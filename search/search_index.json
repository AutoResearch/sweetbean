{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SweetBean","text":"<p>SweetBean is an open-source domain-specific programming language in Python, designed for the declarative specification of stimuli sequences and the synthesis of online jsPsych behavioral experiments. With SweetBean, researchers can conveniently specify experiments once and then compile them into a jsPsych experiment for human participants or text-based experiment for synthetic participants (e.g., large-language models).</p>"},{"location":"#why-sweetbean","title":"Why SweetBean?","text":"<p>In recent years, crowdsourced online experiments have gained immense popularity across behavioral sciences like cognitive psychology, social psychology, and behavioral economics. These experiments offer several advantages, such as:</p> <ul> <li>Faster data collection: gather large datasets in a fraction of the time required for in-person studies at the lab.</li> <li>Increased accessibility: access participants from diverse populations globally.</li> </ul> <p>Despite these benefits, the process of designing and implementing online experiments remains time-consuming and error-prone. Existing tools like jsPsych have made strides in simplifying this process, but there's still a need for a more intuitive solution, in particular for researchers who don't have a background in programming in JavaScript. We address this need with SweetBean.</p> <ul> <li>Declarative language in Python: easily specify the structure and flow of experiments, even with minimal programming experience.</li> <li>Synthetic participant support: Integrate large-language models as synthetic participants for pilot studies, generating synthetic data   to test hypotheses or fine-tune models.</li> </ul>"},{"location":"#overview","title":"Overview","text":"<ul> <li>Basic Tutorials This will get you started with SweetBean.</li> <li>Use Case Tutorials Examples on how SweetBean can be used.</li> <li>User Guide An overview of SweetBean features.</li> <li>Code References A reference guide to the different classes and functions in SweetBean.</li> </ul>"},{"location":"#sweetbean-is-growing","title":"SweetBean is Growing","text":"<p> Our philosophy is rooted in continuous evolution and user-driven development. The initial set of features was based on a word cloud to identify frequently used features of behavioral experiments, but we are always adding new features and stimuli based on the needs of our team and collaborators. If you have any suggestions or feature requests, please feel free to reach out to us via e-mail (ystrittmatter@princeton.edu) or create an issue on our GitHub repository (https://github.com/AutoResearch/sweetbean/issues). We are constantly seeking feedback and looking for ways to improve the language.</p>"},{"location":"#automated-documentation","title":"Automated Documentation","text":"<p>SweetBean is designed with automated documentation in mind. The declarative nature of the language is specifically designed to enable automated translations between code and natural language. Additionally, SweetBean can generate images of stimulus sequences, which may serve as figures in the method section of a paper.</p>"},{"location":"#coming-soon","title":"Coming Soon","text":"<ul> <li>Stimulus enhancement: Language model support for ROK</li> <li>Additional synthetic participants: Support for vision models as synthetic participants</li> <li>Automated Documentation: Automatically generate a method section from code via large language models</li> <li>Additional stimuli: Support for new stimuli types based on the cognitive paradigm ontology.</li> <li>Next: Trolley Problem</li> </ul>"},{"location":"#when-things-go-wrong","title":"When Things Go Wrong","text":"<p>SweetBean is a work in progress, and we are constantly working to improve the language and its documentation. </p> <p>However, sometimes the resulting JavaScript code from a SweetBean experiment might not work as expected. The first step to troubleshoot such issues is to check the generated JavaScript code itself. In most cases, a syntax error in the JavaScript code is the root cause of the problem. If you identify such an issue, we encourage you to open an issue on our GitHub repository and include both the SweetBean code causing the issue and the translation.</p> <p>If there is no syntax error, but the code is still not running as expected, you might want to try to debug your code. You can use the browser's developer tools to identify the issue. If you are not familiar with debugging JavaScript code, we recommend checking out the Mozilla Developer Network for a comprehensive guide on JavaScript debugging. If you think there is a bug in SweetBean, please open an issue on our GitHub repository.</p>"},{"location":"#discover-more-from-our-suite-of-tools","title":"Discover More from Our Suite of Tools","text":"<p>SweetBean is just one part of a powerful set of tools designed to streamline and enhance the behavioral research process. It can be used as a standalone product but is most powerful when used in conjunction with our other tools:</p> <ul> <li> <p>SweetPea: A Python toolbox for the automated generation of counterbalanced experimental designs with similar syntax as SweetBean. Create complex counterbalanced trial sequences with SweetPea and then use SweetBean to implement them in online experiments.</p> </li> <li> <p>AutoRA: A Python platform for automated behavioral research, helping you design, execute and analyze behavioral experiments in a closed loop. Experiments created with SweetBean can be implemented via AutoRA to collect data from human participants. Even if you are not planning to automate your research in a closed loop, AutoRA can help you set up and run experiments without the need of your own server and collect data from real participants via Prolific.</p> </li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you would like to reference SweetBean in a publication, you can use the following BibTeX entry referencing the associated publication in the Journal of Open Source Software:</p> <pre><code>@article{Strittmatter2025, doi = {10.21105/joss.07703},\nauthor = {Younes Strittmatter and Sebastian Musslick},\ntitle = {SweetBean: A declarative language for behavioral experiments with human and artificial participants},\nurl = {https://doi.org/10.21105/joss.07703}, \nyear = {2025}, \npublisher = {The Open Journal}, \nvolume = {10}, \nnumber = {107}, \npages = {7703}, \njournal = {Journal of Open Source Software},\ndoi = {10.21105/joss.07703}\n}\n</code></pre>"},{"location":"#citation_1","title":"Citation","text":"<p>If you would like to reference SweetBean in a publication, you can use the following BibTeX entry referencing the associated publication in the Journal of Open Source Software:</p> <pre><code>@article{Strittmatter2025, doi = {10.21105/joss.07703},\nauthor = {Younes Strittmatter and Sebastian Musslick},\ntitle = {SweetBean: A declarative language for behavioral experiments with human and artificial participants},\nurl = {https://doi.org/10.21105/joss.07703}, \nyear = {2025}, \npublisher = {The Open Journal}, \nvolume = {10}, \nnumber = {107}, \npages = {7703}, \njournal = {Journal of Open Source Software},\ndoi = {10.21105/joss.07703}\n}\n</code></pre>"},{"location":"#about","title":"About","text":"<p>This project is in active development by the Autonomous Empirical Research Group, Lead Designer Younes Strittmatter, led by Sebastian Musslick.</p> <p>This research program was supported by Schmidt Science Fellows, in partnership with the Rhodes Trust, as well as the Carney BRAINSTORM program at Brown University.</p>"},{"location":"Announcement/","title":"Announcement","text":"<ul> <li>Stimulus enhancement: Language model support for ROK</li> <li>Additional synthetic participants: Support for vision models as synthetic participants</li> <li>Automated Documentation: Automatically generate a method section from code via large language models</li> <li>Additional stimuli: Support for new stimuli types based on the cognitive paradigm ontology.</li> <li>Next: Trolley Problem</li> </ul>"},{"location":"CONTRIBUTING/","title":"Contributor Guide","text":"<p>The SweetBean project is a living project that is always looking for contributors. You can contribute to the project in many ways, for example, but not limited to:</p>"},{"location":"CONTRIBUTING/#reporting-issues","title":"Reporting Issues","text":"<p>If you find a bug or have a feature request, please don't hesitate to open an issue on the GitHub Issues.</p>"},{"location":"CONTRIBUTING/#contributing-code-or-documentation","title":"Contributing Code or Documentation","text":"<p>If you want to contribute code, please follow the steps below:</p> <ol> <li>Fork the repository.</li> <li>Make your changes.</li> <li>Create a pull request.</li> </ol>"},{"location":"CONTRIBUTING/#code","title":"Code","text":"<p>Every part of the codebase is open for contributions. But there are some areas where contributions are especially welcome and easy to make:</p>"},{"location":"CONTRIBUTING/#new-stimuli","title":"New Stimuli","text":"<p>If you want to implement a new stimulus, you can do so by creating a new class in the <code>sweetbean/stimulus</code> directory. You can use the existing template that is available in the <code>sweetbean/stimulus/_Template_.py</code> file as guidance. </p> <p>The most straight forward stimuli to implement are jsPsych or jsPsych-contrib stimuli. Be aware, that SweetBean uses jsPsych 7.3.0 as a backend for the web-based experiments. If you want to implement other stimuli, this is also possible but requires more work. You would first need to implement a stimulus compatible with jsPsych in JavaScript and then create the SweetBean wrapper for it.</p>"},{"location":"CONTRIBUTING/#add-features-to-existing-stimuli","title":"Add Features to Existing Stimuli","text":"<p>In some of the stimuli not all features are implemented. For example, some stimuli don't provide support for running them as language experiments. You can add this feature to the existing stimuli.</p>"},{"location":"CONTRIBUTING/#documentation","title":"Documentation","text":"<p>Some parts of the documentation are incomplete. You can help by adding more examples or by adding docstrings to the codebase.</p>"},{"location":"CONTRIBUTING/#examples-and-use-cases","title":"Examples and Use Cases","text":"<p>You can add simple examples that showcase a single stimulus in the <code>docs\\Stimuli</code> folder. If you want to showcase a more complex use case, you can add a new folder in the <code>docs\\Use Case Tutorials</code> directory.</p>"},{"location":"CONTRIBUTING/#providing-data-and-experiment-examples","title":"Providing Data and Experiment Examples","text":"<p>If you use SweetBean in your research, consider sharing the raw SweetBean data with us and the community in this repository. But be aware that your data might be used to train machine learning models. For example, to improve the models that are used as synthetic participants in SweetBean or for coming features such as automatic documentation of the experiment.</p>"},{"location":"CONTRIBUTING/#feedback","title":"Feedback","text":"<p>If you have any feedback, questions or suggestions you can also reach out to the developers via e-mail: ystrittmatter@princeton.edu</p>"},{"location":"installation/","title":"Installation &amp; Compatibility","text":""},{"location":"installation/#installation","title":"Installation","text":"<p>The package is available on PyPI and can be installed via pip:</p> <pre><code>pip install sweetbean\n</code></pre>"},{"location":"installation/#compatibility","title":"Compatibility","text":"<p>SweetBean is compatible with the following version of jsPsych:</p> <ul> <li>jsPsych: <code>7.x</code> </li> </ul>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>Sweetbean has the following dependencies that need to be installed on your system:</p> <ul> <li>Python: <code>&gt;=3.9, &lt;4.0</code> </li> <li>java</li> </ul> <p>Other versions may work but are not officially supported. If you experience issues, please report them!</p>"},{"location":"installation/#python-dependencies","title":"Python Dependencies","text":"<p>The following Python packages are required and will be installed automatically via <code>pip</code>:</p> <ul> <li><code>jinja2</code></li> <li><code>transcrypt</code></li> <li><code>pyppeteer</code></li> <li><code>pillow</code></li> </ul>"},{"location":"installation/#jspsych-plugins","title":"jsPsych Plugins","text":"<p>SweetBean does not support all jsPsych plugins, but new plugins are added regularly. If you need support for a specific jsPsych plugin, please open an issue here.</p>"},{"location":"Basic%20Tutorials/","title":"Basic Tutorials","text":"<p>From Zero to Hero in seven tutorials.</p> <p>In seven lessons, you learn everything that you need to know to create a behavioral experiment with SweetBean. At the end you will know how different variable types in SweetBean work and how to use them to create a task switching experiment with Stroop stimuli.</p>"},{"location":"Basic%20Tutorials/%281%29%20First%20Experiment/","title":"(1) First Experiment","text":"In\u00a0[\u00a0]: Copied! <pre># installing the package\n!pip install sweetbean\n</pre> # installing the package !pip install sweetbean In\u00a0[\u00a0]: Copied! <pre># import the functionality from sweetbean to create a text stimulus\nfrom sweetbean.stimulus import Text\n\n# create an introduction\nintroduction_stimulus = Text(text='Welcome to our awesome experiment.')\n</pre> # import the functionality from sweetbean to create a text stimulus from sweetbean.stimulus import Text  # create an introduction introduction_stimulus = Text(text='Welcome to our awesome experiment.') In\u00a0[\u00a0]: Copied! <pre># import the functionality from sweetbean to create a block\nfrom sweetbean import Block\n\n# create a list of stimuli for the block\nintroduction_list = [introduction_stimulus]\n\n# create the block\nintroduction_block = Block(introduction_list)\n</pre> # import the functionality from sweetbean to create a block from sweetbean import Block  # create a list of stimuli for the block introduction_list = [introduction_stimulus]  # create the block introduction_block = Block(introduction_list) In\u00a0[\u00a0]: Copied! <pre># import the functionality from sweetbean to create experiments\nfrom sweetbean import Experiment\n\n# create a list of blocks\nblock_list = [introduction_block]\n\n# create the experiment\nexperiment = Experiment(block_list)\n</pre> # import the functionality from sweetbean to create experiments from sweetbean import Experiment  # create a list of blocks block_list = [introduction_block]  # create the experiment experiment = Experiment(block_list) In\u00a0[\u00a0]: Copied! <pre># the functionality to create a html is a method of the experiment class. It expects a filename as input and creates the experiment we declared earlier.\nexperiment.to_html('index.html')\n</pre> # the functionality to create a html is a method of the experiment class. It expects a filename as input and creates the experiment we declared earlier. experiment.to_html('index.html') <p>If you run this file in google colab, you can locate the newly created file in the \"files\" tab (left side of your screen). This HTML file is ready to be viewed in any web browser of your choice.</p>"},{"location":"Basic%20Tutorials/%281%29%20First%20Experiment/#1-first-experiment","title":"(1) First Experiment\u00b6","text":"<p>Here, we learn how to create a very simple experiment consisting of a single text stimulus. We get familiar with installing the package and loading different functionality. Then we create a stimulus and get used to how to organize stimuli into blocks and the blocks into an experiment.</p>"},{"location":"Basic%20Tutorials/%281%29%20First%20Experiment/#installing-sweetbean","title":"Installing SweetBean\u00b6","text":"<p>In python, we can make use of packages that are created by the community. To use them, we need to install them first. We use pip, a package manager for python, to install the package.</p> Optional: Packages and Virtual Environments in Python It is best to use virtual environments when using packages in python on your own computer (not in google colab). A virtual environment is an isolated environment for a Python project that contains its own Python interpreter and set of installed packages. Creating a virtual environment allows for a clean separation between projects and their dependencies, which helps avoid conflicts between different versions of the same package required by different projects. Many IDEs (Integrated Development Environments) like PyCharm, Visual Studio Code, or Spyder let you manage these virtual environments via the graphical user interface. If you prefer working in a console, you can create virtual environments using tools such as venv or virtualenv."},{"location":"Basic%20Tutorials/%281%29%20First%20Experiment/#creating-a-stimulus","title":"Creating a stimulus\u00b6","text":"<p>We now create our first stimulus \u2014 a text greeting the participant. First, we need to import the functionality from SweetBean to create such a stimulus, and then we specify the stimulus.</p> <p>There are multiple different stimuli types in SweetBean with varying sets of parameters. Here, we start with a text stimulus with the single feature text.</p> Optional: Imports in Python After importing a feature, it will be available in the rest of the file. Importing has to be done only once. There are multiple ways of importing functionality from packages \u2014 all with their own advantages and disadvantages. Here, we use the \"from\" keyword to import only the desired functionality from the SweetBean package, which makes our code more readable and avoids potential naming conflicts. In the subsequent tutorials, we will show other ways of importing."},{"location":"Basic%20Tutorials/%281%29%20First%20Experiment/#creating-a-block","title":"Creating a block\u00b6","text":"<p>In SweetBean, an experiment consists of blocks, while blocks themselves consist of stimuli.</p> <p>For example, the first part of an experiment typically contains informed consent and instructions for the participants. In SweetBean, this can be achieved by assembling a sequence of text stimuli.</p> <p>The second block of the experiment could then consist of training trials, the following blocks could be experimental blocks with target trials, and the last block of the experiment could be a debriefing block where we again show text stimuli.</p> <p>Here, we have a simple block consisting only of a single text stimulus.</p> Optional: Why do we use blocks? No one prevents you do describe your experiment as a single sequence of stimuli without organizing them into blocks. The block design has two main advantages. First, it helps with designing the experiment and keeping it structured. Second, we will show functionality to loop over blocks in the following tutorials making it possible to define an experimental block and only change specific features of the stimuli."},{"location":"Basic%20Tutorials/%281%29%20First%20Experiment/#creating-the-experiment","title":"Creating the experiment\u00b6","text":"<p>Now that we have a block, we can create a full experiment from this single block.</p>"},{"location":"Basic%20Tutorials/%281%29%20First%20Experiment/#exporting-the-experiment-in-html-format","title":"Exporting the experiment in html format\u00b6","text":"<p>Finally, we create our html file from the experiment.</p> Optional: Hosting and storing the data There are multiple ways to host the experiment and store the data. For example, you can run the experiment on your own server (if your university provides such a service). But there are also free services where you can host a website like this. For example, Firebase provides the functionality of hosting a website and storing data. Honeycomb is a template for reproducible psychophysiological tasks that can be run online and uses Firebase. It is maintained by the Center for Computation and Visualization and the Neuromotion Lab at Brown University. Future iterations of SweetBean will contain functionality to export the experiment to files that can be used in conjunction with Honeycomb."},{"location":"Basic%20Tutorials/%282%29%20Instruction%20Block/","title":"(2) Instruction Block","text":"In\u00a0[\u00a0]: Copied! <pre># Enter your code here:\n</pre> # Enter your code here: In\u00a0[\u00a0]: Copied! <pre>!pip install sweetbean\n</pre> !pip install sweetbean In\u00a0[\u00a0]: Copied! <pre># Enter your code here:\n</pre> # Enter your code here: In\u00a0[\u00a0]: Copied! <pre>from sweetbean.stimulus import Text\n</pre> from sweetbean.stimulus import Text In\u00a0[\u00a0]: Copied! <pre>introduction_stimulus_timed = Text(duration=4000, text='Welcome to our awesome experiment.&lt;br&gt;The introduction will start in 4s.')\n</pre> introduction_stimulus_timed = Text(duration=4000, text='Welcome to our awesome experiment.The introduction will start in 4s.') <p>By adding the duration parameter, this stimulus will now be shown 4000ms.</p> Optional: What is that &amp;ltbr&gt; - tag in the text parameter? The text parameter in a text stimulus is a HTML-text and we can use HTML-code to create it. The &amp;ltbr&gt; tag marks a line break.  In\u00a0[\u00a0]: Copied! <pre>introduction_stimulus_respond = Text(text=\"This is a very detailed explanation of our experiment.&lt;br&gt;Press SPACE to continue.\", choices=[' '])\n</pre> introduction_stimulus_respond = Text(text=\"This is a very detailed explanation of our experiment.Press SPACE to continue.\", choices=[' ']) <p>The choices parameter expects a list of characters. Here, we chose the SPACE character (whitespace). We can also add more or different characters. For example, can you write a stimulus that asks for the participants handedness and accepts the letters <code>r</code>, <code>l</code> or <code>o</code> as choices?</p> In\u00a0[\u00a0]: Copied! <pre># Replace None in the following line:\nintroduction_survey_handedness = None\n</pre> # Replace None in the following line: introduction_survey_handedness = None In\u00a0[\u00a0]: Copied! <pre>introduction_survey_handedness = Text(text=\"What is your handedness?&lt;br&gt;Press R for right, L for left, or O for other.\", choices=['r', 'l', 'o'])\n</pre> introduction_survey_handedness = Text(text=\"What is your handedness?Press R for right, L for left, or O for other.\", choices=['r', 'l', 'o']) In\u00a0[\u00a0]: Copied! <pre># Enter your code:\n</pre> # Enter your code: In\u00a0[\u00a0]: Copied! <pre># import the functionality from sweetbean to create a block\nfrom sweetbean import Block\n\n# create a list of stimuli for the block\nintroduction_list = [introduction_stimulus_timed, introduction_stimulus_respond, introduction_survey_handedness]\n\n# create the block\nintroduction_block = Block(introduction_list)\n</pre> # import the functionality from sweetbean to create a block from sweetbean import Block  # create a list of stimuli for the block introduction_list = [introduction_stimulus_timed, introduction_stimulus_respond, introduction_survey_handedness]  # create the block introduction_block = Block(introduction_list) In\u00a0[\u00a0]: Copied! <pre># Enter your code:\n</pre> # Enter your code: In\u00a0[\u00a0]: Copied! <pre># import the functionality from sweetbean to create experiments\nfrom sweetbean import Experiment\n\n# create a list of blocks\nblock_list = [introduction_block]\n\n# create the experiment\nexperiment = Experiment(block_list)\n</pre> # import the functionality from sweetbean to create experiments from sweetbean import Experiment  # create a list of blocks block_list = [introduction_block]  # create the experiment experiment = Experiment(block_list) In\u00a0[\u00a0]: Copied! <pre># Enter your code:\n</pre> # Enter your code: In\u00a0[\u00a0]: Copied! <pre># create the html file.\nexperiment.to_html('index.html')\n</pre> # create the html file. experiment.to_html('index.html')"},{"location":"Basic%20Tutorials/%282%29%20Instruction%20Block/#2-instruction-block","title":"(2) Instruction Block\u00b6","text":"<p>Here, we learn how to create an instruction block. We creat a block greeting the participants and give instruction for the tasks. We get familiar with the different options to customize text stimuli.</p>"},{"location":"Basic%20Tutorials/%282%29%20Instruction%20Block/#installing-sweetbean","title":"Installing sweetbean\u00b6","text":"<p>Do you remember how to install the package?</p>"},{"location":"Basic%20Tutorials/%282%29%20Instruction%20Block/#solution","title":"Solution\u00b6","text":""},{"location":"Basic%20Tutorials/%282%29%20Instruction%20Block/#creating-text-stimuli","title":"Creating text stimuli\u00b6","text":"<p>Do you remember how to import the functionality to create text stimuli?</p>"},{"location":"Basic%20Tutorials/%282%29%20Instruction%20Block/#solution","title":"Solution\u00b6","text":""},{"location":"Basic%20Tutorials/%282%29%20Instruction%20Block/#adding-features-to-text-stimuli","title":"Adding features to text stimuli\u00b6","text":"<p>This time, we want to add more functionality to our stimulus. Remember:</p> <pre><code>introduction_stimulus = Text(text='Welcome to our awesome experiment.')\n</code></pre>"},{"location":"Basic%20Tutorials/%282%29%20Instruction%20Block/#duration","title":"Duration\u00b6","text":"<p>This stimulus has only one single parameter. The text parameter that defines what text is shown. But as we defined it, this stimulus would be shown indefinitely until the user closes the browser. To change this, we can add a duration parameter. The duration parameter is accepted by most stimuli types in SweetBean. It defines how long a stimulus is shown in ms.</p>"},{"location":"Basic%20Tutorials/%282%29%20Instruction%20Block/#responses","title":"Responses\u00b6","text":"<p>The timing of a stimulus is useful, but what if the for example, the introduction text is very long, and we want to give the participant the freedom to proceed whenever ready?</p> <p>For this purpose we can define a list of choices. These are keys on the keyboard, that will be recorded when the user presses them. They also end the current stimulus.</p>"},{"location":"Basic%20Tutorials/%282%29%20Instruction%20Block/#solution","title":"Solution\u00b6","text":""},{"location":"Basic%20Tutorials/%282%29%20Instruction%20Block/#survey-tool","title":"Survey Tool\u00b6","text":"<p>The described way to ask for demographic data is just a demonstration. SweetBean has extra functionality to conduct surveys and to design questionnaires.</p>"},{"location":"Basic%20Tutorials/%282%29%20Instruction%20Block/#creating-a-block","title":"Creating a block\u00b6","text":"<p>Do you remember how to create a block with the stimuli?</p>"},{"location":"Basic%20Tutorials/%282%29%20Instruction%20Block/#solution","title":"Solution\u00b6","text":""},{"location":"Basic%20Tutorials/%282%29%20Instruction%20Block/#creating-the-experiment","title":"Creating the experiment\u00b6","text":"<p>Do you remember how to create the experiment?</p>"},{"location":"Basic%20Tutorials/%282%29%20Instruction%20Block/#solution","title":"Solution\u00b6","text":""},{"location":"Basic%20Tutorials/%282%29%20Instruction%20Block/#exporting-the-experiment-in-html-format","title":"Exporting the experiment in html format\u00b6","text":"<p>Do you remember how to export the experiment to html?</p>"},{"location":"Basic%20Tutorials/%282%29%20Instruction%20Block/#solution","title":"Solution\u00b6","text":""},{"location":"Basic%20Tutorials/%283%29%20Trial%20Block/","title":"(3) Trial Block","text":"In\u00a0[\u00a0]: Copied! <pre>!pip install sweetbean\n</pre> !pip install sweetbean In\u00a0[\u00a0]: Copied! <pre>timeline = [\n    {'color': 'red', 'word': 'RED'},\n    {'color': 'green', 'word': 'RED'},\n    {'color': 'green', 'word': 'GREEN'},\n    {'color': 'red', 'word': 'GREEN'},\n]\n</pre> timeline = [     {'color': 'red', 'word': 'RED'},     {'color': 'green', 'word': 'RED'},     {'color': 'green', 'word': 'GREEN'},     {'color': 'red', 'word': 'GREEN'}, ] In\u00a0[\u00a0]: Copied! <pre># import the functionality from sweetbean\nfrom sweetbean.variable import TimelineVariable\n\n## declare the timeline variables\n\n# color: The name has to be color (it is the name in the timeline)\ncolor = TimelineVariable(name=\"color\")\n\n# word: The name has to be word (it is the name in the timeline), and it has the levels RED and GREEN\nword = TimelineVariable(name=\"word\")\n</pre> # import the functionality from sweetbean from sweetbean.variable import TimelineVariable  ## declare the timeline variables  # color: The name has to be color (it is the name in the timeline) color = TimelineVariable(name=\"color\")  # word: The name has to be word (it is the name in the timeline), and it has the levels RED and GREEN word = TimelineVariable(name=\"word\") Optional: Why can we not just use the timeline and have to declare the TimelineVariables separately? In a real experiment often times, you don't want to use static timelines that you have to declare in the code. Instead you want to load timelines from a file or from a database. For example, you could upload timeline sequences to a database and then use a different one for each participant. Therefore sweetbean needs to be able to handle timelines that are not yet defined. We only need to declare the timeline variables to produce working JavaScript code. The loading of the timeline can be done at runtime (e.g., when a participant visits our page)  In\u00a0[\u00a0]: Copied! <pre># importing the functionality\nfrom sweetbean.stimulus import Text, Blank\n\n## declaring the different stimuli\n\n# fixation onset (a blank screen for 600ms)\nfixation_onset = Blank(duration=600)\n\n# fixation cross (the character \"+\" shown for 800ms)\nfixation = Text(duration=800, text=\"+\")\n\n# stimulus onset (a blank screen shown for 200ms)\nstimulus_onset = Blank(duration=200)\n\n# the Stroop stimulus. Here instead of fixed parameters, we use the timeline variables, that we defined previously.\nstroop = Text(duration=2500, text=word, color=color)\n</pre> # importing the functionality from sweetbean.stimulus import Text, Blank  ## declaring the different stimuli  # fixation onset (a blank screen for 600ms) fixation_onset = Blank(duration=600)  # fixation cross (the character \"+\" shown for 800ms) fixation = Text(duration=800, text=\"+\")  # stimulus onset (a blank screen shown for 200ms) stimulus_onset = Blank(duration=200)  # the Stroop stimulus. Here instead of fixed parameters, we use the timeline variables, that we defined previously. stroop = Text(duration=2500, text=word, color=color) <p>Note that for this example, we also used a new parameter <code>color</code> for the text stimulus that we haven't used before.</p> In\u00a0[\u00a0]: Copied! <pre>timeline = [\n    {'color': 'red', 'word': 'RED', 'soa': 300},\n    {'color': 'green', 'word': 'GREEN', 'soa': 200 },\n    {'color': 'green', 'word': 'RED', 'soa': 400},\n    {'color': 'red', 'word': 'GREEN', 'soa': 500},\n]\n</pre> timeline = [     {'color': 'red', 'word': 'RED', 'soa': 300},     {'color': 'green', 'word': 'GREEN', 'soa': 200 },     {'color': 'green', 'word': 'RED', 'soa': 400},     {'color': 'red', 'word': 'GREEN', 'soa': 500}, ] In\u00a0[\u00a0]: Copied! <pre># Enter your code here:\n</pre> # Enter your code here: In\u00a0[\u00a0]: Copied! <pre># declare the timeline variable\nsoa = TimelineVariable(name='soa')\n\n# use the timeline variable in the stimulus instead of the fixed value\nstimulus_onset = Blank(duration=soa)\n</pre> # declare the timeline variable soa = TimelineVariable(name='soa')  # use the timeline variable in the stimulus instead of the fixed value stimulus_onset = Blank(duration=soa) In\u00a0[\u00a0]: Copied! <pre># import the functionality from sweetbean to create a block\nfrom sweetbean import Block\n\n# create a list of stimuli for the block\nstimulus_sequence = [fixation_onset, fixation, stimulus_onset, stroop]\n\n# create the block\nstroop_block = Block(stimulus_sequence, timeline)\n</pre> # import the functionality from sweetbean to create a block from sweetbean import Block  # create a list of stimuli for the block stimulus_sequence = [fixation_onset, fixation, stimulus_onset, stroop]  # create the block stroop_block = Block(stimulus_sequence, timeline) Optional: Python keyword arguments Maybe you have noticed that in the declaration of the stimuli we used a slightly different syntax then in the declaration of the block. When defining the stimuli, we use equal signs to declare the different aspects of the stimulus, while no such equal signs are used in the declaration of the block. <code> stroop = TextStimulus(duration=2500, text=word, color=color) block = Block(stimulus_sequence, timeline) </code> In the stimulus definition, we use so called keyword arguments, while we don't use them in the block. But, we can also define the stimuli without the keywords or define the Block with the use of keyword arguments. If we don't use the keyword arguments, we must enter parameter in the order as they are defined in the class.  <code> stroop = TextStimulus(2500, word, color) block = Block(stimuli=stimulus_sequence, timeline=timeline) </code> In\u00a0[\u00a0]: Copied! <pre># import the functionality from sweetbean to create experiments\nfrom sweetbean import Experiment\n\n# create a list of blocks\nblock_list = [stroop_block]\n\n# create the experiment\nexperiment = Experiment(block_list)\n\n# export to html\nexperiment.to_html('index.html')\n</pre> # import the functionality from sweetbean to create experiments from sweetbean import Experiment  # create a list of blocks block_list = [stroop_block]  # create the experiment experiment = Experiment(block_list)  # export to html experiment.to_html('index.html')  <pre><code># this functionality depends on addiditional functionalities that are not in the core package of sweetbean. We need to install these optional dependencies\n!pip install html2image\n!pip install pillow\n!pip install numpy\n!pip install opencv-python\n</code></pre> <pre><code># import the functionality\nfrom sweetbean.sequence import sequence_to_image\n\n# we can now create the image by providing additional arguments that are the labels of the images\nsequence_to_image(stroop_block, durations=['600', '800', '200-500', '2500'])\n</code></pre>"},{"location":"Basic%20Tutorials/%283%29%20Trial%20Block/#3-trial-block","title":"(3) Trial Block\u00b6","text":"<p>Here, we learn how to use a timeline to create a block of trials for the Stroop task, (Stroop, 1935). In the Stroop task, participants are typically asked to name the color in which a color word is displayed (e.g., say <code>green</code> to the word RED displayed in green). We create an experiment that loops through the following stimulus sequence while varying the ink color and the word of the color word.</p>"},{"location":"Basic%20Tutorials/%283%29%20Trial%20Block/#installing-sweetbean","title":"Installing sweetbean\u00b6","text":""},{"location":"Basic%20Tutorials/%283%29%20Trial%20Block/#creating-a-timeline","title":"Creating a timeline\u00b6","text":"<p>Instead of defining a stimulus for each trial, we can create a timeline of stimulus features. In this case, we define the color and the word of a trial in a timeline. The timeline bellow defines the trial sequence</p> <p>RED, GREEN, RED, GREEN</p>"},{"location":"Basic%20Tutorials/%283%29%20Trial%20Block/#sweetpea","title":"SweetPea\u00b6","text":"Optional: Using SweetPea to produce the timeline SweetPea is an open-source declarative language in Python, in which researchers can describe their desired experiment as a set of factors and constraints. It has a very similar syntax to SweetBean and there are similar tutorials to this one that can help you to create counterbalanced sequences of trials. For an example of how to use SweetPea in conjunction with SweetBean, see this example."},{"location":"Basic%20Tutorials/%283%29%20Trial%20Block/#declare-timelinevariables","title":"Declare TimelineVariables\u00b6","text":"<p>To use the timeline declared above we need to declare timeline variables. You can use these variables to parameterize stimuli, rather than parameterizing them with static values. In this way, stimuli can be defined in terms of the timeline variables, and the timeline can be used to parameterize the stimuli for each trial.</p>"},{"location":"Basic%20Tutorials/%283%29%20Trial%20Block/#creating-the-stimulus-sequence","title":"Creating the stimulus sequence\u00b6","text":"<p>Now we create a stimulus sequence. When using a timeline, sweetbean can loop through a specified sequence of stimuli as often as there are trials defined in the timeline. Here we want to loop through the sequence:</p> <p>A blank screen first (fixation onset), then the fixation cross, then a blank screen again (stimulus onset), and finally the Stroop stimulus.</p> <p>Here, we also introduce a (rather boring) stimulus: A blank screen</p> Optional: Isn't a text stimulus without text a blank screen?If you want, you can also define a TextStimulus without the text paramater to emulate a blank screen. This is an example to make the programming language easier to read and translate for the use with Natural Language Processing."},{"location":"Basic%20Tutorials/%283%29%20Trial%20Block/#variable-stimulus-onset","title":"Variable Stimulus onset.\u00b6","text":"<p>For the purpouse of sound experimental design, it is often usefull to introduce a variable stimulus onset instead of a fixed one, e.g., to isolate preparation effects from processing effects. With such a variable stimulus onset, a participant can not anticipate the onset of the stimulus.</p> <p>Can you change the code to accommodate for this? To start we already provide the timeline:</p>"},{"location":"Basic%20Tutorials/%283%29%20Trial%20Block/#solution","title":"Solution\u00b6","text":""},{"location":"Basic%20Tutorials/%283%29%20Trial%20Block/#creating-a-block","title":"Creating a block\u00b6","text":"<p>To create the block, all we have to do is add the timeline as parameter</p>"},{"location":"Basic%20Tutorials/%283%29%20Trial%20Block/#creating-the-experiment-and-exporting-it-as-a-html-file","title":"Creating the experiment and exporting it as a html file\u00b6","text":""},{"location":"Basic%20Tutorials/%283%29%20Trial%20Block/#optional-creating-a-depiction-of-the-stimulus-sequence-for-the-method-section","title":"Optional: Creating a depiction of the stimulus sequence for the method section\u00b6","text":"<p>SweetBean provides functionality to help document your experiments. For example, you can create a stimulus timeline as the one seen above. This a picture that shows the succesion of stimulu in your experiment and can help others to understand it.</p> <p>NOTE: This functionality does not work in google colab since we need access to simulate a browser, but you can use it when running SweetBean on your personal computer.</p>"},{"location":"Basic%20Tutorials/%284%29%20Responses%20and%20Feedback/","title":"(4) Responses and Feedback","text":"In\u00a0[\u00a0]: Copied! <pre>!pip install sweetbean\n</pre> !pip install sweetbean <pre>Looking in indexes: https://pypi.org/simple, https://us-python.pkg.dev/colab-wheels/public/simple/\nRequirement already satisfied: sweetbean in /usr/local/lib/python3.8/dist-packages (0.0.19)\n</pre> <p>Now, we are looking to incorporate responses from the participant and response feedback to the experiment. Specifically, we would like the participant to press the key <code>f</code> using their left index finger when the ink color of the color word is red. Similarly, we would like the participant to press the key <code>j</code> with their right index finger when the color is green.</p> <p>You can practice your SweetBean skills by implementing these instructions in a block (if you feel comfortable creating text stimuli you can skip this part and use the instructions block in the solution):</p> In\u00a0[\u00a0]: Copied! <pre># Enter your code here:\n</pre> # Enter your code here: In\u00a0[\u00a0]: Copied! <pre># imports\nfrom sweetbean.stimulus import Text\nfrom sweetbean import Block\n\n# Creating the Instructions\nwelcome = Text(text=\"Welcome to our experiment.&lt;br&gt;Here, you will have to react to the ink color of a color word.&lt;br&gt;Press SPACE to continue\", choices=[' '])\ninstruction_red = Text(text=\"If the ink color is &lt;b&gt;red&lt;b&gt;,&lt;br&gt;press &lt;b&gt;F&lt;b&gt; with your left index finger as fast as possible.&lt;br&gt;Press F to continue\", choices=['f'])\ninstruction_green = Text(text=\"If the ink color is &lt;b&gt;green&lt;b&gt;,&lt;br&gt;press &lt;b&gt;J&lt;b&gt; with your right index finger as fast as possible.&lt;br&gt;Press J to continue\", choices=['j'])\ninstructions_end = Text(text=\"The experiment will start now.&lt;br&gt;React as fast an as accurate as possible.&lt;br&gt;Remember:&lt;br&gt;React to the ink color not the meaning of the word.&lt;br&gt;Ress SPACE to continus\", choices=[' '])\n\n# Creating the stimulus sequence\ninstructions_sequence = [welcome, instruction_red, instruction_green, instructions_end]\n\n# Creating the block\ninstructions_block = Block(instructions_sequence)\n</pre> # imports from sweetbean.stimulus import Text from sweetbean import Block  # Creating the Instructions welcome = Text(text=\"Welcome to our experiment.Here, you will have to react to the ink color of a color word.Press SPACE to continue\", choices=[' ']) instruction_red = Text(text=\"If the ink color is red,press F with your left index finger as fast as possible.Press F to continue\", choices=['f']) instruction_green = Text(text=\"If the ink color is green,press J with your right index finger as fast as possible.Press J to continue\", choices=['j']) instructions_end = Text(text=\"The experiment will start now.React as fast an as accurate as possible.Remember:React to the ink color not the meaning of the word.Ress SPACE to continus\", choices=[' '])  # Creating the stimulus sequence instructions_sequence = [welcome, instruction_red, instruction_green, instructions_end]  # Creating the block instructions_block = Block(instructions_sequence) In\u00a0[\u00a0]: Copied! <pre>timeline = [\n    {'color': 'red', 'word': 'RED'},\n    {'color': 'green', 'word': 'GREEN'},\n    {'color': 'green', 'word': 'RED'},\n    {'color': 'red', 'word': 'GREEN'},\n]\n</pre> timeline = [     {'color': 'red', 'word': 'RED'},     {'color': 'green', 'word': 'GREEN'},     {'color': 'green', 'word': 'RED'},     {'color': 'red', 'word': 'GREEN'}, ] In\u00a0[\u00a0]: Copied! <pre># Enter your code here:\n</pre> # Enter your code here: In\u00a0[\u00a0]: Copied! <pre># import the functionality from sweetbean\nfrom sweetbean.variable import TimelineVariable\n\n## declare the timeline variables\n\n# color: The name has to be color (it is the name in the timeline), and it has the levels red and green\ncolor = TimelineVariable(name=\"color\")\n\n# word: The name has to be word (it is the name in the timeline), and it has the levels RED and GREEN\nword = TimelineVariable(name=\"word\")\n</pre> # import the functionality from sweetbean from sweetbean.variable import TimelineVariable  ## declare the timeline variables  # color: The name has to be color (it is the name in the timeline), and it has the levels red and green color = TimelineVariable(name=\"color\")  # word: The name has to be word (it is the name in the timeline), and it has the levels RED and GREEN word = TimelineVariable(name=\"word\")  In\u00a0[\u00a0]: Copied! <pre># defining the predicate for the f-level of the \"correct response\" parameter\ndef correct_key_fct(cl):\n    return 'f' if cl == 'red' else 'j'\n</pre> # defining the predicate for the f-level of the \"correct response\" parameter def correct_key_fct(cl):     return 'f' if cl == 'red' else 'j'  <p>Some people might have trouble understanding the code above. A equivalent writing with an if and else statement is:</p> <pre><code>def correct_key_fct(color):\n  if color == 'red':\n    return 'f'\n  else:\n    return 'j'\n</code></pre> Optional: Python is whitespace sensitive!In contrast to many other programming languages, Python is whitespace sensitive. Whitespaces in Python do matter and are used to block the code, for example to define functions, in loops or blocks of if-else statements. In that sense they are equivalent to the curly brackets '{}' in Java, JavaScript, C++ and many other programming languages.  In\u00a0[\u00a0]: Copied! <pre># importing the functionality\nfrom sweetbean.variable import FunctionVariable\n\n# declare the variable\ncorrect_key = FunctionVariable('correct_key', correct_key_fct, [color])\n</pre> # importing the functionality from sweetbean.variable import FunctionVariable  # declare the variable correct_key = FunctionVariable('correct_key', correct_key_fct, [color]) In\u00a0[\u00a0]: Copied! <pre># imports\nfrom sweetbean.stimulus import Text\n\n# declaring the stimulus\nstroop = Text(duration=2500, text=word, color=color, choices=['j', 'f'], correct_key=correct_key)\n</pre> # imports from sweetbean.stimulus import Text  # declaring the stimulus stroop = Text(duration=2500, text=word, color=color, choices=['j', 'f'], correct_key=correct_key) <p>This is a stimulus that shows a color word in the color and with the word provided by the timeline. The stimulus is shown for 2500ms or till a response is given. The user can press either <code>j</code> or <code>f</code>.</p> Comprehension question: Can you think of another way to get the correct_key parameter that doesnt' depend on a function variable?Here, we used the derived paramter to demonstrate how it is used. But we could also simply add the keys to the timeline and use a timeline varibale insted. Often times, there are multiple ways of implementing a desired experiment. In\u00a0[\u00a0]: Copied! <pre># import\nfrom sweetbean.variable import DataVariable\n\n# declare the data variable\ncorrect = DataVariable('correct', 1)\n</pre> # import from sweetbean.variable import DataVariable  # declare the data variable correct = DataVariable('correct', 1) In\u00a0[\u00a0]: Copied! <pre># define the function\ndef get_feedback(was_correct):\n    if was_correct:\n        return 'That was correct!'\n    return 'That was incorrect!'\n</pre> # define the function def get_feedback(was_correct):     if was_correct:         return 'That was correct!'     return 'That was incorrect!'  In\u00a0[\u00a0]: Copied! <pre>feedback_text = FunctionVariable('feedback_text', get_feedback, [correct])\n</pre> feedback_text = FunctionVariable('feedback_text', get_feedback, [correct]) Comprehension question: Can you think of another way to get the feeback word parameter that doesnt' depend on a derived paramter?Here, we can not use a timeline, since this is an adaptive parameter. We have to use the derived parameter and the data variable since we have use information derived from user input. In\u00a0[\u00a0]: Copied! <pre># Enter your code:\n# ...\nfeedback_color = None\n</pre> # Enter your code: # ... feedback_color = None In\u00a0[\u00a0]: Copied! <pre># create the levels\ndef get_feedback_color(was_correct):\n    return 'green' if was_correct else 'red'\n\nfeedback_color = FunctionVariable('feedback_color', get_feedback_color, [correct])\n</pre> # create the levels def get_feedback_color(was_correct):     return 'green' if was_correct else 'red'  feedback_color = FunctionVariable('feedback_color', get_feedback_color, [correct]) In\u00a0[\u00a0]: Copied! <pre>feedback = Text(duration=1000, text=feedback_text,color=feedback_color)\n</pre> feedback = Text(duration=1000, text=feedback_text,color=feedback_color) In\u00a0[\u00a0]: Copied! <pre># Enter your code:\n</pre> # Enter your code: In\u00a0[\u00a0]: Copied! <pre># import the functionality from sweetbean to create experiments\nfrom sweetbean import Block, Experiment\n\n# fixation stimulus\nfixation = Text(800, '+')\n\n# create a stimulus sequence\nstimulus_sequence = [fixation, stroop, feedback]\n\n# create the trial block\ntrial_block = Block(stimulus_sequence, timeline)\n\n# create the experiment from the two blocks\nexperiment = Experiment([instructions_block, trial_block])\n\n# export to the html file\nexperiment.to_html('index.html')\n</pre> # import the functionality from sweetbean to create experiments from sweetbean import Block, Experiment  # fixation stimulus fixation = Text(800, '+')  # create a stimulus sequence stimulus_sequence = [fixation, stroop, feedback]  # create the trial block trial_block = Block(stimulus_sequence, timeline)  # create the experiment from the two blocks experiment = Experiment([instructions_block, trial_block])  # export to the html file experiment.to_html('index.html')"},{"location":"Basic%20Tutorials/%284%29%20Responses%20and%20Feedback/#4-responses-and-feedback","title":"(4) Responses and Feedback\u00b6","text":"<p>Here, we learn how to add a feedback stimulus indicating a correct or false response.</p>"},{"location":"Basic%20Tutorials/%284%29%20Responses%20and%20Feedback/#installing-sweetbean","title":"Installing sweetbean\u00b6","text":""},{"location":"Basic%20Tutorials/%284%29%20Responses%20and%20Feedback/#solution","title":"Solution\u00b6","text":""},{"location":"Basic%20Tutorials/%284%29%20Responses%20and%20Feedback/#creating-a-timeline","title":"Creating a timeline\u00b6","text":""},{"location":"Basic%20Tutorials/%284%29%20Responses%20and%20Feedback/#declare-timelinevariables","title":"Declare TimelineVariables\u00b6","text":"<p>Do you remember how to declare the timeline variables(if you feel comfortable creating timeline variables, you can skip this part and use the solution)?</p>"},{"location":"Basic%20Tutorials/%284%29%20Responses%20and%20Feedback/#solution","title":"Solution\u00b6","text":""},{"location":"Basic%20Tutorials/%284%29%20Responses%20and%20Feedback/#creating-function-variables","title":"Creating function variables\u00b6","text":"<p>In SweetBean, in addition to static parameters and timeline parameters, we can also use function parameters. These are parameters, that derive from other features of the trial. Here, we want to derive the correct key from the ink color of the stimulus. Remember: <code>f</code> for red color words and <code>j</code> for green color words.</p>"},{"location":"Basic%20Tutorials/%284%29%20Responses%20and%20Feedback/#defining-the-functions","title":"Defining the functions\u00b6","text":"<p>We can first create a function that returns the correct key for a given color:</p>"},{"location":"Basic%20Tutorials/%284%29%20Responses%20and%20Feedback/#creating-the-function-variable-levels","title":"Creating the function variable levels\u00b6","text":"<p>With the predicates defined, we can now define the function variable. We need to pass in a name, the function and the arguments that we want to pass into the function. In this case, we want to pass in the color of the stimulus.</p>"},{"location":"Basic%20Tutorials/%284%29%20Responses%20and%20Feedback/#create-the-stimulus","title":"Create the stimulus\u00b6","text":"<p>The function variable can be used in the creation of the stimulus just as a static or a timeline parameter. Here, we introduce another feature of the text stimulus: We can provide a correct_key parameter. This correct_key parameter can be used for data analysis later, but it can also be used to provide feedback (we will see how this is used later in this tutorial)</p>"},{"location":"Basic%20Tutorials/%284%29%20Responses%20and%20Feedback/#adding-feedback","title":"Adding feedback\u00b6","text":"<p>To add feedback, we introduce yet another type of variable: the data variable. At the end of each stimulus, data for this stimulus is stored in a container. This data contains stimulus features like color, word and duration, but also user input like key presses. With the data variable, we can access this container to create adaptive stimuli like feedback.</p>"},{"location":"Basic%20Tutorials/%284%29%20Responses%20and%20Feedback/#creating-the-data-variable","title":"Creating the data variable\u00b6","text":"<p>We create a data variable for the correct-data of a trial. This is a special data point, that can be accessed in stimuli that have the correct_key parameter. A data variable also uses a window argument that specifies how far back in time the data should be accessed. In this case, we want to access the data of the stimulus that came before the current stimulus. So we use a window of 1.</p>"},{"location":"Basic%20Tutorials/%284%29%20Responses%20and%20Feedback/#defining-the-function","title":"Defining the function\u00b6","text":"<p>Again, we want to create an adaptive text based on weather the response was correct or notIn the same way we can access timeline variables in predicate functions, we can also access data variables.</p>"},{"location":"Basic%20Tutorials/%284%29%20Responses%20and%20Feedback/#creating-the-function-variable","title":"Creating the function variable\u00b6","text":"<p>Now, we create the function variable. Instead of passing a timeline variable, we pass the data variable.</p>"},{"location":"Basic%20Tutorials/%284%29%20Responses%20and%20Feedback/#create-a-parameter-for-the-color-of-the-feedback","title":"Create a parameter for the color of the feedback.\u00b6","text":"<p>Maybe we also want to change the color of the feedback (green for positive and red for negative feedback). Can you create the derived parameter?</p>"},{"location":"Basic%20Tutorials/%284%29%20Responses%20and%20Feedback/#solution","title":"Solution\u00b6","text":""},{"location":"Basic%20Tutorials/%284%29%20Responses%20and%20Feedback/#creating-the-feedback-stimulus","title":"Creating the feedback stimulus\u00b6","text":""},{"location":"Basic%20Tutorials/%284%29%20Responses%20and%20Feedback/#adding-a-fixation-cross-creating-the-block-creating-the-experiment-and-exporting-the-html","title":"Adding a fixation cross, creating the block, creating the experiment and exporting the html\u00b6","text":"<p>You can practice your SweetBean skills by adding a fixation cross and completing experiment. Remember there are two blocks now. If you feel comfortable creating blocks and experiments you can skip this part and use the code in the solution:</p>"},{"location":"Basic%20Tutorials/%284%29%20Responses%20and%20Feedback/#solution","title":"Solution\u00b6","text":""},{"location":"Basic%20Tutorials/%285%29%20Combining%20Instructions%2C%20Stimuli%2C%20and%20Responses/","title":"(5) Combining Instructions, Stimuli, and Responses","text":"In\u00a0[\u00a0]: Copied! <pre>!pip install sweetbean\n</pre> !pip install sweetbean <p>Given the following timeline, could you program a task switching experiment?</p> In\u00a0[\u00a0]: Copied! <pre>timeline = [\n    {'color': 'red', 'word': 'RED', 'task': 'color_naming'},\n    {'color': 'green', 'word': 'GREEN', 'task': 'color_naming'},\n    {'color': 'green', 'word': 'RED', 'task': 'word_reading'},\n    {'color': 'red', 'word': 'GREEN', 'task': 'word_reading'},\n]\n</pre> timeline = [     {'color': 'red', 'word': 'RED', 'task': 'color_naming'},     {'color': 'green', 'word': 'GREEN', 'task': 'color_naming'},     {'color': 'green', 'word': 'RED', 'task': 'word_reading'},     {'color': 'red', 'word': 'GREEN', 'task': 'word_reading'}, ] <p>First we want to declare the timeline variables</p> In\u00a0[\u00a0]: Copied! <pre># Enter your code here:\n</pre> # Enter your code here: In\u00a0[\u00a0]: Copied! <pre># imports\nfrom sweetbean.variable import TimelineVariable\n\ncolor = TimelineVariable('color')\nword = TimelineVariable('word')\ntask = TimelineVariable('task')\n</pre> # imports from sweetbean.variable import TimelineVariable  color = TimelineVariable('color') word = TimelineVariable('word') task = TimelineVariable('task') <p>Now we can generate some instructions for the experiment:</p> In\u00a0[\u00a0]: Copied! <pre>from sweetbean.stimulus import Text\n\ninstruction_welcome = # Enter your code here\n\ninstruction_list = [\n    # Enter your code here\n]\n\n# Create the instruction block\ninstruction_block = Block(instruction_list)\n</pre> from sweetbean.stimulus import Text  instruction_welcome = # Enter your code here  instruction_list = [     # Enter your code here ]  # Create the instruction block instruction_block = Block(instruction_list) In\u00a0[\u00a0]: Copied! <pre>from sweetbean.stimulus import Text\nfrom sweetbean import Block\n\n# Define the instruction text blocks\ninstruction_welcome = Text(\n    text='Welcome to our task-switching experiment.&lt;br&gt;&lt;br&gt; \\\n          In this experiment, you will alternate between two tasks: color naming and word reading.&lt;br&gt;&lt;br&gt; \\\n          Press the SPACE key to continue.',\n    choices=[' ']\n)\n\ninstruction_fixation = Text(\n    text='At the beginning of each trial, you will see a fixation cue:&lt;br&gt;&lt;br&gt; \\\n          A \"+\" means you should perform the color-naming task.&lt;br&gt; \\\n          An \"x\" means you should perform the word-reading task.&lt;br&gt;&lt;br&gt; \\\n          Press the SPACE key to continue.',\n    choices=[' ']\n)\n\ninstruction_tasks = Text(\n    text='For the color-naming task:&lt;br&gt; \\\n          Identify the COLOR of the text, ignoring the word.&lt;br&gt;&lt;br&gt; \\\n          For the word-reading task:&lt;br&gt; \\\n          Read the WORD, ignoring its color.&lt;br&gt;&lt;br&gt; \\\n          Press the SPACE key to continue.',\n    choices=[' ']\n)\n\ninstruction_responses = Text(\n    text='You will respond using the following keys:&lt;br&gt;&lt;br&gt; \\\n          For RED (color or word): press the \"f\" key.&lt;br&gt; \\\n          For GREEN (color or word): press the \"j\" key.&lt;br&gt;&lt;br&gt; \\\n          The stimulus will be displayed for a short period of time, so respond quickly.&lt;br&gt;&lt;br&gt; \\\n          Press the SPACE key to continue.',\n    choices=[' ']\n)\n\ninstruction_note = Text(\n    text='Remember:&lt;br&gt; \\\n          Pay attention to the fixation cue (\"+\" for color naming or \"x\" for word reading)&lt;br&gt;&lt;br&gt; \\\n          to determine the task.&lt;br&gt;&lt;br&gt; \\\n          Press the SPACE key to BEGIN the experiment.',\n    choices=[' ']\n)\n\n# Create a list of instruction stimuli for the instruction block\ninstruction_list = [\n    instruction_welcome,\n    instruction_fixation,\n    instruction_tasks,\n    instruction_responses,\n    instruction_note\n]\n\n# Create the instruction block\ninstruction_block = Block(instruction_list)\n</pre> from sweetbean.stimulus import Text from sweetbean import Block  # Define the instruction text blocks instruction_welcome = Text(     text='Welcome to our task-switching experiment. \\           In this experiment, you will alternate between two tasks: color naming and word reading. \\           Press the SPACE key to continue.',     choices=[' '] )  instruction_fixation = Text(     text='At the beginning of each trial, you will see a fixation cue: \\           A \"+\" means you should perform the color-naming task. \\           An \"x\" means you should perform the word-reading task. \\           Press the SPACE key to continue.',     choices=[' '] )  instruction_tasks = Text(     text='For the color-naming task: \\           Identify the COLOR of the text, ignoring the word. \\           For the word-reading task: \\           Read the WORD, ignoring its color. \\           Press the SPACE key to continue.',     choices=[' '] )  instruction_responses = Text(     text='You will respond using the following keys: \\           For RED (color or word): press the \"f\" key. \\           For GREEN (color or word): press the \"j\" key. \\           The stimulus will be displayed for a short period of time, so respond quickly. \\           Press the SPACE key to continue.',     choices=[' '] )  instruction_note = Text(     text='Remember: \\           Pay attention to the fixation cue (\"+\" for color naming or \"x\" for word reading) \\           to determine the task. \\           Press the SPACE key to BEGIN the experiment.',     choices=[' '] )  # Create a list of instruction stimuli for the instruction block instruction_list = [     instruction_welcome,     instruction_fixation,     instruction_tasks,     instruction_responses,     instruction_note ]  # Create the instruction block instruction_block = Block(instruction_list)  In\u00a0[\u00a0]: Copied! <pre># Enter your code here:\n</pre> # Enter your code here: In\u00a0[\u00a0]: Copied! <pre>from sweetbean.variable import FunctionVariable\n\n# Predicates\ndef fixation_shape_fct(task):\n    if task == 'color_naming':\n        return '+'\n    return 'x'\n\n\n# variable\nfixation_shape = FunctionVariable('fixation_shape', fixation_shape_fct, [task])\n</pre> from sweetbean.variable import FunctionVariable  # Predicates def fixation_shape_fct(task):     if task == 'color_naming':         return '+'     return 'x'   # variable fixation_shape = FunctionVariable('fixation_shape', fixation_shape_fct, [task])  In\u00a0[\u00a0]: Copied! <pre># Predicate for f\ndef correct_key_fct(word, color, task):\n    if (task == 'word_reading' and word == 'RED') or \\\n        (task == 'color_naming' and color == 'red'):\n        return 'f'\n    return 'j'\n\n\n\n# variable for the response\ncorrect_key = FunctionVariable('correct_key', correct_key_fct, [word, color, task])\n</pre> # Predicate for f def correct_key_fct(word, color, task):     if (task == 'word_reading' and word == 'RED') or \\         (task == 'color_naming' and color == 'red'):         return 'f'     return 'j'    # variable for the response correct_key = FunctionVariable('correct_key', correct_key_fct, [word, color, task]) In\u00a0[\u00a0]: Copied! <pre># Enter your code here:\n</pre> # Enter your code here: In\u00a0[\u00a0]: Copied! <pre>from sweetbean.stimulus import Text\nfrom sweetbean import Block, Experiment\n\n# Stimuli\nfixation = Text(1000, fixation_shape)\nso_s = Text(800)\nstroop = Text(2000, word, color, ['f', 'j'], correct_key)\nso_f = Text(300)\n\n# Block\ntrain_block = Block([fixation, so_s, stroop, so_f], timeline)\nexperiment = Experiment([instruction_block, train_block])\n\n# Experiment\nexperiment.to_html('index.html')\n</pre> from sweetbean.stimulus import Text from sweetbean import Block, Experiment  # Stimuli fixation = Text(1000, fixation_shape) so_s = Text(800) stroop = Text(2000, word, color, ['f', 'j'], correct_key) so_f = Text(300)  # Block train_block = Block([fixation, so_s, stroop, so_f], timeline) experiment = Experiment([instruction_block, train_block])  # Experiment experiment.to_html('index.html')"},{"location":"Basic%20Tutorials/%285%29%20Combining%20Instructions%2C%20Stimuli%2C%20and%20Responses/#5-combining-instructions-stimuli-and-responses","title":"(5) Combining Instructions, Stimuli, and Responses\u00b6","text":"<p>Here, we combine instructions, stimuli, and response to create a complete task switching experiment. In this experiment, participants alternate between two tasks: color naming and word reading. Each trial begins with a fixation cue\u2014a \"+\" indicates a color-naming task, while an \"x\" signals a word-reading task. The stimulus, displayed for 2000 ms, consists of a word (\"RED\" or \"GREEN\") presented in a color (red or green). For color-naming tasks, participants identify the text's color, ignoring the word; for word-reading tasks, they read the word, ignoring its color. Responses are made using keys ('f' or 'j'), with the correct key determined by the task and the stimulus properties. The experiment assesses cognitive flexibility and the ability to manage task switching, including potential interference effects from conflicting information.</p>"},{"location":"Basic%20Tutorials/%285%29%20Combining%20Instructions%2C%20Stimuli%2C%20and%20Responses/#installing-sweetbean","title":"Installing sweetbean\u00b6","text":""},{"location":"Basic%20Tutorials/%285%29%20Combining%20Instructions%2C%20Stimuli%2C%20and%20Responses/#solution","title":"Solution\u00b6","text":""},{"location":"Basic%20Tutorials/%285%29%20Combining%20Instructions%2C%20Stimuli%2C%20and%20Responses/#creating-the-instructions","title":"Creating the instructions\u00b6","text":""},{"location":"Basic%20Tutorials/%285%29%20Combining%20Instructions%2C%20Stimuli%2C%20and%20Responses/#solution","title":"Solution\u00b6","text":""},{"location":"Basic%20Tutorials/%285%29%20Combining%20Instructions%2C%20Stimuli%2C%20and%20Responses/#creating-the-fixation","title":"Creating the fixation\u00b6","text":"<p>The fixation cross will vary between the two tasks, maybe we can show a <code>+</code>, when the task is color_naming, and a <code>x</code> when the task is word_reading. We can do this with a function variable.</p>"},{"location":"Basic%20Tutorials/%285%29%20Combining%20Instructions%2C%20Stimuli%2C%20and%20Responses/#solution","title":"Solution\u00b6","text":""},{"location":"Basic%20Tutorials/%285%29%20Combining%20Instructions%2C%20Stimuli%2C%20and%20Responses/#creating-the-correct-response","title":"Creating the correct response\u00b6","text":"<p>Now let's create a correct response parameter. This one is tricky! It will depend on the color, the word and the task. So the predicate will have three input arguments. Let's say we want the participant to press f when the color is \"red\" in the color_naming task or the word is \"RED\" in the word_reading task. They should press j when the color is \"green\" in the color_naming task or the word is \"GREEN\" in the word_reading task.</p>"},{"location":"Basic%20Tutorials/%285%29%20Combining%20Instructions%2C%20Stimuli%2C%20and%20Responses/#finishing-the-experiment","title":"Finishing the experiment\u00b6","text":"<p>Now, create the stimuli, the block and the experiment</p>"},{"location":"Basic%20Tutorials/%285%29%20Combining%20Instructions%2C%20Stimuli%2C%20and%20Responses/#solution","title":"Solution\u00b6","text":""},{"location":"Basic%20Tutorials/%286%29%20Side%20Effects/","title":"(6) Side Effects","text":"In\u00a0[\u00a0]: Copied! <pre>!pip install sweetbean\n</pre> !pip install sweetbean <p>We will use the following timeline for our experiment. Note, that we add an additional time line variable called <code>trial</code> that indexes the current trial. We will use this variable later to compute the running accuracy of the participant for every trial.</p> In\u00a0[\u00a0]: Copied! <pre>timeline = [\n    {'color': 'red', 'word': 'RED', 'task': 'color_naming', 'trial': 1},\n    {'color': 'green', 'word': 'GREEN', 'task': 'color_naming', 'trial': 2},\n    {'color': 'green', 'word': 'RED', 'task': 'word_reading', 'trial': 3},\n    {'color': 'red', 'word': 'GREEN', 'task': 'word_reading', 'trial': 4},\n    {'color': 'red', 'word': 'GREEN', 'task': 'word_reading', 'trial': 5},\n    {'color': 'red', 'word': 'RED', 'task': 'color_naming', 'trial': 6},\n    {'color': 'green', 'word': 'RED', 'task': 'word_reading', 'trial': 7},\n    {'color': 'red', 'word': 'GREEN', 'task': 'color_naming', 'trial': 8},\n    {'color': 'green', 'word': 'RED', 'task': 'color_naming', 'trial': 9},\n    {'color': 'red', 'word': 'GREEN', 'task': 'word_reading', 'trial': 10},\n]\n</pre> timeline = [     {'color': 'red', 'word': 'RED', 'task': 'color_naming', 'trial': 1},     {'color': 'green', 'word': 'GREEN', 'task': 'color_naming', 'trial': 2},     {'color': 'green', 'word': 'RED', 'task': 'word_reading', 'trial': 3},     {'color': 'red', 'word': 'GREEN', 'task': 'word_reading', 'trial': 4},     {'color': 'red', 'word': 'GREEN', 'task': 'word_reading', 'trial': 5},     {'color': 'red', 'word': 'RED', 'task': 'color_naming', 'trial': 6},     {'color': 'green', 'word': 'RED', 'task': 'word_reading', 'trial': 7},     {'color': 'red', 'word': 'GREEN', 'task': 'color_naming', 'trial': 8},     {'color': 'green', 'word': 'RED', 'task': 'color_naming', 'trial': 9},     {'color': 'red', 'word': 'GREEN', 'task': 'word_reading', 'trial': 10}, ] <p>First we want to declare the timeline variables</p> In\u00a0[\u00a0]: Copied! <pre># imports\nfrom sweetbean.variable import TimelineVariable\n\ncolor = TimelineVariable('color')\nword = TimelineVariable('word')\ntask = TimelineVariable('task')\ntrial = TimelineVariable('trial')\n</pre> # imports from sweetbean.variable import TimelineVariable  color = TimelineVariable('color') word = TimelineVariable('word') task = TimelineVariable('task') trial = TimelineVariable('trial') In\u00a0[\u00a0]: Copied! <pre>from sweetbean.variable import FunctionVariable\n\n# Predicates\ndef fixation_shape_fct(task):\n    # Enter your code here\n\n\n# variable\nfixation_shape = # Enter your code here\n</pre> from sweetbean.variable import FunctionVariable  # Predicates def fixation_shape_fct(task):     # Enter your code here   # variable fixation_shape = # Enter your code here In\u00a0[\u00a0]: Copied! <pre>from sweetbean.variable import FunctionVariable\n\n# Predicates\ndef fixation_shape_fct(task):\n    if task == 'color_naming':\n        return '+'\n    return 'x'\n\n\n# variable\nfixation_shape = FunctionVariable('fixation_shape', fixation_shape_fct, [task])\n</pre> from sweetbean.variable import FunctionVariable  # Predicates def fixation_shape_fct(task):     if task == 'color_naming':         return '+'     return 'x'   # variable fixation_shape = FunctionVariable('fixation_shape', fixation_shape_fct, [task]) <p>The fixation shape determines the fixation stimulus.</p> In\u00a0[\u00a0]: Copied! <pre>from sweetbean.stimulus import Text\n\nfixation = Text(1000, fixation_shape)\n</pre> from sweetbean.stimulus import Text  fixation = Text(1000, fixation_shape) In\u00a0[\u00a0]: Copied! <pre># Enter your code here\n</pre> # Enter your code here In\u00a0[\u00a0]: Copied! <pre>from sweetbean.stimulus import Text\n\nfixation_stimulus_interval = Text(800)\ninter_trial_interval = Text(500)\n</pre> from sweetbean.stimulus import Text  fixation_stimulus_interval = Text(800) inter_trial_interval = Text(500) <p>To encode the correctness of the response to each Stroop stimulus we will define a predicate with three input arguments. Let's say we want the participant to press f when the color is \"red\" in the color_naming task or the word is \"RED\" in the word_reading task. They should press j when the color is \"green\" in the color_naming task or the word is \"GREEN\" in the word_reading task.</p> <p>The <code>correct_key</code> FunctionVariable indicates the correct key for the stimulus.</p> <p>Can you complete the code below based on what you learned in the previous tutorials?</p> In\u00a0[\u00a0]: Copied! <pre>from sweetbean.variable import FunctionVariable\n\n# Predicate\ndef correct_key_fct(word, color, task):\n    # Enter your code here\n\n\n\n# variable for the response\ncorrect_key = # Enter your code here\n</pre> from sweetbean.variable import FunctionVariable  # Predicate def correct_key_fct(word, color, task):     # Enter your code here    # variable for the response correct_key = # Enter your code here In\u00a0[\u00a0]: Copied! <pre>from sweetbean.variable import FunctionVariable\n\n# Predicate for f\ndef correct_key_fct(word, color, task):\n    if (task == 'word_reading' and word == 'RED') or \\\n        (task == 'color_naming' and color == 'red'):\n        return 'f'\n    return 'j'\n\n\n\n# variable for the response\ncorrect_key = FunctionVariable('correct_key', correct_key_fct, [word, color, task])\n</pre> from sweetbean.variable import FunctionVariable  # Predicate for f def correct_key_fct(word, color, task):     if (task == 'word_reading' and word == 'RED') or \\         (task == 'color_naming' and color == 'red'):         return 'f'     return 'j'    # variable for the response correct_key = FunctionVariable('correct_key', correct_key_fct, [word, color, task]) <p>Next, we can define the Stroop stimulus which is shown for 2000ms.</p> In\u00a0[\u00a0]: Copied! <pre>stroop = Text(2000,\n              word, color, ['f', 'j'],\n              correct_key)\n</pre> stroop = Text(2000,               word, color, ['f', 'j'],               correct_key) In\u00a0[\u00a0]: Copied! <pre>from sweetbean.variable import DataVariable\n\n# declare the data variable\ncorrect = DataVariable('correct', 1)\n</pre> from sweetbean.variable import DataVariable  # declare the data variable correct = DataVariable('correct', 1) In\u00a0[20]: Copied! <pre>from sweetbean.variable import SharedVariable\n\nnum_correct = SharedVariable(\"num_correct\", 0)\n</pre> from sweetbean.variable import SharedVariable  num_correct = SharedVariable(\"num_correct\", 0) <p>Next, we write an update function that increases the number of correct trials based on the current response.</p> In\u00a0[21]: Copied! <pre>update_num_correct = FunctionVariable(\n    \"update_num_correct\", lambda score, value: score + value, [num_correct, correct]\n)\n</pre> update_num_correct = FunctionVariable(     \"update_num_correct\", lambda score, value: score + value, [num_correct, correct] ) In\u00a0[22]: Copied! <pre>from sweetbean.variable import SideEffect\n\nupdate_accuracy_side_effect = SideEffect(num_correct, update_num_correct)\n</pre> from sweetbean.variable import SideEffect  update_accuracy_side_effect = SideEffect(num_correct, update_num_correct) <p>Side effects can be triggered with SweetBean stimuli.  In this case, we will associate the side effect with the occurrence of the Stroop stimulus.</p> <p>Let's re-define our Stroop stimulus above. This time, we will add the side effect that we just defined.</p> In\u00a0[23]: Copied! <pre>stroop = Text(2000,\n              word,\n              color,\n               ['f', 'j'],\n              correct_key,\n              side_effects=[update_accuracy_side_effect])\n</pre> stroop = Text(2000,               word,               color,                ['f', 'j'],               correct_key,               side_effects=[update_accuracy_side_effect]) In\u00a0[24]: Copied! <pre>accuracy_text = FunctionVariable(\"accuracy_text\", lambda score, n: f\"Score: {score/n}\", [num_correct, trial])\n\naccuracy_score = Text(duration=2000, text=accuracy_text)\n</pre> accuracy_text = FunctionVariable(\"accuracy_text\", lambda score, n: f\"Score: {score/n}\", [num_correct, trial])  accuracy_score = Text(duration=2000, text=accuracy_text) In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\n\n# Block\nstroop_block = Block([fixation,\n                      fixation_stimulus_interval,\n                      stroop,\n                      accuracy_score,\n                      inter_trial_interval], timeline)\nexperiment = Experiment([stroop_block])\n\n# Experiment\nexperiment.to_html('index.html')\n</pre> from sweetbean import Block, Experiment  # Block stroop_block = Block([fixation,                       fixation_stimulus_interval,                       stroop,                       accuracy_score,                       inter_trial_interval], timeline) experiment = Experiment([stroop_block])  # Experiment experiment.to_html('index.html')"},{"location":"Basic%20Tutorials/%286%29%20Side%20Effects/#6-side-effects","title":"(6) Side Effects\u00b6","text":"<p>Next, we will learn how to add stimuli that change as a function of the participant's responses via the <code>SideEffect</code> functionality.</p> <p>Specifically, we seek to include a score into our task switching experiment a running score indicating the average accuracy of the participant.</p>"},{"location":"Basic%20Tutorials/%286%29%20Side%20Effects/#installing-sweetbean","title":"Installing sweetbean\u00b6","text":""},{"location":"Basic%20Tutorials/%286%29%20Side%20Effects/#defining-the-stimuli","title":"Defining the stimuli\u00b6","text":"<p>Next, we add the main stimuli for the experiment:</p> <ul> <li>a fixation cross</li> <li>a blank interval between the fixation cross and a Stroop stimulus</li> <li>a stroop stimulus</li> <li>a blank inter-trial interval at the end of the trial</li> </ul>"},{"location":"Basic%20Tutorials/%286%29%20Side%20Effects/#fixation-cross","title":"Fixation cross\u00b6","text":"<p>The fixation cross should display a \"+\" if participants are supposed to respond to the color (color-naming task) and a \"x\" if they are supposed to respond to the word (word reading task).</p> <p>Can you define a <code>FunctionVariable</code> encoding the correct string displayed for the fixation cross as a function of the <code>task</code> variable?</p>"},{"location":"Basic%20Tutorials/%286%29%20Side%20Effects/#solution","title":"Solution\u00b6","text":""},{"location":"Basic%20Tutorials/%286%29%20Side%20Effects/#intervals","title":"Intervals\u00b6","text":"<p>Next, we define two blank intervals, one between the fixation cross and the stimulus (800ms), and another inter-trial interval (500ms).</p>"},{"location":"Basic%20Tutorials/%286%29%20Side%20Effects/#solution","title":"Solution\u00b6","text":""},{"location":"Basic%20Tutorials/%286%29%20Side%20Effects/#stroop-stimulus","title":"Stroop stimulus\u00b6","text":"<p>Eventually, we want to show the stroop stimulus to which people must respond. This one is a bit more complicated as we have to first determine the correct response to each stimulus. We will use that later to compute our accuracy score.</p>"},{"location":"Basic%20Tutorials/%286%29%20Side%20Effects/#solution","title":"Solution\u00b6","text":""},{"location":"Basic%20Tutorials/%286%29%20Side%20Effects/#adding-side-effects-to-compute-an-accuracy-score","title":"Adding Side Effects to Compute an Accuracy Score\u00b6","text":"<p>Now that we have our basic stimuli in place, it is time to think about how we can add a running accuracy score to the experiment.</p>"},{"location":"Basic%20Tutorials/%286%29%20Side%20Effects/#obtaining-the-single-trial-accuracy-from-the-data","title":"Obtaining the single-trial accuracy from the data\u00b6","text":"<p>All stimuli that have the <code>correct_key</code> parameter compute a <code>correct</code> value indicating whether the response was correct or not. This is also the case for the Stroop stimulus defined above.</p> <p>This is a property of the data, i.e., a data variable. Let's define this data variable. In this case, we add the additional argument <code>1</code> to refer to the response of the previous trial (1 stimulus back).</p>"},{"location":"Basic%20Tutorials/%286%29%20Side%20Effects/#counting-the-number-of-correct-trials","title":"Counting the number of correct trials\u00b6","text":"<p>Now, we define a count for the number of accurate trials as a <code>SharedVariable</code> which can be shared across different trials. We initialize it with zero.</p>"},{"location":"Basic%20Tutorials/%286%29%20Side%20Effects/#updating-the-number-of-correct-trials-with-each-stimulus-presentation","title":"Updating the number of correct trials with each stimulus presentation\u00b6","text":"<p>We can consider the updating the number of correct trials as a <code>SideEffect</code> of every Stroop stimulus presentation.  A side effects takes in the variable to set (in this case <code>num_correct</code>) and the variable it will be set to (in this case the function variable <code>update_num_correct</code>).</p>"},{"location":"Basic%20Tutorials/%286%29%20Side%20Effects/#displaying-the-accuracy-score","title":"Displaying the accuracy score\u00b6","text":"<p>Finally, we want to display the running accuracy score. To do this, we can define another ``FunctionVariable'' that computes the accuracy as the number of correct responses divided by the number of trials.</p>"},{"location":"Basic%20Tutorials/%286%29%20Side%20Effects/#finishing-the-experiment","title":"Finishing the experiment\u00b6","text":"<p>All right, now we can complete the experiment by arranging all stimuli in a block. Note that we are skipping instructions here, to keep it simple.</p> <p>Our Stroop block will have the following order of events:</p> <ol> <li>Fixation cross</li> <li>Fixation-stimulus interval</li> <li>Stroop stimulus</li> <li>Accuracy score</li> <li>Inter-trial interval</li> </ol>"},{"location":"Basic%20Tutorials/%287%29%20Generating%20Text-Based%20Experiments%20for%20LLMs/","title":"(7) Generating Text-Based Experiments for LLMs","text":"In\u00a0[1]: Copied! <pre>!pip install sweetbean\n</pre> !pip install sweetbean <pre>Requirement already satisfied: sweetbean in /Users/younesstrittmatter/Documents/GitHub/AutoResearch/sweetbean/.venv/lib/python3.11/site-packages (0.1.1.dev28+g4b938d1.d20241122)\r\nRequirement already satisfied: jinja2 in /Users/younesstrittmatter/Documents/GitHub/AutoResearch/sweetbean/.venv/lib/python3.11/site-packages (from sweetbean) (3.1.4)\r\nRequirement already satisfied: MarkupSafe&gt;=2.0 in /Users/younesstrittmatter/Documents/GitHub/AutoResearch/sweetbean/.venv/lib/python3.11/site-packages (from jinja2-&gt;sweetbean) (3.0.2)\r\n\r\n[notice] A new release of pip is available: 23.1.2 -&gt; 24.3.1\r\n[notice] To update, run: pip install --upgrade pip\r\n</pre> In\u00a0[2]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.variable import TimelineVariable\nfrom sweetbean.stimulus import Text\n\n## Specify timeline\n\ntimeline = [\n    {'color': 'red', 'word': 'RED', 'task': 'color_naming'},\n    {'color': 'green', 'word': 'GREEN', 'task': 'color_naming'},\n    {'color': 'green', 'word': 'RED', 'task': 'word_reading'},\n    {'color': 'red', 'word': 'GREEN', 'task': 'word_reading'},\n    {'color': 'red', 'word': 'GREEN', 'task': 'word_reading'},\n    {'color': 'red', 'word': 'RED', 'task': 'color_naming'},\n    {'color': 'green', 'word': 'RED', 'task': 'word_reading'},\n    {'color': 'red', 'word': 'GREEN', 'task': 'color_naming'},\n    {'color': 'green', 'word': 'RED', 'task': 'color_naming'},\n    {'color': 'red', 'word': 'GREEN', 'task': 'word_reading'},\n]\n\n# declare timeline variables\n\ncolor = TimelineVariable('color')\nword = TimelineVariable('word')\ntask = TimelineVariable('task')\n\n# Define the instruction text blocks\n\ninstruction_welcome = Text(\n    text='Welcome to our task-switching experiment.&lt;br&gt;&lt;br&gt; \\\n          In this experiment, you will alternate between two tasks: color naming and word reading.&lt;br&gt;&lt;br&gt; \\\n          Press the SPACE key to continue.',\n    choices=[' ']\n)\n\ninstruction_fixation = Text(\n    text='At the beginning of each trial, you will see a fixation cue:&lt;br&gt;&lt;br&gt; \\\n          A \"+\" means you should perform the color-naming task.&lt;br&gt; \\\n          An \"x\" means you should perform the word-reading task.&lt;br&gt;&lt;br&gt; \\\n          Press the SPACE key to continue.',\n    choices=[' ']\n)\n\ninstruction_tasks = Text(\n    text='For the color-naming task:&lt;br&gt; \\\n          Identify the COLOR of the text, ignoring the word.&lt;br&gt;&lt;br&gt; \\\n          For the word-reading task:&lt;br&gt; \\\n          Read the WORD, ignoring its color.&lt;br&gt;&lt;br&gt; \\\n          Press the SPACE key to continue.',\n    choices=[' ']\n)\n\ninstruction_responses = Text(\n    text='You will respond using the following keys:&lt;br&gt;&lt;br&gt; \\\n          For RED (color or word): press the \"f\" key.&lt;br&gt; \\\n          For GREEN (color or word): press the \"j\" key.&lt;br&gt;&lt;br&gt; \\\n          The stimulus will be displayed for a short period of time, so respond quickly.&lt;br&gt;&lt;br&gt; \\\n          Press the SPACE key to continue.',\n    choices=[' ']\n)\n\ninstruction_note = Text(\n    text='Remember:&lt;br&gt; \\\n          Pay attention to the fixation cue (\"+\" for color naming or \"x\" for word reading)&lt;br&gt;&lt;br&gt; \\\n          to determine the task.&lt;br&gt;&lt;br&gt; \\\n          Press the SPACE key to BEGIN the experiment.',\n    choices=[' ']\n)\n\ninstruction_list = [\n    instruction_welcome,\n    instruction_fixation,\n    instruction_tasks,\n    instruction_responses,\n    instruction_note\n]\n\ninstruction_block = Block(instruction_list)\n\n# Determine fixation cross based on task\n\nfrom sweetbean.variable import FunctionVariable\n\ndef fixation_shape_fct(task):\n    if task == 'color_naming':\n        return '+'\n    return 'x'\n\n\nfixation_shape = FunctionVariable('fixation_shape', fixation_shape_fct, [task])\n\n# Determine correct response based on task, color, and word\n\ndef correct_key_fct(word, color, task):\n    if (task == 'word_reading' and word == 'RED') or \\\n        (task == 'color_naming' and color == 'red'):\n        return 'f'\n    return 'j'\n\ncorrect_key = FunctionVariable('correct_key', correct_key_fct, [word, color, task])\n\n# Combine stimuli\nfixation = Text(1000, fixation_shape)\nso_s = Text(800)\nstroop = Text(2000, word, color, ['f', 'j'], correct_key)\nso_f = Text(300)\n\n# Declare block\ntask_switching_block = Block([fixation, so_s, stroop, so_f], timeline)\ntask_switching_block = Block([fixation, stroop], timeline)\nexperiment = Experiment([task_switching_block])\n</pre> from sweetbean import Block, Experiment from sweetbean.variable import TimelineVariable from sweetbean.stimulus import Text  ## Specify timeline  timeline = [     {'color': 'red', 'word': 'RED', 'task': 'color_naming'},     {'color': 'green', 'word': 'GREEN', 'task': 'color_naming'},     {'color': 'green', 'word': 'RED', 'task': 'word_reading'},     {'color': 'red', 'word': 'GREEN', 'task': 'word_reading'},     {'color': 'red', 'word': 'GREEN', 'task': 'word_reading'},     {'color': 'red', 'word': 'RED', 'task': 'color_naming'},     {'color': 'green', 'word': 'RED', 'task': 'word_reading'},     {'color': 'red', 'word': 'GREEN', 'task': 'color_naming'},     {'color': 'green', 'word': 'RED', 'task': 'color_naming'},     {'color': 'red', 'word': 'GREEN', 'task': 'word_reading'}, ]  # declare timeline variables  color = TimelineVariable('color') word = TimelineVariable('word') task = TimelineVariable('task')  # Define the instruction text blocks  instruction_welcome = Text(     text='Welcome to our task-switching experiment. \\           In this experiment, you will alternate between two tasks: color naming and word reading. \\           Press the SPACE key to continue.',     choices=[' '] )  instruction_fixation = Text(     text='At the beginning of each trial, you will see a fixation cue: \\           A \"+\" means you should perform the color-naming task. \\           An \"x\" means you should perform the word-reading task. \\           Press the SPACE key to continue.',     choices=[' '] )  instruction_tasks = Text(     text='For the color-naming task: \\           Identify the COLOR of the text, ignoring the word. \\           For the word-reading task: \\           Read the WORD, ignoring its color. \\           Press the SPACE key to continue.',     choices=[' '] )  instruction_responses = Text(     text='You will respond using the following keys: \\           For RED (color or word): press the \"f\" key. \\           For GREEN (color or word): press the \"j\" key. \\           The stimulus will be displayed for a short period of time, so respond quickly. \\           Press the SPACE key to continue.',     choices=[' '] )  instruction_note = Text(     text='Remember: \\           Pay attention to the fixation cue (\"+\" for color naming or \"x\" for word reading) \\           to determine the task. \\           Press the SPACE key to BEGIN the experiment.',     choices=[' '] )  instruction_list = [     instruction_welcome,     instruction_fixation,     instruction_tasks,     instruction_responses,     instruction_note ]  instruction_block = Block(instruction_list)  # Determine fixation cross based on task  from sweetbean.variable import FunctionVariable  def fixation_shape_fct(task):     if task == 'color_naming':         return '+'     return 'x'   fixation_shape = FunctionVariable('fixation_shape', fixation_shape_fct, [task])  # Determine correct response based on task, color, and word  def correct_key_fct(word, color, task):     if (task == 'word_reading' and word == 'RED') or \\         (task == 'color_naming' and color == 'red'):         return 'f'     return 'j'  correct_key = FunctionVariable('correct_key', correct_key_fct, [word, color, task])  # Combine stimuli fixation = Text(1000, fixation_shape) so_s = Text(800) stroop = Text(2000, word, color, ['f', 'j'], correct_key) so_f = Text(300)  # Declare block task_switching_block = Block([fixation, so_s, stroop, so_f], timeline) task_switching_block = Block([fixation, stroop], timeline) experiment = Experiment([task_switching_block])  <p>Instead of compiling the experiment into a web-based version for human participants, we can generate a text-based version for LLMs in natural language. Execute the following line to execute the experiment in natural language. You must enter key presses for each stimulus that requires a response.</p> In\u00a0[3]: Copied! <pre>data = experiment.run_on_language(get_input=input)\n</pre> data = experiment.run_on_language(get_input=input) <p>The <code>run_on_language</code> function will return a dictionary with the data from the experiment.</p> <p>Let's install a package for running LLMs.</p> In\u00a0[\u00a0]: Copied! <pre>!pip install unsloth \"xformers==0.0.28.post2\"\n</pre> !pip install unsloth \"xformers==0.0.28.post2\" <p>Next, we want to execute the experiment with an LLM. Here, we use Centaur \u2013 an LLM fine-tuned to human behavior in cognitive psychology experiments. However, any model (for example, using OpenAI, HuggingFace, LLama, or Google API) can be used as a synthetic participant.</p> <p>In order to execute the experiment with an LLM, we need to define a function that returns the LLMs response to every instruction it receives.</p> In\u00a0[\u00a0]: Copied! <pre>from unsloth import FastLanguageModel\nimport transformers\n\nmodel, tokenizer = FastLanguageModel.from_pretrained(\n    model_name=\"marcelbinz/Llama-3.1-Centaur-8B-adapter\",\n    max_seq_length=32768,\n    dtype=None,\n    load_in_4bit=True,\n)\nFastLanguageModel.for_inference(model)\n\npipe = transformers.pipeline(\n    \"text-generation\",\n    model=model,\n    tokenizer=tokenizer,\n    trust_remote_code=True,\n    pad_token_id=0,\n    do_sample=True,\n    temperature=1.0,\n    max_new_tokens=1,\n)\n\n\ndef generate(input):\n    return pipe(input)[0][\"generated_text\"][len(input):]\n</pre> from unsloth import FastLanguageModel import transformers  model, tokenizer = FastLanguageModel.from_pretrained(     model_name=\"marcelbinz/Llama-3.1-Centaur-8B-adapter\",     max_seq_length=32768,     dtype=None,     load_in_4bit=True, ) FastLanguageModel.for_inference(model)  pipe = transformers.pipeline(     \"text-generation\",     model=model,     tokenizer=tokenizer,     trust_remote_code=True,     pad_token_id=0,     do_sample=True,     temperature=1.0,     max_new_tokens=1, )   def generate(input):     return pipe(input)[0][\"generated_text\"][len(input):] <p>Next, we can run the experiment on an LLM. Note that the LLM receives the full trial history as a prompt (including information about the responses it made in previous trials).</p> In\u00a0[\u00a0]: Copied! <pre>data = experiment.run_on_language(get_input=generate)\n</pre> data = experiment.run_on_language(get_input=generate) <p>Let's have a look at the LLM's response. In this case, we want to index the first block of the experiment (<code>0</code>) and the eighth trial (<code>7</code>):</p> In\u00a0[\u00a0]: Copied! <pre>data[0][7]\n</pre> data[0][7] <p>We observe that the network correctly responded with the key \"J\" which was incorrect.</p> <p>Note that the data produced here is in the same format as the data produced via web-experiments with human participants. This functionality eases the comparison of human and LLM behavior, and enables the alignment of LLMs to behavior of human participants in combination with automated data collection via web-experiments, as supported by AutoRA.</p>"},{"location":"Basic%20Tutorials/%287%29%20Generating%20Text-Based%20Experiments%20for%20LLMs/#7-generating-text-based-experiments-for-llms","title":"(7) Generating Text-Based Experiments for LLMs\u00b6","text":"<p>Large language models (LLMs) have the potential to simulate human behavior in a variety of tasks, making them valuable simulators for behavioral experiments. SweetBean provides functionality for generating prompts for LLMs based on the same experiment specification used for human participants. In this example, we will execute our task switching experiment on a large language model.</p> <p>Note: If you are running this tutorial in Google Colaboratory, we recommend changing the Runtime type to \"T4 GPU\".</p>"},{"location":"Basic%20Tutorials/%287%29%20Generating%20Text-Based%20Experiments%20for%20LLMs/#installing-sweetbean","title":"Installing sweetbean\u00b6","text":""},{"location":"Basic%20Tutorials/%287%29%20Generating%20Text-Based%20Experiments%20for%20LLMs/#experiment-specification","title":"Experiment specification\u00b6","text":"<p>Below, we have the complete task switching experiment from Tutorial (5). Let's run the code below.</p>"},{"location":"Basic%20Tutorials/%287%29%20Generating%20Text-Based%20Experiments%20for%20LLMs/#running-the-experiment-in-natural-language","title":"Running the experiment in natural language\u00b6","text":""},{"location":"Basic%20Tutorials/%287%29%20Generating%20Text-Based%20Experiments%20for%20LLMs/#execute-the-experiment-with-an-llm-as-participant","title":"Execute the experiment with an LLM as participant\u00b6","text":""},{"location":"Extensions/","title":"Extensions","text":"<p>An overview of the extensions that can be used in SweetBean experiments.</p>"},{"location":"Extensions/Touchscreen/","title":"Touchscreen","text":"<p>Instead of key presses in, with this extension, touch buttons can be used to get the response.</p>"},{"location":"Extensions/Touchscreen/#prerequisite","title":"Prerequisite","text":"<p>Make sure to include (or install) the extension from here:</p> <p>https://github.com/jspsych/jspsych-contrib/tree/main/packages/extension-touchscreen-buttons</p> <p>Note: To use predefined buttons (left, right, ...) also make sure to include the css file in your html or js file.</p>"},{"location":"Extensions/Touchscreen/touchbutton/","title":"Touchbutton","text":"In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.extension import TouchButton\nfrom sweetbean.stimulus import Blank, Feedback, Fixation, Flanker\nfrom sweetbean.variable import FunctionVariable, TimelineVariable\n</pre> from sweetbean import Block, Experiment from sweetbean.extension import TouchButton from sweetbean.stimulus import Blank, Feedback, Fixation, Flanker from sweetbean.variable import FunctionVariable, TimelineVariable In\u00a0[\u00a0]: Copied! <pre>timeline = [\n    {\"direction\": \"left\", \"distractor\": \"right\", \"correct_key\": \"f\"},\n    {\"direction\": \"right\", \"distractor\": \"right\", \"correct_key\": \"j\"},\n    {\"direction\": \"left\", \"distractor\": \"left\", \"correct_key\": \"f\"},\n    {\"direction\": \"right\", \"distractor\": \"left\", \"correct_key\": \"j\"},\n]\n</pre> timeline = [     {\"direction\": \"left\", \"distractor\": \"right\", \"correct_key\": \"f\"},     {\"direction\": \"right\", \"distractor\": \"right\", \"correct_key\": \"j\"},     {\"direction\": \"left\", \"distractor\": \"left\", \"correct_key\": \"f\"},     {\"direction\": \"right\", \"distractor\": \"left\", \"correct_key\": \"j\"}, ] In\u00a0[\u00a0]: Copied! <pre>direction = TimelineVariable(\"direction\")\ndistractor = TimelineVariable(\"distractor\")\ncorrect_key = FunctionVariable(\n    \"correct_key\",\n    lambda dir: TouchButton.left() if dir == \"left\" else TouchButton.right(),\n    [TimelineVariable(\"direction\")],\n)\n</pre> direction = TimelineVariable(\"direction\") distractor = TimelineVariable(\"distractor\") correct_key = FunctionVariable(     \"correct_key\",     lambda dir: TouchButton.left() if dir == \"left\" else TouchButton.right(),     [TimelineVariable(\"direction\")], ) In\u00a0[\u00a0]: Copied! <pre>fixation = Fixation(1000)\nso_s = Blank(400)\nflanker = Flanker(\n    2000, direction, distractor, [TouchButton.left(), TouchButton.right()], correct_key\n)\nso_f = Blank(300)\nfeedback = Feedback(800, window=2)\n</pre> fixation = Fixation(1000) so_s = Blank(400) flanker = Flanker(     2000, direction, distractor, [TouchButton.left(), TouchButton.right()], correct_key ) so_f = Blank(300) feedback = Feedback(800, window=2) In\u00a0[\u00a0]: Copied! <pre>block = Block([fixation, so_s, flanker, so_f, feedback], timeline)\n</pre> block = Block([fixation, so_s, flanker, so_f, feedback], timeline) <p>Create an image of the stimuli sequence of the block</p> In\u00a0[\u00a0]: Copied! <pre># Create an HTML file of the experiment\nexperiment = Experiment([block])\nexperiment.to_html(\"touchButton.html\")\n</pre> # Create an HTML file of the experiment experiment = Experiment([block]) experiment.to_html(\"touchButton.html\")"},{"location":"Notebooks/Basic%20LLM%20Experiment/","title":"Basic LLM Experiment","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nTo use this script, you need to be logged in to the Vertex AI platform:\nSee https://cloud.google.com/sdk/gcloud/reference/auth/application-default/login\n```bash\ngcloud auth application-default login\n```\n\"\"\"\nimport vertexai\nfrom vertexai.generative_models import GenerativeModel, SafetySetting\n\n\nPROJECT = \"auto-centauer\"\nLOCATION = \"us-central1\"\nMODEL = \"gemini-1.5-flash-002\"\n\n\ndef generate(prompt):\n    vertexai.init(project=PROJECT, location=LOCATION)\n    model = GenerativeModel(\n        MODEL,\n    )\n    responses = model.generate_content(\n        [prompt],\n        generation_config=generation_config,\n        safety_settings=safety_settings,\n        stream=True,\n    )\n\n    return \"\".join([response.text for response in responses])\n\n\n\ngeneration_config = {\n    \"max_output_tokens\": 1,\n    \"temperature\": 1,\n    \"top_p\": 0.95,\n    \"stop_sequences\": [\"&gt;&gt;\"],\n}\n\nsafety_settings = [\n    SafetySetting(\n        category=SafetySetting.HarmCategory.HARM_CATEGORY_HATE_SPEECH,\n        threshold=SafetySetting.HarmBlockThreshold.OFF,\n    ),\n    SafetySetting(\n        category=SafetySetting.HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,\n        threshold=SafetySetting.HarmBlockThreshold.OFF,\n    ),\n    SafetySetting(\n        category=SafetySetting.HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,\n        threshold=SafetySetting.HarmBlockThreshold.OFF,\n    ),\n    SafetySetting(\n        category=SafetySetting.HarmCategory.HARM_CATEGORY_HARASSMENT,\n        threshold=SafetySetting.HarmBlockThreshold.OFF,\n    ),\n]\n</pre> \"\"\" To use this script, you need to be logged in to the Vertex AI platform: See https://cloud.google.com/sdk/gcloud/reference/auth/application-default/login ```bash gcloud auth application-default login ``` \"\"\" import vertexai from vertexai.generative_models import GenerativeModel, SafetySetting   PROJECT = \"auto-centauer\" LOCATION = \"us-central1\" MODEL = \"gemini-1.5-flash-002\"   def generate(prompt):     vertexai.init(project=PROJECT, location=LOCATION)     model = GenerativeModel(         MODEL,     )     responses = model.generate_content(         [prompt],         generation_config=generation_config,         safety_settings=safety_settings,         stream=True,     )      return \"\".join([response.text for response in responses])    generation_config = {     \"max_output_tokens\": 1,     \"temperature\": 1,     \"top_p\": 0.95,     \"stop_sequences\": [\"&gt;&gt;\"], }  safety_settings = [     SafetySetting(         category=SafetySetting.HarmCategory.HARM_CATEGORY_HATE_SPEECH,         threshold=SafetySetting.HarmBlockThreshold.OFF,     ),     SafetySetting(         category=SafetySetting.HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,         threshold=SafetySetting.HarmBlockThreshold.OFF,     ),     SafetySetting(         category=SafetySetting.HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,         threshold=SafetySetting.HarmBlockThreshold.OFF,     ),     SafetySetting(         category=SafetySetting.HarmCategory.HARM_CATEGORY_HARASSMENT,         threshold=SafetySetting.HarmBlockThreshold.OFF,     ), ]  In\u00a0[1]: Copied! <pre>from sweetbean.sequence import Block, Experiment\nfrom sweetbean.stimulus import TextStimulus\nfrom sweetbean.parameter import TimelineVariable, DataVariable, DerivedLevel, DerivedParameter\n\n# TIMELINE\ntimeline = [\n    {\"color\": \"red\", \"word\": \"RED\"},\n    {\"color\": \"green\", \"word\": \"GREEN\"},\n    {\"color\": \"green\", \"word\": \"RED\"},\n    {\"color\": \"red\", \"word\": \"GREEN\"},\n]\n\n# EVENT SEQUENCE\n\ncolor = TimelineVariable(\"color\", [\"red\", \"green\"])\nword = TimelineVariable(\"word\", [\"RED\", \"GREEN\"])\n\n\ndef is_correct_f(color):\n    return color == \"red\"\n\n\ndef is_correct_j(color):\n    return not is_correct_f(color)\n\n\nj_key = DerivedLevel(\"j\", is_correct_j, [color])\nf_key = DerivedLevel(\"f\", is_correct_f, [color])\n\ncorrect_key = DerivedParameter(\"correct\", [j_key, f_key])\n\n# Creating a data variable\ncorrect = DataVariable(\"correct\", [True, False])\n\n\n# Predicates\ndef is_correct(correct):\n    return correct\n\n\ndef is_false(correct):\n    return not correct\n\n\n# Derived Levels\ncorrect_feedback = DerivedLevel(\"correct\", is_correct, [correct], 2)\nfalse_feedback = DerivedLevel(\"false\", is_false, [correct], 2)\n\n# Derived Parameter\nfeedback_text = DerivedParameter(\"feedback_text\", [correct_feedback, false_feedback])\n\n# Using it in the stimulus\nfixation = TextStimulus(1000, \"+\")\n\nso_s = TextStimulus(400)\nstroop = TextStimulus(2000, word, color, [\"j\", \"f\"], correct_key)\nso_f = TextStimulus(300)\nfeedback = TextStimulus(800, feedback_text)\n\nevent_sequence = [fixation, so_s, stroop, so_f, feedback]\n\n# BLOCK DESIGN\n\ntrain_block = Block(event_sequence, timeline)\nexperiment = Experiment([train_block])\n</pre> from sweetbean.sequence import Block, Experiment from sweetbean.stimulus import TextStimulus from sweetbean.parameter import TimelineVariable, DataVariable, DerivedLevel, DerivedParameter  # TIMELINE timeline = [     {\"color\": \"red\", \"word\": \"RED\"},     {\"color\": \"green\", \"word\": \"GREEN\"},     {\"color\": \"green\", \"word\": \"RED\"},     {\"color\": \"red\", \"word\": \"GREEN\"}, ]  # EVENT SEQUENCE  color = TimelineVariable(\"color\", [\"red\", \"green\"]) word = TimelineVariable(\"word\", [\"RED\", \"GREEN\"])   def is_correct_f(color):     return color == \"red\"   def is_correct_j(color):     return not is_correct_f(color)   j_key = DerivedLevel(\"j\", is_correct_j, [color]) f_key = DerivedLevel(\"f\", is_correct_f, [color])  correct_key = DerivedParameter(\"correct\", [j_key, f_key])  # Creating a data variable correct = DataVariable(\"correct\", [True, False])   # Predicates def is_correct(correct):     return correct   def is_false(correct):     return not correct   # Derived Levels correct_feedback = DerivedLevel(\"correct\", is_correct, [correct], 2) false_feedback = DerivedLevel(\"false\", is_false, [correct], 2)  # Derived Parameter feedback_text = DerivedParameter(\"feedback_text\", [correct_feedback, false_feedback])  # Using it in the stimulus fixation = TextStimulus(1000, \"+\")  so_s = TextStimulus(400) stroop = TextStimulus(2000, word, color, [\"j\", \"f\"], correct_key) so_f = TextStimulus(300) feedback = TextStimulus(800, feedback_text)  event_sequence = [fixation, so_s, stroop, so_f, feedback]  # BLOCK DESIGN  train_block = Block(event_sequence, timeline) experiment = Experiment([train_block]) <p>To test what the LLM \"sees\", we can run the experiment as chat on ourselves. If we set multiturn to true we will not see the full chat history but only the last generated prompt.</p> In\u00a0[2]: Copied! <pre>data = experiment.run_on_language(get_input=input, multiturn=True)\ndata\n</pre> data = experiment.run_on_language(get_input=input, multiturn=True) data Out[2]: <pre>{'full_chat': ' You see \"+\" written in white. You see a blank screen. You see \"RED\" written in red. You can press [\\'j\\', \\'f\\']. You press &lt;&lt;&gt;&gt;. You see a blank screen. You see \"false\" written in white. You see \"+\" written in white. You see a blank screen. You see \"GREEN\" written in green. You can press [\\'j\\', \\'f\\']. You press &lt;&lt;&gt;&gt;. You see a blank screen. You see \"false\" written in white. You see \"+\" written in white. You see a blank screen. You see \"RED\" written in green. You can press [\\'j\\', \\'f\\']. You press &lt;&lt;&gt;&gt;. You see a blank screen. You see \"false\" written in white. You see \"+\" written in white. You see a blank screen. You see \"GREEN\" written in red. You can press [\\'j\\', \\'f\\']. You press &lt;&lt;&gt;&gt;. You see a blank screen. You see \"false\" written in white.',\n 'data_lst': {'choices': [[],\n   [],\n   ['j', 'f'],\n   [],\n   [],\n   [],\n   [],\n   ['j', 'f'],\n   [],\n   [],\n   [],\n   [],\n   ['j', 'f'],\n   [],\n   [],\n   [],\n   [],\n   ['j', 'f'],\n   [],\n   []],\n  'type': ['jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse'],\n  'text': ['+',\n   '',\n   'RED',\n   '',\n   'false',\n   '+',\n   '',\n   'GREEN',\n   '',\n   'false',\n   '+',\n   '',\n   'RED',\n   '',\n   'false',\n   '+',\n   '',\n   'GREEN',\n   '',\n   'false'],\n  'color': ['white',\n   'white',\n   'red',\n   'white',\n   'white',\n   'white',\n   'white',\n   'green',\n   'white',\n   'white',\n   'white',\n   'white',\n   'green',\n   'white',\n   'white',\n   'white',\n   'white',\n   'red',\n   'white',\n   'white'],\n  'duration': [1000,\n   400,\n   2000,\n   300,\n   800,\n   1000,\n   400,\n   2000,\n   300,\n   800,\n   1000,\n   400,\n   2000,\n   300,\n   800,\n   1000,\n   400,\n   2000,\n   300,\n   800],\n  'correct_key': ['',\n   '',\n   'f',\n   '',\n   '',\n   '',\n   '',\n   'j',\n   '',\n   '',\n   '',\n   '',\n   'j',\n   '',\n   '',\n   '',\n   '',\n   'f',\n   '',\n   ''],\n  'correct': [None,\n   None,\n   False,\n   None,\n   None,\n   None,\n   None,\n   False,\n   None,\n   None,\n   None,\n   None,\n   False,\n   None,\n   None,\n   None,\n   None,\n   False,\n   None,\n   None],\n  'response': [None,\n   None,\n   '',\n   None,\n   None,\n   None,\n   None,\n   '',\n   None,\n   None,\n   None,\n   None,\n   '',\n   None,\n   None,\n   None,\n   None,\n   '',\n   None,\n   None]},\n 'prompts_single': [' You see \"+\" written in white.',\n  ' You see a blank screen.',\n  ' You see \"RED\" written in red. You can press [\\'j\\', \\'f\\']. You press &lt;&lt;',\n  ' You see a blank screen.',\n  ' You see \"false\" written in white.',\n  ' You see \"+\" written in white.',\n  ' You see a blank screen.',\n  ' You see \"GREEN\" written in green. You can press [\\'j\\', \\'f\\']. You press &lt;&lt;',\n  ' You see a blank screen.',\n  ' You see \"false\" written in white.',\n  ' You see \"+\" written in white.',\n  ' You see a blank screen.',\n  ' You see \"RED\" written in green. You can press [\\'j\\', \\'f\\']. You press &lt;&lt;',\n  ' You see a blank screen.',\n  ' You see \"false\" written in white.',\n  ' You see \"+\" written in white.',\n  ' You see a blank screen.',\n  ' You see \"GREEN\" written in red. You can press [\\'j\\', \\'f\\']. You press &lt;&lt;',\n  ' You see a blank screen.',\n  ' You see \"false\" written in white.'],\n 'prompts_multiturn': [[...], [...], [...], [...]],\n 'intro': '',\n 'reaction_appendix': '{{reaction}}&gt;&gt;.',\n 'multiturn': True}</pre> <p>Let's run the experiment on the AI. Here, we use api calls to google cloud, but all that is needed is a function that generates text from other text. In this case <code>generate</code> uses the input and makes an api call and returns the response.</p> In\u00a0[3]: Copied! <pre>def parse_response(response, correct_key):\n return correct_key in response\n\n\ndata_ai = experiment.run_on_language(get_input=generate, parse_response=parse_response,\n                                     intro=\"You are a participant in a psychological experiment. You're goal is not to react as accurate as possible but as similar to a human as possible. This includes making similar mistakes as humans. You will be given a sequence of things you see and your goal is to react with a single letter indicating a key press. Your response should always be a single letter. Please respond with the keys 'j' and 'f' to indicate the color of the word. The correct key for red is 'f' and for green 'j'. Please indicate your response by either f or j.\")\ndata_ai\n</pre> def parse_response(response, correct_key):  return correct_key in response   data_ai = experiment.run_on_language(get_input=generate, parse_response=parse_response,                                      intro=\"You are a participant in a psychological experiment. You're goal is not to react as accurate as possible but as similar to a human as possible. This includes making similar mistakes as humans. You will be given a sequence of things you see and your goal is to react with a single letter indicating a key press. Your response should always be a single letter. Please respond with the keys 'j' and 'f' to indicate the color of the word. The correct key for red is 'f' and for green 'j'. Please indicate your response by either f or j.\") data_ai <pre>/Users/younesstrittmatter/Documents/GitHub/AutoResearch/sweetbean/.venv/lib/python3.11/site-packages/google/auth/_default.py:76: UserWarning: Your application has authenticated using end user credentials from Google Cloud SDK without a quota project. You might receive a \"quota exceeded\" or \"API not enabled\" error. See the following page for troubleshooting: https://cloud.google.com/docs/authentication/adc-troubleshooting/user-creds. \n  warnings.warn(_CLOUD_SDK_CREDENTIALS_WARNING)\n</pre> Out[3]: <pre>{'full_chat': 'You are a participant in a psychological experiment. You\\'re goal is not to react as accurate as possible but as similar to a human as possible. This includes making similar mistakes as humans. You will be given a sequence of things you see and your goal is to react with a single letter indicating a key press. Your response should always be a single letter. Please respond with the keys \\'j\\' and \\'f\\' to indicate the color of the word. The correct key for red is \\'f\\' and for green \\'j\\'. Please indicate your response by either f or j. You see \"+\" written in white. You see a blank screen. You see \"RED\" written in red. You can press [\\'j\\', \\'f\\']. You press &lt;&lt;f&gt;&gt;. You see a blank screen. You see \"correct\" written in white. You see \"+\" written in white. You see a blank screen. You see \"GREEN\" written in green. You can press [\\'j\\', \\'f\\']. You press &lt;&lt;j&gt;&gt;. You see a blank screen. You see \"correct\" written in white. You see \"+\" written in white. You see a blank screen. You see \"RED\" written in green. You can press [\\'j\\', \\'f\\']. You press &lt;&lt;j&gt;&gt;. You see a blank screen. You see \"correct\" written in white. You see \"+\" written in white. You see a blank screen. You see \"GREEN\" written in red. You can press [\\'j\\', \\'f\\']. You press &lt;&lt;f&gt;&gt;. You see a blank screen. You see \"correct\" written in white.',\n 'data_lst': {'choices': [[],\n   [],\n   ['j', 'f'],\n   [],\n   [],\n   [],\n   [],\n   ['j', 'f'],\n   [],\n   [],\n   [],\n   [],\n   ['j', 'f'],\n   [],\n   [],\n   [],\n   [],\n   ['j', 'f'],\n   [],\n   []],\n  'type': ['jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse',\n   'jsPsychHtmlKeyboardResponse'],\n  'text': ['+',\n   '',\n   'RED',\n   '',\n   'correct',\n   '+',\n   '',\n   'GREEN',\n   '',\n   'correct',\n   '+',\n   '',\n   'RED',\n   '',\n   'correct',\n   '+',\n   '',\n   'GREEN',\n   '',\n   'correct'],\n  'color': ['white',\n   'white',\n   'red',\n   'white',\n   'white',\n   'white',\n   'white',\n   'green',\n   'white',\n   'white',\n   'white',\n   'white',\n   'green',\n   'white',\n   'white',\n   'white',\n   'white',\n   'red',\n   'white',\n   'white'],\n  'duration': [1000,\n   400,\n   2000,\n   300,\n   800,\n   1000,\n   400,\n   2000,\n   300,\n   800,\n   1000,\n   400,\n   2000,\n   300,\n   800,\n   1000,\n   400,\n   2000,\n   300,\n   800],\n  'correct_key': ['',\n   '',\n   'f',\n   '',\n   '',\n   '',\n   '',\n   'j',\n   '',\n   '',\n   '',\n   '',\n   'j',\n   '',\n   '',\n   '',\n   '',\n   'f',\n   '',\n   ''],\n  'correct': [None,\n   None,\n   True,\n   None,\n   None,\n   None,\n   None,\n   True,\n   None,\n   None,\n   None,\n   None,\n   True,\n   None,\n   None,\n   None,\n   None,\n   True,\n   None,\n   None],\n  'response': [None,\n   None,\n   'f',\n   None,\n   None,\n   None,\n   None,\n   'j',\n   None,\n   None,\n   None,\n   None,\n   'j',\n   None,\n   None,\n   None,\n   None,\n   'f',\n   None,\n   None]},\n 'prompts_single': [' You see \"+\" written in white.',\n  ' You see a blank screen.',\n  ' You see \"RED\" written in red. You can press [\\'j\\', \\'f\\']. You press &lt;&lt;',\n  'f',\n  ' You see a blank screen.',\n  ' You see \"correct\" written in white.',\n  ' You see \"+\" written in white.',\n  ' You see a blank screen.',\n  ' You see \"GREEN\" written in green. You can press [\\'j\\', \\'f\\']. You press &lt;&lt;',\n  'j',\n  ' You see a blank screen.',\n  ' You see \"correct\" written in white.',\n  ' You see \"+\" written in white.',\n  ' You see a blank screen.',\n  ' You see \"RED\" written in green. You can press [\\'j\\', \\'f\\']. You press &lt;&lt;',\n  'j',\n  ' You see a blank screen.',\n  ' You see \"correct\" written in white.',\n  ' You see \"+\" written in white.',\n  ' You see a blank screen.',\n  ' You see \"GREEN\" written in red. You can press [\\'j\\', \\'f\\']. You press &lt;&lt;',\n  'f',\n  ' You see a blank screen.',\n  ' You see \"correct\" written in white.'],\n 'prompts_multiturn': [[...], [...], [...], [...]],\n 'intro': \"You are a participant in a psychological experiment. You're goal is not to react as accurate as possible but as similar to a human as possible. This includes making similar mistakes as humans. You will be given a sequence of things you see and your goal is to react with a single letter indicating a key press. Your response should always be a single letter. Please respond with the keys 'j' and 'f' to indicate the color of the word. The correct key for red is 'f' and for green 'j'. Please indicate your response by either f or j.\",\n 'reaction_appendix': '{{reaction}}&gt;&gt;.',\n 'multiturn': False}</pre>"},{"location":"Notebooks/Basic%20LLM%20Experiment/#basic-llm-experiment","title":"Basic LLM Experiment\u00b6","text":"<p>Here, we run a experiment with a llm model via api.</p> <p>As prerequisite, we create functions that call the api on prompts and returns the response:</p>"},{"location":"Notebooks/Basic%20LLM%20Experiment/#define-the-experiment","title":"Define the experiment\u00b6","text":"<p>First, we define the experiment.</p>"},{"location":"Notebooks/tst/","title":"Tst","text":"In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import Bandit, Text\nfrom sweetbean.util.prompts import demographic\nfrom sweetbean.variable import (\n    DataVariable,\n    FunctionVariable,\n    SharedVariable,\n    SideEffect,\n    TimelineVariable,\n)\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import Bandit, Text from sweetbean.util.prompts import demographic from sweetbean.variable import (     DataVariable,     FunctionVariable,     SharedVariable,     SideEffect,     TimelineVariable, ) In\u00a0[\u00a0]: Copied! <pre>timeline = [\n    {\n        \"bandit_1\": {\"color\": \"orange\", \"value\": 10},\n        \"bandit_2\": {\"color\": \"blue\", \"value\": 0},\n        \"bandit_3\": {\"color\": \"red\", \"value\": 5},\n    },\n    {\n        \"bandit_1\": {\"color\": \"orange\", \"value\": 9},\n        \"bandit_2\": {\"color\": \"blue\", \"value\": 1},\n        \"bandit_3\": {\"color\": \"red\", \"value\": 5},\n    },\n    {\n        \"bandit_1\": {\"color\": \"orange\", \"value\": 8},\n        \"bandit_2\": {\"color\": \"blue\", \"value\": 2},\n        \"bandit_3\": {\"color\": \"red\", \"value\": 5},\n    },\n    {\n        \"bandit_1\": {\"color\": \"orange\", \"value\": 7},\n        \"bandit_2\": {\"color\": \"blue\", \"value\": 3},\n        \"bandit_3\": {\"color\": \"red\", \"value\": 5},\n    },\n    {\n        \"bandit_1\": {\"color\": \"orange\", \"value\": 6},\n        \"bandit_2\": {\"color\": \"blue\", \"value\": 4},\n        \"bandit_3\": {\"color\": \"red\", \"value\": 5},\n    },\n]\n</pre> timeline = [     {         \"bandit_1\": {\"color\": \"orange\", \"value\": 10},         \"bandit_2\": {\"color\": \"blue\", \"value\": 0},         \"bandit_3\": {\"color\": \"red\", \"value\": 5},     },     {         \"bandit_1\": {\"color\": \"orange\", \"value\": 9},         \"bandit_2\": {\"color\": \"blue\", \"value\": 1},         \"bandit_3\": {\"color\": \"red\", \"value\": 5},     },     {         \"bandit_1\": {\"color\": \"orange\", \"value\": 8},         \"bandit_2\": {\"color\": \"blue\", \"value\": 2},         \"bandit_3\": {\"color\": \"red\", \"value\": 5},     },     {         \"bandit_1\": {\"color\": \"orange\", \"value\": 7},         \"bandit_2\": {\"color\": \"blue\", \"value\": 3},         \"bandit_3\": {\"color\": \"red\", \"value\": 5},     },     {         \"bandit_1\": {\"color\": \"orange\", \"value\": 6},         \"bandit_2\": {\"color\": \"blue\", \"value\": 4},         \"bandit_3\": {\"color\": \"red\", \"value\": 5},     }, ] In\u00a0[\u00a0]: Copied! <pre>bandit_1 = TimelineVariable(\"bandit_1\")\nbandit_2 = TimelineVariable(\"bandit_2\")\nbandit_3 = TimelineVariable(\"bandit_3\")\n</pre> bandit_1 = TimelineVariable(\"bandit_1\") bandit_2 = TimelineVariable(\"bandit_2\") bandit_3 = TimelineVariable(\"bandit_3\") In\u00a0[\u00a0]: Copied! <pre>score = SharedVariable(\"score\", 0)\nvalue = DataVariable(\"value\", 0)\n</pre> score = SharedVariable(\"score\", 0) value = DataVariable(\"value\", 0) In\u00a0[\u00a0]: Copied! <pre>update_score = FunctionVariable(\n    \"update_score\", lambda sc, val: sc + val, [score, value]\n)\n</pre> update_score = FunctionVariable(     \"update_score\", lambda sc, val: sc + val, [score, value] ) In\u00a0[\u00a0]: Copied! <pre>update_score_side_effect = SideEffect(score, update_score)\n</pre> update_score_side_effect = SideEffect(score, update_score) In\u00a0[\u00a0]: Copied! <pre>bandit_task = Bandit(\n    bandits=[bandit_1, bandit_2, bandit_3],\n    side_effects=[update_score_side_effect],\n)\nshow_score = Text(duration=1000, text=score)\n</pre> bandit_task = Bandit(     bandits=[bandit_1, bandit_2, bandit_3],     side_effects=[update_score_side_effect], ) show_score = Text(duration=1000, text=score) In\u00a0[\u00a0]: Copied! <pre>trial_sequence = Block([bandit_task, show_score], timeline=timeline)\nexperiment = Experiment([trial_sequence])\n</pre> trial_sequence = Block([bandit_task, show_score], timeline=timeline) experiment = Experiment([trial_sequence]) In\u00a0[\u00a0]: Copied! <pre>data, prompts = experiment.run_on_language(preamble=demographic(37, \"man\"))\n</pre> data, prompts = experiment.run_on_language(preamble=demographic(37, \"man\")) In\u00a0[\u00a0]: Copied! <pre>print(data, prompts)\n</pre> print(data, prompts)"},{"location":"Stimuli/","title":"Stimuli","text":"<p>An overview of the stimuli that can be used in SweetBean experiments.</p> <p>If you are using non-generic stimuli (see bellow), you will not need to import any jsPsych plugins manually and can use all features of SweetBean without any additional setup including running the experiment on language models and exporting stimuli image sequences.</p>"},{"location":"Stimuli/#generic-stimuli-only-in-pre-release","title":"Generic Stimuli (only in pre-release)","text":"<p>The user can define generic jsPsych stimuli using the Generic Class and the arguments found in the jsPsych documentation or on jsPsych contrib. This provides the user with the flexibility to use any jsPsych stimuli in their experiments. However, the user must ensure that the stimuli are imported to their script manually. For example, by adding the following line to the top of their generated html script (replacing <code>&lt;plugin-name&gt;</code> with the name of the plugin):</p> <pre><code>&lt;script src=\"https://unpkg.com/@jspsych/&lt;plugin-name&gt;\"&gt;&lt;/script&gt;\n</code></pre> <p>Warning: Generic stimuli do not support running experiments on language models or exporting stimuli image sequences.</p>"},{"location":"Stimuli/bandit/","title":"Bandit","text":"<p>Present a grid of colored squares representing multiple \u201cbandits.\u201d The participant clicks a square to choose one option. The stimulus records the selected index (<code>choice</code>) and a corresponding <code>value</code> (e.g., payout/label). The layout adapts to the number of bandits, and a short post-response delay can drive simple animations before the trial ends.</p>"},{"location":"Stimuli/bandit/#when-to-use","title":"When To Use","text":"<ul> <li>Multi-armed bandit tasks with several simultaneous options.</li> <li>Reward/payout choice screens where each option has an associated value.</li> <li>Visual grids of clickable alternatives.</li> </ul>"},{"location":"Stimuli/bandit/#examples","title":"Examples","text":"<p>A three-armed bandit task for reinforcement learning. The task is to choose between options, each with a different value.</p> <p></p>"},{"location":"Stimuli/bandit/bandit/","title":"Bandit","text":"In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import Bandit, Text\nfrom sweetbean.variable import (\n    DataVariable,\n    FunctionVariable,\n    SharedVariable,\n    SideEffect,\n    TimelineVariable,\n)\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import Bandit, Text from sweetbean.variable import (     DataVariable,     FunctionVariable,     SharedVariable,     SideEffect,     TimelineVariable, ) In\u00a0[\u00a0]: Copied! <pre>timeline = [\n    {\n        \"bandit_1\": {\"color\": \"orange\", \"value\": 10},\n        \"bandit_2\": {\"color\": \"blue\", \"value\": 0},\n        \"bandit_3\": {\"color\": \"red\", \"value\": 5},\n    },\n    {\n        \"bandit_1\": {\"color\": \"orange\", \"value\": 9},\n        \"bandit_2\": {\"color\": \"blue\", \"value\": 1},\n        \"bandit_3\": {\"color\": \"red\", \"value\": 5},\n    },\n    {\n        \"bandit_1\": {\"color\": \"orange\", \"value\": 8},\n        \"bandit_2\": {\"color\": \"blue\", \"value\": 2},\n        \"bandit_3\": {\"color\": \"red\", \"value\": 5},\n    },\n    {\n        \"bandit_1\": {\"color\": \"orange\", \"value\": 7},\n        \"bandit_2\": {\"color\": \"blue\", \"value\": 3},\n        \"bandit_3\": {\"color\": \"red\", \"value\": 5},\n    },\n    {\n        \"bandit_1\": {\"color\": \"orange\", \"value\": 6},\n        \"bandit_2\": {\"color\": \"blue\", \"value\": 4},\n        \"bandit_3\": {\"color\": \"red\", \"value\": 5},\n    },\n]\n</pre> timeline = [     {         \"bandit_1\": {\"color\": \"orange\", \"value\": 10},         \"bandit_2\": {\"color\": \"blue\", \"value\": 0},         \"bandit_3\": {\"color\": \"red\", \"value\": 5},     },     {         \"bandit_1\": {\"color\": \"orange\", \"value\": 9},         \"bandit_2\": {\"color\": \"blue\", \"value\": 1},         \"bandit_3\": {\"color\": \"red\", \"value\": 5},     },     {         \"bandit_1\": {\"color\": \"orange\", \"value\": 8},         \"bandit_2\": {\"color\": \"blue\", \"value\": 2},         \"bandit_3\": {\"color\": \"red\", \"value\": 5},     },     {         \"bandit_1\": {\"color\": \"orange\", \"value\": 7},         \"bandit_2\": {\"color\": \"blue\", \"value\": 3},         \"bandit_3\": {\"color\": \"red\", \"value\": 5},     },     {         \"bandit_1\": {\"color\": \"orange\", \"value\": 6},         \"bandit_2\": {\"color\": \"blue\", \"value\": 4},         \"bandit_3\": {\"color\": \"red\", \"value\": 5},     }, ] In\u00a0[\u00a0]: Copied! <pre>bandit_1 = TimelineVariable(\"bandit_1\")\nbandit_2 = TimelineVariable(\"bandit_2\")\nbandit_3 = TimelineVariable(\"bandit_3\")\n</pre> bandit_1 = TimelineVariable(\"bandit_1\") bandit_2 = TimelineVariable(\"bandit_2\") bandit_3 = TimelineVariable(\"bandit_3\") In\u00a0[\u00a0]: Copied! <pre>score = SharedVariable(\"score\", 0)\nvalue = DataVariable(\"value\", 0)\n</pre> score = SharedVariable(\"score\", 0) value = DataVariable(\"value\", 0) In\u00a0[\u00a0]: Copied! <pre>update_score = FunctionVariable(\n    \"update_score\", lambda sc, val: sc + val, [score, value]\n)\n</pre> update_score = FunctionVariable(     \"update_score\", lambda sc, val: sc + val, [score, value] ) In\u00a0[\u00a0]: Copied! <pre>update_score_side_effect = SideEffect(score, update_score)\n</pre> update_score_side_effect = SideEffect(score, update_score) In\u00a0[\u00a0]: Copied! <pre>bandit_task = Bandit(\n    bandits=[bandit_1, bandit_2, bandit_3],\n    side_effects=[update_score_side_effect],\n)\nshow_score = Text(duration=1000, text=score)\n</pre> bandit_task = Bandit(     bandits=[bandit_1, bandit_2, bandit_3],     side_effects=[update_score_side_effect], ) show_score = Text(duration=1000, text=score) In\u00a0[\u00a0]: Copied! <pre>block = Block([bandit_task, show_score], timeline=timeline)\n</pre> block = Block([bandit_task, show_score], timeline=timeline) In\u00a0[\u00a0]: Copied! <pre># Create an image of the stimuli sequence of the block\nblock.to_image(\"bandit.png\", [{\"value\": 5}, None], zoom_factor=[1, 3])\n</pre> # Create an image of the stimuli sequence of the block block.to_image(\"bandit.png\", [{\"value\": 5}, None], zoom_factor=[1, 3]) In\u00a0[\u00a0]: Copied! <pre># Create HTML file of the experiment\nexperiment = Experiment([block])\nexperiment.to_html(\"bandit.html\")\n</pre> # Create HTML file of the experiment experiment = Experiment([block]) experiment.to_html(\"bandit.html\")"},{"location":"Stimuli/bilateralrsvp/","title":"BilateralRSVP","text":"<p>Present two synchronized RSVP streams (left and right) where one item per side appears each frame. Participants detect or identify a target on one stream (by feature/shape or content) while the opposite stream can carry a simultaneous distractor. You control per-frame timing (duration/ISI), per-side item sequences, optional masks, target/distractor annotations (shape/underline), keyboard response handling, and overall trial duration. Only works with simple visual items (text, single symbols); for more complex or layered stimuli, consider the Symbol or Html plugins.</p>"},{"location":"Stimuli/bilateralrsvp/#when-to-use","title":"When To Use","text":"<ul> <li>Classic left\u2013right RSVP with a single target per trial.</li> <li>Shape-/feature-defined targets (e.g., circle vs. square) with optional post-target distractors.</li> <li>Lateralized EEG/ERP paradigms (e.g., N2pc) needing stable bilateral placement.</li> <li>Two-alternative forced-choice or identification tasks following rapid bilateral streams.</li> </ul>"},{"location":"Stimuli/bilateralrsvp/bilateralrsvp/","title":"Bilateralrsvp","text":"In\u00a0[\u00a0]: Copied! <pre>from sweetbean.block import Block\nfrom sweetbean.experiment import Experiment\nfrom sweetbean.stimulus import BilateralRSVP, Feedback, Text\nfrom sweetbean.variable import FunctionVariable, TimelineVariable\n</pre> from sweetbean.block import Block from sweetbean.experiment import Experiment from sweetbean.stimulus import BilateralRSVP, Feedback, Text from sweetbean.variable import FunctionVariable, TimelineVariable In\u00a0[\u00a0]: Copied! <pre># -------------------------\n# Trial table (streams are PURE CONTENT)\n# -------------------------\ntimeline = [\n    {\n        \"left_stream\": [\"O\", \"O\", \"Q\", \"Q\", \"O\", \"Q\"],\n        \"right_stream\": [\"1\", \"1\", \"2\", \"3\", \"4\", \"5\"],\n        \"left_target_index\": 4,  # zero-based\n        \"left_target_shape\": \"circle\",\n        \"right_target_index\": 4,\n        \"right_target_shape\": \"square\",\n        \"correct_key\": \"o\",\n    },\n    {\n        \"left_stream\": [\"O\", \"Q\", \"Q\", \"O\", \"Q\", \"O\"],\n        \"right_stream\": [\"1\", \"1\", \"2\", \"3\", \"4\", \"5\"],\n        \"left_target_index\": 2,\n        \"left_target_shape\": \"circle\",\n        \"right_target_index\": 2,\n        \"right_target_shape\": \"square\",\n        \"correct_key\": \"q\",\n    },\n    {\n        \"left_stream\": [\"O\", \"O\", \"Q\", \"O\", \"O\", \"O\"],\n        \"right_stream\": [\"1\", \"1\", \"2\", \"3\", \"4\", \"5\"],\n        \"left_target_index\": 2,\n        \"left_target_shape\": \"square\",\n        \"right_target_index\": 2,\n        \"right_target_shape\": \"circle\",\n        \"correct_key\": \"2\",\n    },\n]\n</pre> # ------------------------- # Trial table (streams are PURE CONTENT) # ------------------------- timeline = [     {         \"left_stream\": [\"O\", \"O\", \"Q\", \"Q\", \"O\", \"Q\"],         \"right_stream\": [\"1\", \"1\", \"2\", \"3\", \"4\", \"5\"],         \"left_target_index\": 4,  # zero-based         \"left_target_shape\": \"circle\",         \"right_target_index\": 4,         \"right_target_shape\": \"square\",         \"correct_key\": \"o\",     },     {         \"left_stream\": [\"O\", \"Q\", \"Q\", \"O\", \"Q\", \"O\"],         \"right_stream\": [\"1\", \"1\", \"2\", \"3\", \"4\", \"5\"],         \"left_target_index\": 2,         \"left_target_shape\": \"circle\",         \"right_target_index\": 2,         \"right_target_shape\": \"square\",         \"correct_key\": \"q\",     },     {         \"left_stream\": [\"O\", \"O\", \"Q\", \"O\", \"O\", \"O\"],         \"right_stream\": [\"1\", \"1\", \"2\", \"3\", \"4\", \"5\"],         \"left_target_index\": 2,         \"left_target_shape\": \"square\",         \"right_target_index\": 2,         \"right_target_shape\": \"circle\",         \"correct_key\": \"2\",     }, ] In\u00a0[\u00a0]: Copied! <pre># -------------------------\n# Helper functions for per-trial logic\n# -------------------------\ndef pick_target_side(left_shape, right_shape):\n    ls = str(left_shape).strip().lower()\n    rs = str(right_shape).strip().lower()\n    if ls == \"circle\" and rs != \"circle\":\n        return \"left\"\n    if rs == \"circle\" and ls != \"circle\":\n        return \"right\"\n    return \"left\"\n</pre> # ------------------------- # Helper functions for per-trial logic # ------------------------- def pick_target_side(left_shape, right_shape):     ls = str(left_shape).strip().lower()     rs = str(right_shape).strip().lower()     if ls == \"circle\" and rs != \"circle\":         return \"left\"     if rs == \"circle\" and ls != \"circle\":         return \"right\"     return \"left\" In\u00a0[\u00a0]: Copied! <pre>def pick_target_index(side, left_idx, right_idx):\n    return int(left_idx) if str(side) == \"left\" else int(right_idx)\n</pre> def pick_target_index(side, left_idx, right_idx):     return int(left_idx) if str(side) == \"left\" else int(right_idx) In\u00a0[\u00a0]: Copied! <pre>def pick_target_shape(side, left_shape, right_shape):\n    return (\n        (str(left_shape) if str(side) == \"left\" else str(right_shape)).strip().lower()\n    )\n</pre> def pick_target_shape(side, left_shape, right_shape):     return (         (str(left_shape) if str(side) == \"left\" else str(right_shape)).strip().lower()     ) In\u00a0[\u00a0]: Copied! <pre>def pick_distractor_shape(side, left_shape, right_shape):\n    # use the *other* side's shape as the distractor decoration\n    return (\n        (str(right_shape) if str(side) == \"left\" else str(left_shape)).strip().lower()\n    )\n</pre> def pick_distractor_shape(side, left_shape, right_shape):     # use the *other* side's shape as the distractor decoration     return (         (str(right_shape) if str(side) == \"left\" else str(left_shape)).strip().lower()     ) In\u00a0[\u00a0]: Copied! <pre>def plus_one(i):  # for post-target distractor at t+1\n    return int(i) + 1\n</pre> def plus_one(i):  # for post-target distractor at t+1     return int(i) + 1 In\u00a0[\u00a0]: Copied! <pre># -------------------------\n# Variables (evaluated per timeline row)\n# -------------------------\nvar_target_side = FunctionVariable(\n    name=\"target_side\",\n    fct=pick_target_side,\n    args=[\n        TimelineVariable(\"left_target_shape\"),\n        TimelineVariable(\"right_target_shape\"),\n    ],\n)\n</pre> # ------------------------- # Variables (evaluated per timeline row) # ------------------------- var_target_side = FunctionVariable(     name=\"target_side\",     fct=pick_target_side,     args=[         TimelineVariable(\"left_target_shape\"),         TimelineVariable(\"right_target_shape\"),     ], ) In\u00a0[\u00a0]: Copied! <pre>var_target_index = FunctionVariable(\n    name=\"target_index\",\n    fct=pick_target_index,\n    args=[\n        var_target_side,\n        TimelineVariable(\"left_target_index\"),\n        TimelineVariable(\"right_target_index\"),\n    ],\n)\n</pre> var_target_index = FunctionVariable(     name=\"target_index\",     fct=pick_target_index,     args=[         var_target_side,         TimelineVariable(\"left_target_index\"),         TimelineVariable(\"right_target_index\"),     ], ) In\u00a0[\u00a0]: Copied! <pre>var_target_shape = FunctionVariable(\n    name=\"target_shape\",\n    fct=pick_target_shape,\n    args=[\n        var_target_side,\n        TimelineVariable(\"left_target_shape\"),\n        TimelineVariable(\"right_target_shape\"),\n    ],\n)\n</pre> var_target_shape = FunctionVariable(     name=\"target_shape\",     fct=pick_target_shape,     args=[         var_target_side,         TimelineVariable(\"left_target_shape\"),         TimelineVariable(\"right_target_shape\"),     ], ) In\u00a0[\u00a0]: Copied! <pre>var_distractor_shape = FunctionVariable(\n    name=\"distractor_shape\",\n    fct=pick_distractor_shape,\n    args=[\n        var_target_side,\n        TimelineVariable(\"left_target_shape\"),\n        TimelineVariable(\"right_target_shape\"),\n    ],\n)\n</pre> var_distractor_shape = FunctionVariable(     name=\"distractor_shape\",     fct=pick_distractor_shape,     args=[         var_target_side,         TimelineVariable(\"left_target_shape\"),         TimelineVariable(\"right_target_shape\"),     ], ) In\u00a0[\u00a0]: Copied! <pre>var_post_index = FunctionVariable(\n    name=\"post_index\",\n    fct=plus_one,\n    args=[var_target_index],\n)\n</pre> var_post_index = FunctionVariable(     name=\"post_index\",     fct=plus_one,     args=[var_target_index], ) In\u00a0[\u00a0]: Copied! <pre># -------------------------\n# Shared response + feedback\n# -------------------------\ndef make_response_window(prompt=\"What was the target symbol?\"):\n    return Text(\n        text=prompt,\n        choices=list(\"abcdefghijklmnopqrstuvwxyz0123456789\"),\n        correct_key=TimelineVariable(\"correct_key\"),\n    )\n</pre> # ------------------------- # Shared response + feedback # ------------------------- def make_response_window(prompt=\"What was the target symbol?\"):     return Text(         text=prompt,         choices=list(\"abcdefghijklmnopqrstuvwxyz0123456789\"),         correct_key=TimelineVariable(\"correct_key\"),     ) In\u00a0[\u00a0]: Copied! <pre>def make_feedback():\n    return Feedback(duration=300)\n</pre> def make_feedback():     return Feedback(duration=300) In\u00a0[\u00a0]: Copied! <pre># -------------------------\n# VARIANT 1 \u2014 Color-only targets (shape 'none') + underline distractor (opposite side)\n# -------------------------\nrsvp_v1 = BilateralRSVP(\n    left=TimelineVariable(\"left_stream\"),\n    right=TimelineVariable(\"right_stream\"),\n    target_side=var_target_side,\n    target_index=var_target_index,\n    target_shape=\"none\",\n    target_color=\"#00b050\",  # colors the glyph itself\n    distractor_shape=\"underline\",\n    distractor_color=\"#888\",\n    stimulus_duration=200,\n    isi=40,\n    choices=\"NO_KEYS\",\n)\nblock_v1 = Block([rsvp_v1, make_response_window(), make_feedback()], timeline=timeline)\n</pre> # ------------------------- # VARIANT 1 \u2014 Color-only targets (shape 'none') + underline distractor (opposite side) # ------------------------- rsvp_v1 = BilateralRSVP(     left=TimelineVariable(\"left_stream\"),     right=TimelineVariable(\"right_stream\"),     target_side=var_target_side,     target_index=var_target_index,     target_shape=\"none\",     target_color=\"#00b050\",  # colors the glyph itself     distractor_shape=\"underline\",     distractor_color=\"#888\",     stimulus_duration=200,     isi=40,     choices=\"NO_KEYS\", ) block_v1 = Block([rsvp_v1, make_response_window(), make_feedback()], timeline=timeline) In\u00a0[\u00a0]: Copied! <pre># -------------------------\n# VARIANT 2 \u2014 Target HTML template + circle distractor\n# -------------------------\nrsvp_v2 = BilateralRSVP(\n    left=TimelineVariable(\"left_stream\"),\n    right=TimelineVariable(\"right_stream\"),\n    target_side=var_target_side,\n    target_index=var_target_index,\n    target_shape=\"none\",  # HTML wrapper handles appearance\n    target_html=(\n        '&lt;span style=\"font-weight:800;color:#ff4d4d;'\n        'border-bottom:3px solid #ff7f00;padding:0.05em 0.2em\"&gt;{{content}}&lt;/span&gt;'\n    ),\n    distractor_shape=\"circle\",\n    distractor_color=\"#bbbbbb\",\n    stimulus_duration=200,\n    isi=40,\n    choices=\"NO_KEYS\",\n)\nblock_v2 = Block([rsvp_v2, make_response_window(), make_feedback()], timeline=timeline)\n</pre> # ------------------------- # VARIANT 2 \u2014 Target HTML template + circle distractor # ------------------------- rsvp_v2 = BilateralRSVP(     left=TimelineVariable(\"left_stream\"),     right=TimelineVariable(\"right_stream\"),     target_side=var_target_side,     target_index=var_target_index,     target_shape=\"none\",  # HTML wrapper handles appearance     target_html=(         '{{content}}'     ),     distractor_shape=\"circle\",     distractor_color=\"#bbbbbb\",     stimulus_duration=200,     isi=40,     choices=\"NO_KEYS\", ) block_v2 = Block([rsvp_v2, make_response_window(), make_feedback()], timeline=timeline) In\u00a0[\u00a0]: Copied! <pre># -------------------------\n# VARIANT 3 \u2014 Arrays/broadcasting (two targets + two distractors)\n# NOTE: This is a multi-target demo; your response window still asks for a single key.\n# -------------------------\nrsvp_v3 = BilateralRSVP(\n    left=TimelineVariable(\"left_stream\"),\n    right=TimelineVariable(\"right_stream\"),\n    # two targets\n    target_index=[2, 4],\n    target_side=[\"left\", \"right\"],\n    target_shape=[\"circle\", \"square\"],\n    target_color=[\"#00b050\", \"#ff7f00\"],\n    # two distractors (sides omitted \u2192 opposite of each target)\n    distractor_index=[2, 4],\n    distractor_shape=[\"underline\", \"circle\"],\n    distractor_color=[\"#888\", \"#bbb\"],\n    stimulus_duration=180,\n    isi=40,\n    choices=\"NO_KEYS\",\n)\nblock_v3 = Block(\n    [\n        rsvp_v3,\n        make_response_window(\"(Demo) Enter any target you saw:\"),\n        make_feedback(),\n    ],\n    timeline=timeline,\n)\n</pre> # ------------------------- # VARIANT 3 \u2014 Arrays/broadcasting (two targets + two distractors) # NOTE: This is a multi-target demo; your response window still asks for a single key. # ------------------------- rsvp_v3 = BilateralRSVP(     left=TimelineVariable(\"left_stream\"),     right=TimelineVariable(\"right_stream\"),     # two targets     target_index=[2, 4],     target_side=[\"left\", \"right\"],     target_shape=[\"circle\", \"square\"],     target_color=[\"#00b050\", \"#ff7f00\"],     # two distractors (sides omitted \u2192 opposite of each target)     distractor_index=[2, 4],     distractor_shape=[\"underline\", \"circle\"],     distractor_color=[\"#888\", \"#bbb\"],     stimulus_duration=180,     isi=40,     choices=\"NO_KEYS\", ) block_v3 = Block(     [         rsvp_v3,         make_response_window(\"(Demo) Enter any target you saw:\"),         make_feedback(),     ],     timeline=timeline, ) In\u00a0[\u00a0]: Copied! <pre># -------------------------\n# VARIANT 4 \u2014 Post-target distractor at index + 1 (opposite side by default)\n# -------------------------\nrsvp_v4 = BilateralRSVP(\n    left=TimelineVariable(\"left_stream\"),\n    right=TimelineVariable(\"right_stream\"),\n    target_side=var_target_side,\n    target_index=var_target_index,\n    target_shape=\"none\",\n    target_color=\"#167ad3\",\n    distractor_index=var_post_index,  # t+1\n    distractor_shape=\"underline\",\n    distractor_color=\"#888\",\n    stimulus_duration=50,  # EEG-style 50/50 \u2192 10 Hz\n    isi=50,\n    choices=\"NO_KEYS\",\n)\nblock_v4 = Block([rsvp_v4, make_response_window(), make_feedback()], timeline=timeline)\n</pre> # ------------------------- # VARIANT 4 \u2014 Post-target distractor at index + 1 (opposite side by default) # ------------------------- rsvp_v4 = BilateralRSVP(     left=TimelineVariable(\"left_stream\"),     right=TimelineVariable(\"right_stream\"),     target_side=var_target_side,     target_index=var_target_index,     target_shape=\"none\",     target_color=\"#167ad3\",     distractor_index=var_post_index,  # t+1     distractor_shape=\"underline\",     distractor_color=\"#888\",     stimulus_duration=50,  # EEG-style 50/50 \u2192 10 Hz     isi=50,     choices=\"NO_KEYS\", ) block_v4 = Block([rsvp_v4, make_response_window(), make_feedback()], timeline=timeline) In\u00a0[\u00a0]: Copied! <pre># -------------------------\n# VARIANT 5 \u2014 Mask between frames (ISI) + classic circle target\n# (Kept NO_KEYS so response is collected afterward for consistency.)\n# -------------------------\nrsvp_v5 = BilateralRSVP(\n    left=TimelineVariable(\"left_stream\"),\n    right=TimelineVariable(\"right_stream\"),\n    target_side=var_target_side,\n    target_index=var_target_index,\n    target_shape=\"circle\",\n    target_color=\"#30c050\",\n    distractor_shape=\"none\",\n    stimulus_duration=120,\n    isi=40,\n    mask_html=\"\u2022\",  # shown during ISI\n    choices=\"NO_KEYS\",\n)\nblock_v5 = Block([rsvp_v5, make_response_window(), make_feedback()], timeline=timeline)\n</pre> # ------------------------- # VARIANT 5 \u2014 Mask between frames (ISI) + classic circle target # (Kept NO_KEYS so response is collected afterward for consistency.) # ------------------------- rsvp_v5 = BilateralRSVP(     left=TimelineVariable(\"left_stream\"),     right=TimelineVariable(\"right_stream\"),     target_side=var_target_side,     target_index=var_target_index,     target_shape=\"circle\",     target_color=\"#30c050\",     distractor_shape=\"none\",     stimulus_duration=120,     isi=40,     mask_html=\"\u2022\",  # shown during ISI     choices=\"NO_KEYS\", ) block_v5 = Block([rsvp_v5, make_response_window(), make_feedback()], timeline=timeline) In\u00a0[\u00a0]: Copied! <pre># -------------------------\n# VARIANT 6 \u2014 Per-item HTML on distractor (highlight box), color-only target\n# -------------------------\nrsvp_v6 = BilateralRSVP(\n    left=TimelineVariable(\"left_stream\"),\n    right=TimelineVariable(\"right_stream\"),\n    target_side=var_target_side,\n    target_index=var_target_index,\n    target_shape=\"none\",\n    target_color=\"#ff8c00\",\n    distractor_shape=\"none\",\n    distractor_html=(\n        '&lt;span style=\"display:inline-block;padding:0.1em 0.25em;'\n        'border:2px solid #aaa;border-radius:8%\"&gt;{{content}}&lt;/span&gt;'\n    ),\n    stimulus_duration=200,\n    isi=40,\n    choices=\"NO_KEYS\",\n)\nblock_v6 = Block([rsvp_v6, make_response_window(), make_feedback()], timeline=timeline)\n</pre> # ------------------------- # VARIANT 6 \u2014 Per-item HTML on distractor (highlight box), color-only target # ------------------------- rsvp_v6 = BilateralRSVP(     left=TimelineVariable(\"left_stream\"),     right=TimelineVariable(\"right_stream\"),     target_side=var_target_side,     target_index=var_target_index,     target_shape=\"none\",     target_color=\"#ff8c00\",     distractor_shape=\"none\",     distractor_html=(         '{{content}}'     ),     stimulus_duration=200,     isi=40,     choices=\"NO_KEYS\", ) block_v6 = Block([rsvp_v6, make_response_window(), make_feedback()], timeline=timeline) In\u00a0[\u00a0]: Copied! <pre># -------------------------\n# VARIANT 7 \u2014 Fix distractor side to LEFT (override opposite-side default)\n# -------------------------\nrsvp_v7 = BilateralRSVP(\n    left=TimelineVariable(\"left_stream\"),\n    right=TimelineVariable(\"right_stream\"),\n    target_side=var_target_side,\n    target_index=var_target_index,\n    target_shape=var_target_shape,  # per-trial circle/square from table\n    distractor_side=\"left\",  # force left regardless of target_side\n    distractor_index=var_target_index,\n    distractor_shape=\"square\",\n    distractor_color=\"#999\",\n    stimulus_duration=200,\n    isi=40,\n    choices=\"NO_KEYS\",\n)\nblock_v7 = Block([rsvp_v7, make_response_window(), make_feedback()], timeline=timeline)\n</pre> # ------------------------- # VARIANT 7 \u2014 Fix distractor side to LEFT (override opposite-side default) # ------------------------- rsvp_v7 = BilateralRSVP(     left=TimelineVariable(\"left_stream\"),     right=TimelineVariable(\"right_stream\"),     target_side=var_target_side,     target_index=var_target_index,     target_shape=var_target_shape,  # per-trial circle/square from table     distractor_side=\"left\",  # force left regardless of target_side     distractor_index=var_target_index,     distractor_shape=\"square\",     distractor_color=\"#999\",     stimulus_duration=200,     isi=40,     choices=\"NO_KEYS\", ) block_v7 = Block([rsvp_v7, make_response_window(), make_feedback()], timeline=timeline) In\u00a0[\u00a0]: Copied! <pre># -------------------------\n# Build and export one experiment\n# -------------------------\nintro = Text(\n    text=\"Bilateral RSVP - multiple variants. Press any key to begin.\", choices=\"ALL\"\n)\noutro = Text(text=\"Done. Thanks!\", choices=\"ALL\")\n</pre> # ------------------------- # Build and export one experiment # ------------------------- intro = Text(     text=\"Bilateral RSVP - multiple variants. Press any key to begin.\", choices=\"ALL\" ) outro = Text(text=\"Done. Thanks!\", choices=\"ALL\") In\u00a0[\u00a0]: Copied! <pre>exp = Experiment(\n    [\n        Block([intro]),\n        block_v1,\n        block_v2,\n        block_v3,\n        block_v4,\n        block_v5,\n        block_v6,\n        block_v7,\n        Block([outro]),\n    ]\n)\n</pre> exp = Experiment(     [         Block([intro]),         block_v1,         block_v2,         block_v3,         block_v4,         block_v5,         block_v6,         block_v7,         Block([outro]),     ] ) In\u00a0[\u00a0]: Copied! <pre>exp.to_html(\"bilateralrsvp.html\")\n</pre> exp.to_html(\"bilateralrsvp.html\")"},{"location":"Stimuli/bilateralrsvp/bilateralrsvp_simple/","title":"Bilateralrsvp simple","text":"In\u00a0[\u00a0]: Copied! <pre>from sweetbean.block import Block\nfrom sweetbean.experiment import Experiment\nfrom sweetbean.stimulus import BilateralRSVP\n</pre> from sweetbean.block import Block from sweetbean.experiment import Experiment from sweetbean.stimulus import BilateralRSVP In\u00a0[\u00a0]: Copied! <pre># -------------------------\n# VARIANT 7 \u2014 Fix distractor side to LEFT (override opposite-side default)\n# -------------------------\nbi_rsvp = BilateralRSVP(\n    left=[\"a\", \"b\", \"c\"],\n    right=[1, 2, 3],\n    target_side=\"left\",\n    target_index=2,\n    target_shape=\"circle\",  # per-trial circle/square from table\n    distractor_shape=\"square\",\n    stimulus_duration=200,\n    isi=40,\n    choices=\"NO_KEYS\",\n)\nblock = Block([bi_rsvp])\n</pre> # ------------------------- # VARIANT 7 \u2014 Fix distractor side to LEFT (override opposite-side default) # ------------------------- bi_rsvp = BilateralRSVP(     left=[\"a\", \"b\", \"c\"],     right=[1, 2, 3],     target_side=\"left\",     target_index=2,     target_shape=\"circle\",  # per-trial circle/square from table     distractor_shape=\"square\",     stimulus_duration=200,     isi=40,     choices=\"NO_KEYS\", ) block = Block([bi_rsvp]) In\u00a0[\u00a0]: Copied! <pre>exp = Experiment(\n    [\n        block,\n    ]\n)\n</pre> exp = Experiment(     [         block,     ] ) In\u00a0[\u00a0]: Copied! <pre>exp.to_html(\"bilateralrsvp_simple.html\")\n</pre> exp.to_html(\"bilateralrsvp_simple.html\")"},{"location":"Stimuli/blank/","title":"Blank","text":"<p>Show a blank screen for a set duration. Can optionally record keyboard responses during the blank interval.</p>"},{"location":"Stimuli/blank/#when-to-use","title":"When To Use","text":"<ul> <li>Inter-trial intervals (ITI) and timing gaps.</li> <li>Visual reset screens between stimuli.</li> <li>Passive delays with optional response capture.</li> </ul>"},{"location":"Stimuli/feedback/","title":"Feedback","text":"<p>Display a brief text message indicating whether the previous response was correct or incorrect, with configurable messages and colors.</p>"},{"location":"Stimuli/feedback/#when-to-use","title":"When To Use","text":"<ul> <li>Trial-by-trial correctness feedback.</li> <li>Simple score/progress indication using text and color.</li> <li>Immediate reinforcement after a keypress response.</li> </ul>"},{"location":"Stimuli/fixation/","title":"Fixation","text":"<p>Show a centered fixation cross (\u201c+\u201d) for a specified duration. Typically used before a trial to stabilize gaze/attention.</p>"},{"location":"Stimuli/fixation/#when-to-use","title":"When To Use","text":"<ul> <li>Pre-trial fixation to stabilize attention or gaze.</li> <li>Brief timing anchor before stimulus onset.</li> <li>Minimal visual content between task phases.</li> </ul>"},{"location":"Stimuli/flanker/","title":"Flanker","text":"<p>Show a central target arrow flanked by distractor arrows (e.g., <code>&lt;&lt;&gt;&lt;&lt;</code>, <code>&gt;&gt;&lt;&gt;&gt;</code>). Participants respond to the target\u2019s direction via keypress while flankers may be congruent or incongruent.</p>"},{"location":"Stimuli/flanker/#when-to-use","title":"When To Use","text":"<ul> <li>Arrow-based Flanker tasks (congruent vs. incongruent).</li> <li>Response interference paradigms with left/right keys.</li> <li>Quick attentional control or conflict measurements.</li> </ul>"},{"location":"Stimuli/flanker/#example","title":"Example","text":""},{"location":"Stimuli/flanker/flanker/","title":"Flanker","text":"In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import Blank, Feedback, Fixation, Flanker\nfrom sweetbean.variable import TimelineVariable\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import Blank, Feedback, Fixation, Flanker from sweetbean.variable import TimelineVariable In\u00a0[\u00a0]: Copied! <pre>timeline = [\n    {\"direction\": \"left\", \"distractor\": \"right\", \"correct_key\": \"f\"},\n    {\"direction\": \"right\", \"distractor\": \"right\", \"correct_key\": \"j\"},\n    {\"direction\": \"left\", \"distractor\": \"left\", \"correct_key\": \"f\"},\n    {\"direction\": \"right\", \"distractor\": \"left\", \"correct_key\": \"j\"},\n]\n</pre> timeline = [     {\"direction\": \"left\", \"distractor\": \"right\", \"correct_key\": \"f\"},     {\"direction\": \"right\", \"distractor\": \"right\", \"correct_key\": \"j\"},     {\"direction\": \"left\", \"distractor\": \"left\", \"correct_key\": \"f\"},     {\"direction\": \"right\", \"distractor\": \"left\", \"correct_key\": \"j\"}, ] In\u00a0[\u00a0]: Copied! <pre>direction = TimelineVariable(\"direction\")\ndistractor = TimelineVariable(\"distractor\")\ncorrect_key = TimelineVariable(\"correct_key\")\n</pre> direction = TimelineVariable(\"direction\") distractor = TimelineVariable(\"distractor\") correct_key = TimelineVariable(\"correct_key\") In\u00a0[\u00a0]: Copied! <pre>fixation = Fixation(1000)\nso_s = Blank(400)\nflanker = Flanker(2000, direction, distractor, [\"j\", \"f\"], correct_key)\nso_f = Blank(300)\nfeedback = Feedback(800, window=2)\n</pre> fixation = Fixation(1000) so_s = Blank(400) flanker = Flanker(2000, direction, distractor, [\"j\", \"f\"], correct_key) so_f = Blank(300) feedback = Feedback(800, window=2) In\u00a0[\u00a0]: Copied! <pre>block = Block([fixation, so_s, flanker, so_f, feedback], timeline)\n</pre> block = Block([fixation, so_s, flanker, so_f, feedback], timeline) In\u00a0[\u00a0]: Copied! <pre># Create an image of the stimuli sequence of the block\nblock.to_image(\n    \"flanker.png\",\n    data=[None, None, {\"correct\": True}, None, None],\n    zoom_factor=[3, 3, 1, 3, 3],\n    sequence=True,\n)\n</pre> # Create an image of the stimuli sequence of the block block.to_image(     \"flanker.png\",     data=[None, None, {\"correct\": True}, None, None],     zoom_factor=[3, 3, 1, 3, 3],     sequence=True, ) In\u00a0[\u00a0]: Copied! <pre># Create an HTML file of the experiment\nexperiment = Experiment([block])\nexperiment.to_html(\"flanker.html\")\n</pre> # Create an HTML file of the experiment experiment = Experiment([block]) experiment.to_html(\"flanker.html\")"},{"location":"Stimuli/foraging/","title":"Foraging","text":"<p>Display an on-screen arena containing multiple items with a subset designated as targets and the rest as * distractors*. Participants click targets to collect them. The trial typically ends when all targets are collected or when a time limit is reached. Layouts can be randomized or arranged (grid/circle), items avoid overlap, and tokens can be HTML, text, simple shapes, or images.</p>"},{"location":"Stimuli/foraging/#when-to-use","title":"When To Use","text":"<ul> <li>Multi-target visual search / foraging with click-to-collect responses.</li> <li>You need control over target/distractor counts, spacing, placement mode, and timing.</li> <li>You care about search efficiency metrics (e.g., targets per second), click streams, and completion rate.</li> </ul>"},{"location":"Stimuli/foraging/foraging/","title":"Foraging","text":"In\u00a0[\u00a0]: Copied! <pre>from sweetbean.block import Block\nfrom sweetbean.experiment import Experiment\nfrom sweetbean.stimulus import Text\nfrom sweetbean.stimulus.Foraging import Foraging\nfrom sweetbean.variable import TimelineVariable\n</pre> from sweetbean.block import Block from sweetbean.experiment import Experiment from sweetbean.stimulus import Text from sweetbean.stimulus.Foraging import Foraging from sweetbean.variable import TimelineVariable In\u00a0[\u00a0]: Copied! <pre># --- Timeline with per-trial item arrays (targets/distractors) ---\n# Each item can define ONE of: html | text | shape | src\n# Optional: color, rotationDeg, pos, size, fontSize, id, attrs\ntimeline = [\n    {\n        \"targets\": [\n            {\"text\": \"O\", \"color\": \"blue\"},\n            {\"text\": \"O\", \"color\": \"blue\"},\n        ],\n        \"distractors\": [\n            {\"text\": \"O\", \"color\": \"red\"},\n            {\"text\": \"Q\", \"color\": \"blue\"},\n            {\"text\": \"Q\", \"color\": \"red\"},\n        ],\n        # blue Os\n    },\n    {\n        \"targets\": [\n            {\"shape\": \"square\", \"color\": \"red\"},\n            {\"shape\": \"square\", \"color\": \"blue\"},\n        ],\n        \"distractors\": [\n            {\"shape\": \"triangle\", \"color\": \"red\"},\n            {\"shape\": \"circle\", \"color\": \"blue\"},\n            {\"shape\": \"triangle\", \"color\": \"blue\"},\n        ],\n        # squares\n    },\n    {\n        \"targets\": [\n            {\"html\": \"&lt;b&gt;?&lt;/b&gt;\", \"color\": \"red\"},\n            {\"html\": \"&lt;b&gt;!&lt;/b&gt;\", \"color\": \"blue\"},\n        ],\n        \"distractors\": [\n            {\"html\": \"?\", \"color\": \"red\"},\n            {\"html\": \"!\", \"color\": \"blue\"},\n            {\"html\": \"!\", \"color\": \"blue\"},\n        ],\n        # bold punctuation\n    },\n    {\n        \"targets\": [\n            {\"src\": \"https://dummyimage.com/256x256/ffffff/000000&amp;text=T1\"},\n            {\"src\": \"https://dummyimage.com/256x256/ffffff/000000&amp;text=T2\"},\n        ],\n        \"distractors\": [\n            {\"src\": \"https://dummyimage.com/256x256/ffffff/000000&amp;text=D1\"},\n            {\"src\": \"https://dummyimage.com/256x256/ffffff/000000&amp;text=D2\"},\n            {\"src\": \"https://dummyimage.com/256x256/ffffff/000000&amp;text=D3\"},\n        ],\n        # Ts\n    },\n]\n</pre> # --- Timeline with per-trial item arrays (targets/distractors) --- # Each item can define ONE of: html | text | shape | src # Optional: color, rotationDeg, pos, size, fontSize, id, attrs timeline = [     {         \"targets\": [             {\"text\": \"O\", \"color\": \"blue\"},             {\"text\": \"O\", \"color\": \"blue\"},         ],         \"distractors\": [             {\"text\": \"O\", \"color\": \"red\"},             {\"text\": \"Q\", \"color\": \"blue\"},             {\"text\": \"Q\", \"color\": \"red\"},         ],         # blue Os     },     {         \"targets\": [             {\"shape\": \"square\", \"color\": \"red\"},             {\"shape\": \"square\", \"color\": \"blue\"},         ],         \"distractors\": [             {\"shape\": \"triangle\", \"color\": \"red\"},             {\"shape\": \"circle\", \"color\": \"blue\"},             {\"shape\": \"triangle\", \"color\": \"blue\"},         ],         # squares     },     {         \"targets\": [             {\"html\": \"?\", \"color\": \"red\"},             {\"html\": \"!\", \"color\": \"blue\"},         ],         \"distractors\": [             {\"html\": \"?\", \"color\": \"red\"},             {\"html\": \"!\", \"color\": \"blue\"},             {\"html\": \"!\", \"color\": \"blue\"},         ],         # bold punctuation     },     {         \"targets\": [             {\"src\": \"https://dummyimage.com/256x256/ffffff/000000&amp;text=T1\"},             {\"src\": \"https://dummyimage.com/256x256/ffffff/000000&amp;text=T2\"},         ],         \"distractors\": [             {\"src\": \"https://dummyimage.com/256x256/ffffff/000000&amp;text=D1\"},             {\"src\": \"https://dummyimage.com/256x256/ffffff/000000&amp;text=D2\"},             {\"src\": \"https://dummyimage.com/256x256/ffffff/000000&amp;text=D3\"},         ],         # Ts     }, ] In\u00a0[\u00a0]: Copied! <pre># Instruction screen before each foraging trial (like your Text \u201cresponse window\u201d in RSVP)\ninstructions = Text(\n    text=\"Collect ALL targets as fast as you can. \"\n    \"Distractors will jiggle. Tap/click targets to collect.\",\n    duration=1500,  # auto-advance after 1.5s\n)\n</pre> # Instruction screen before each foraging trial (like your Text \u201cresponse window\u201d in RSVP) instructions = Text(     text=\"Collect ALL targets as fast as you can. \"     \"Distractors will jiggle. Tap/click targets to collect.\",     duration=1500,  # auto-advance after 1.5s ) In\u00a0[\u00a0]: Copied! <pre># Foraging stimulus:\n# - Defaults: random non-overlapping placement inside a centered arena,\n#   black bg, end_when_found=True, trial_duration=None.\nforaging = Foraging(\n    targets=TimelineVariable(\"targets\"),\n    distractors=TimelineVariable(\"distractors\"),\n)\n</pre> # Foraging stimulus: # - Defaults: random non-overlapping placement inside a centered arena, #   black bg, end_when_found=True, trial_duration=None. foraging = Foraging(     targets=TimelineVariable(\"targets\"),     distractors=TimelineVariable(\"distractors\"), ) In\u00a0[\u00a0]: Copied! <pre># Put them together\nstimulus_sequence = [instructions, foraging]\n</pre> # Put them together stimulus_sequence = [instructions, foraging] In\u00a0[\u00a0]: Copied! <pre>block = Block(stimulus_sequence, timeline=timeline)\nexp = Experiment([block])\n</pre> block = Block(stimulus_sequence, timeline=timeline) exp = Experiment([block]) In\u00a0[\u00a0]: Copied! <pre># Will use your HTML preamble (already loading @sweet-jspsych/plugin-foraging)\nexp.to_html(\"foraging.html\")\n</pre> # Will use your HTML preamble (already loading @sweet-jspsych/plugin-foraging) exp.to_html(\"foraging.html\")"},{"location":"Stimuli/gabor/","title":"Gabor","text":"<p>Render one or more true sinusoidal Gabor patches (grating \u00d7 Gaussian). Each patch exposes orientation, spatial frequency (sf_cpp / sf_cpd), phase, contrast, and Gaussian sigma/size; positions are in pixels (or degrees with <code>px_per_deg</code>). Multiple patches can be shown at once, and you can collect keyboard and/or mouse responses. Not for flat geometric shapes, annuli, bars/stripe fills, or noise masks \u2014 use Symbol (with stripe/noise textures and layering) for those or if you need more complex composites (e.g., a Gabor with an annular mask).</p>"},{"location":"Stimuli/gabor/#when-to-use","title":"When To Use","text":"<ul> <li>Orientation / contrast / phase judgments where sf/phase/sigma must be controlled precisely.</li> <li>2AFC with Gabor patches (e.g., which side has higher contrast?).</li> <li>Spatial-frequency tuning, phase sweeps, or multi-patch Gabor arrays (crowding/surround interactions).</li> </ul>"},{"location":"Stimuli/gabor/gabor/","title":"Gabor","text":"In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus.Gabor import Gabor\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus.Gabor import Gabor In\u00a0[\u00a0]: Copied! <pre>gabor_1 = Gabor(\n    canvas_width=900,\n    canvas_height=540,\n    bg_gray=0.5,\n    gamma=1.0,\n    patches=[\n        # left\n        dict(\n            x_px=-220,\n            y_px=0,\n            sigma_px=42,\n            sf_cpp=0.02,\n            orientation_deg=45,\n            phase_deg=0,\n            contrast=0.40,\n            label=\"left\",\n        ),\n        # right\n        dict(\n            x_px=220,\n            y_px=0,\n            sigma_px=42,\n            sf_cpp=0.02,\n            orientation_deg=135,\n            phase_deg=180,\n            contrast=0.55,\n            label=\"right\",\n        ),\n    ],\n    response_keys=[\"f\", \"j\"],\n    keymap_to_patch_index={\"f\": 0, \"j\": 1},\n    end_on_response=True,\n    duration=750,  # alias for trial_duration\n)\n</pre> gabor_1 = Gabor(     canvas_width=900,     canvas_height=540,     bg_gray=0.5,     gamma=1.0,     patches=[         # left         dict(             x_px=-220,             y_px=0,             sigma_px=42,             sf_cpp=0.02,             orientation_deg=45,             phase_deg=0,             contrast=0.40,             label=\"left\",         ),         # right         dict(             x_px=220,             y_px=0,             sigma_px=42,             sf_cpp=0.02,             orientation_deg=135,             phase_deg=180,             contrast=0.55,             label=\"right\",         ),     ],     response_keys=[\"f\", \"j\"],     keymap_to_patch_index={\"f\": 0, \"j\": 1},     end_on_response=True,     duration=750,  # alias for trial_duration ) In\u00a0[\u00a0]: Copied! <pre>gabor_2 = Gabor(\n    patches=[\n        dict(\n            x_px=0,\n            y_px=0,\n            sigma_px=20,\n            sf_cpp=0.02,\n            orientation_deg=0,\n            phase_deg=0,\n            contrast=0.55,\n        )\n    ]\n)\n</pre> gabor_2 = Gabor(     patches=[         dict(             x_px=0,             y_px=0,             sigma_px=20,             sf_cpp=0.02,             orientation_deg=0,             phase_deg=0,             contrast=0.55,         )     ] ) In\u00a0[\u00a0]: Copied! <pre>block = Block([gabor_1, gabor_2])\nexperiment = Experiment([block])\nexperiment.to_html(\"gabor.html\")\n</pre> block = Block([gabor_1, gabor_2]) experiment = Experiment([block]) experiment.to_html(\"gabor.html\")"},{"location":"Stimuli/generic/generic/","title":"Generic","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\n(only in pr-release)\nAn instructions screen welcoming the participant to the experiment,\nfollowed by a second page of instructions, and a final page of instructions.\n\"\"\"\n</pre> \"\"\" (only in pr-release) An instructions screen welcoming the participant to the experiment, followed by a second page of instructions, and a final page of instructions. \"\"\" In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import Generic\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import Generic In\u00a0[\u00a0]: Copied! <pre>instructions = Generic(\n    type=\"jsPsychInstructions\",\n    pages=[\n        \"Welcome to the experiment\",\n        \"This is the second page of instructions\",\n        \"This is the final page\",\n    ],\n    show_clickable_nav=True,\n)\n</pre> instructions = Generic(     type=\"jsPsychInstructions\",     pages=[         \"Welcome to the experiment\",         \"This is the second page of instructions\",         \"This is the final page\",     ],     show_clickable_nav=True, ) In\u00a0[\u00a0]: Copied! <pre>block = Block([instructions])\n</pre> block = Block([instructions]) In\u00a0[\u00a0]: Copied! <pre>experiment = Experiment([block])\nexperiment.to_html(\"instructions.html\")\n</pre> experiment = Experiment([block]) experiment.to_html(\"instructions.html\")"},{"location":"Stimuli/htmlChoice/","title":"HtmlChoice","text":"<p>Render multiple on-screen HTML elements as clickable options. A mouse or touch click selects one item; the stimulus records the selected index (<code>choice</code>) and, if provided, an associated <code>value</code>. An optional post-response delay lets short animations or visual confirmation play before the trial ends.</p>"},{"location":"Stimuli/htmlChoice/#when-to-use","title":"When To Use","text":"<ul> <li>On-screen alternatives presented as buttons, icons, or custom HTML.</li> <li>Mouse/touch tasks where the participant chooses one of several items.</li> <li>Post-stimulus decision screens following another presentation phase.</li> </ul>"},{"location":"Stimuli/htmlChoice/htmlChoice/","title":"htmlChoice","text":"In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import HtmlChoice\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import HtmlChoice In\u00a0[\u00a0]: Copied! <pre>choice = HtmlChoice(\n    duration=2000,\n    html_array=[\"&lt;button&gt;Yes&lt;/button&gt;\", \"&lt;button&gt;No&lt;/button&gt;\"],\n    values=[1, 0],\n    time_after_response=300,\n)\n</pre> choice = HtmlChoice(     duration=2000,     html_array=[\"Yes\", \"No\"],     values=[1, 0],     time_after_response=300, ) In\u00a0[\u00a0]: Copied! <pre>block = Block([choice])\n</pre> block = Block([choice]) In\u00a0[\u00a0]: Copied! <pre># Create HTML file of the experiment\nexperiment = Experiment([block])\nexperiment.to_html(\"htmlChoice.html\")\n</pre> # Create HTML file of the experiment experiment = Experiment([block]) experiment.to_html(\"htmlChoice.html\")"},{"location":"Stimuli/htmlkeyboardresponse/","title":"HtmlKeyboardResponse","text":"<p>Display arbitrary HTML content and collect keyboard responses from a specified key set. Records the pressed key and reaction time (RT). An optional <code>correct_key</code> lets you mark correctness for downstream feedback.</p>"},{"location":"Stimuli/htmlkeyboardresponse/#when-to-use","title":"When To Use","text":"<ul> <li>You want to show HTML (text, simple markup, etc.) and capture a keypress.</li> <li>Response prompts that require a specific key set (e.g., [\"f\",\"j\"]).</li> <li>As the response phase following another stimulus.</li> </ul>"},{"location":"Stimuli/htmlkeyboardresponse/htmlkeyboardresponse/","title":"Htmlkeyboardresponse","text":"In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import HtmlKeyboardResponse\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import HtmlKeyboardResponse In\u00a0[\u00a0]: Copied! <pre>stim = HtmlKeyboardResponse(\n    duration=2000,\n    stimulus=\"&lt;p style='font-size:48px; color:pink'&gt;Hello, World!&lt;/p&gt;\",\n)\n</pre> stim = HtmlKeyboardResponse(     duration=2000,     stimulus=\"<p>Hello, World!</p>\", ) In\u00a0[\u00a0]: Copied! <pre>block = Block([stim])\nexperiment = Experiment([block])\nexperiment.to_html(\"htmlkeyboardresponse.html\")\n</pre> block = Block([stim]) experiment = Experiment([block]) experiment.to_html(\"htmlkeyboardresponse.html\")"},{"location":"Stimuli/image/","title":"Image","text":"<p>Display a static image file on screen. Optionally collect a keyboard response while the image is visible (e.g., specific keys like <code>[\"f\",\"j\"]</code>) and compute reaction time.</p>"},{"location":"Stimuli/image/#when-to-use","title":"When To Use","text":"<ul> <li>Trials that present a pre-made picture/figure/photo as the main stimulus.</li> <li>Your data has a column with image file paths or identifiers to show per trial.</li> <li>You need a simple keypress response during or after image presentation.</li> </ul>"},{"location":"Stimuli/image/#example-banana","title":"Example: Banana","text":"<p>A banana is shown until the participant presses space.</p> <p></p>"},{"location":"Stimuli/image/image/","title":"Image","text":"In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import Image\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import Image In\u00a0[\u00a0]: Copied! <pre>stim_1 = Image(\n    stimulus=\"https://media.istockphoto.com/id/120492078/photo/\"\n    \"banana.jpg?s=1024x1024&amp;w=is&amp;k=20&amp;c=M9KLVNgqLft_btWgSu0iZAmdv2asI11Qel-6fsQK140=\",\n    choices=[\" \"],\n)\n</pre> stim_1 = Image(     stimulus=\"https://media.istockphoto.com/id/120492078/photo/\"     \"banana.jpg?s=1024x1024&amp;w=is&amp;k=20&amp;c=M9KLVNgqLft_btWgSu0iZAmdv2asI11Qel-6fsQK140=\",     choices=[\" \"], ) In\u00a0[\u00a0]: Copied! <pre>block = Block([stim_1])\n</pre> block = Block([stim_1]) In\u00a0[\u00a0]: Copied! <pre># Create an image of the stimulus\nblock.to_image(\"./\", data=None, sequence=False, timeline_idx=\"random\", zoom_factor=1)\n</pre> # Create an image of the stimulus block.to_image(\"./\", data=None, sequence=False, timeline_idx=\"random\", zoom_factor=1) In\u00a0[\u00a0]: Copied! <pre># Create an HTML file of the experiment\nexperiment = Experiment([block])\nexperiment.to_html(\"image.html\")\n</pre> # Create an HTML file of the experiment experiment = Experiment([block]) experiment.to_html(\"image.html\")"},{"location":"Stimuli/image/image_language/","title":"Image language","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nThis script demonstrates how to use the `run_on_language` method to run an experiment\nwith image stimuli.\n\"\"\"\n</pre> \"\"\" This script demonstrates how to use the `run_on_language` method to run an experiment with image stimuli. \"\"\" In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import Image\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import Image In\u00a0[\u00a0]: Copied! <pre>stim_1 = Image(\n    stimulus=\"https://media.istockphoto.com/id/120492078/photo/\"\n    \"banana.jpg?s=1024x1024&amp;w=is&amp;k=20&amp;c=M9KLVNgqLft_btWgSu0iZAmdv2asI11Qel-6fsQK140=\",\n    choices=[\" \"],\n)\n</pre> stim_1 = Image(     stimulus=\"https://media.istockphoto.com/id/120492078/photo/\"     \"banana.jpg?s=1024x1024&amp;w=is&amp;k=20&amp;c=M9KLVNgqLft_btWgSu0iZAmdv2asI11Qel-6fsQK140=\",     choices=[\" \"], ) In\u00a0[\u00a0]: Copied! <pre>block = Block([stim_1])\nexperiment = Experiment([block])\n</pre> block = Block([stim_1]) experiment = Experiment([block]) <p>To make this work, there is a file called image_prompts.json in the same directory as this script with the following content: { \"https://media.istockphoto.com/id/120492078/photo/banana.jpg?s=1024x1024&amp;w=is&amp;k=20&amp;c=M9KLVNgqLft_btWgSu0iZAmdv2asI11Qel-6fsQK140=\": \"You see a picture of a banana.\"   # noqa: E501 }</p> In\u00a0[\u00a0]: Copied! <pre>experiment.run_on_language()\n</pre> experiment.run_on_language()"},{"location":"Stimuli/likertsurvey/","title":"LikertSurvey","text":"<p>Present one or more Likert items with ordered labels (e.g., \u201cStrongly disagree\u201d \u2192 \u201cStrongly agree\u201d). Participants pick a position on the scale for each question; responses are recorded per item. Supports constructing surveys from a shared scale.</p>"},{"location":"Stimuli/likertsurvey/#when-to-use","title":"When To Use","text":"<ul> <li>Agreement/attitude ratings on an ordered scale</li> <li>Standard psychometric or UX scales</li> <li>Consistent rating anchors across many items</li> </ul>"},{"location":"Stimuli/likertsurvey/likertsurvey/","title":"Likertsurvey","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nA welcoming text the participant is shown until the participant presses the spacebar. The text says,\n'Welcome! We show a survey. Press SPACE to continue'. This is followed by a survey with two\nquestions that the participant is supposed to answer on a likert scale. The first question is\n'How are you feeling?' and the participant is supposed to rate their feeling on a scale from\n-2 to 2 with 5 levels. The second question is 'Do you like this tool?' on a scale from 1 to 3.\nThen, the participant is supposed to rate five animals on their cuteness from 1 to 5.\nThe animals are a bunny, a shark, a spider, a cat, and a dog.\n\"\"\"\n</pre> \"\"\" A welcoming text the participant is shown until the participant presses the spacebar. The text says, 'Welcome! We show a survey. Press SPACE to continue'. This is followed by a survey with two questions that the participant is supposed to answer on a likert scale. The first question is 'How are you feeling?' and the participant is supposed to rate their feeling on a scale from -2 to 2 with 5 levels. The second question is 'Do you like this tool?' on a scale from 1 to 3. Then, the participant is supposed to rate five animals on their cuteness from 1 to 5. The animals are a bunny, a shark, a spider, a cat, and a dog. \"\"\" In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import LikertSurvey, Text\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import LikertSurvey, Text <p>EVENT SEQUENCE</p> In\u00a0[\u00a0]: Copied! <pre>stim_1 = Text(\n    text=\"Welcome! We show a survey. Press SPACE to continue\",\n    choices=[\" \"],\n)\n</pre> stim_1 = Text(     text=\"Welcome! We show a survey. Press SPACE to continue\",     choices=[\" \"], ) In\u00a0[\u00a0]: Copied! <pre>stim_2 = LikertSurvey(\n    questions=[\n        {\"prompt\": \"How are you feeling?\", \"labels\": [-2, -1, 0, 1, 2]},\n        {\"prompt\": \"Do you like this tool?\", \"labels\": [0, 1, 3]},\n    ]\n)\n</pre> stim_2 = LikertSurvey(     questions=[         {\"prompt\": \"How are you feeling?\", \"labels\": [-2, -1, 0, 1, 2]},         {\"prompt\": \"Do you like this tool?\", \"labels\": [0, 1, 3]},     ] ) In\u00a0[\u00a0]: Copied! <pre>stim_3 = Text(\n    text=\"Rate the following animals on a scale from 1-5 on their cuteness.\",\n    choices=[\" \"],\n)\n</pre> stim_3 = Text(     text=\"Rate the following animals on a scale from 1-5 on their cuteness.\",     choices=[\" \"], ) In\u00a0[\u00a0]: Copied! <pre>stim_4 = LikertSurvey.from_scale(\n    prompts=[\"bunny\", \"shark\", \"spider\", \"cat\", \"dog\"], scale=[1, 2, 3, 4, 5]\n)\n</pre> stim_4 = LikertSurvey.from_scale(     prompts=[\"bunny\", \"shark\", \"spider\", \"cat\", \"dog\"], scale=[1, 2, 3, 4, 5] ) In\u00a0[\u00a0]: Copied! <pre>event_sequence = [stim_1, stim_2, stim_3, stim_4]\n</pre> event_sequence = [stim_1, stim_2, stim_3, stim_4] <p>BLOCK DESIGN</p> In\u00a0[\u00a0]: Copied! <pre>block = Block(event_sequence)\nexperiment = Experiment([block])\nexperiment.to_html(\"likertsurvey.html\")\n</pre> block = Block(event_sequence) experiment = Experiment([block]) experiment.to_html(\"likertsurvey.html\")"},{"location":"Stimuli/multichoicesurvey/","title":"MultiChoiceSurvey","text":"<p>Present one or more multiple-choice questions, each with a fixed set of options. Participants select one option per question; selections are recorded per question. Works well for categorical choices and simple questionnaires.</p>"},{"location":"Stimuli/multichoicesurvey/#when-to-use","title":"When To Use","text":"<ul> <li>Forced-choice or single-answer items</li> <li>Simple questionnaires and demographics</li> <li>Quick category selections per question</li> </ul>"},{"location":"Stimuli/multichoicesurvey/multiplechoice/","title":"Multiplechoice","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nAfter the participant is greeted with 'Welcome! We show a survey. Press SPACE to continue' until\nthey press the spacebar, they are asked two multiple-choice questions. One is about how they are,\nwhich they can rate as bad, good, or fine. The other is about their handedness.\n\"\"\"\n</pre> \"\"\" After the participant is greeted with 'Welcome! We show a survey. Press SPACE to continue' until they press the spacebar, they are asked two multiple-choice questions. One is about how they are, which they can rate as bad, good, or fine. The other is about their handedness. \"\"\" In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import MultiChoiceSurvey, Text\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import MultiChoiceSurvey, Text <p>EVENT SEQUENCE</p> In\u00a0[\u00a0]: Copied! <pre>stim_1 = Text(\n    text=\"Welcome! We show a survey. Press SPACE to continue\",\n    choices=[\" \"],\n)\n</pre> stim_1 = Text(     text=\"Welcome! We show a survey. Press SPACE to continue\",     choices=[\" \"], ) In\u00a0[\u00a0]: Copied! <pre>stim_2 = MultiChoiceSurvey(\n    questions=[\n        {\"prompt\": \"How are you?\", \"options\": [\"bad\", \"good\", \"fine\"]},\n        {\n            \"prompt\": \"What is your handedness?\",\n            \"options\": [\"left\", \"right\", \"other\", \"prefer not to say\"],\n        },\n    ]\n)\n</pre> stim_2 = MultiChoiceSurvey(     questions=[         {\"prompt\": \"How are you?\", \"options\": [\"bad\", \"good\", \"fine\"]},         {             \"prompt\": \"What is your handedness?\",             \"options\": [\"left\", \"right\", \"other\", \"prefer not to say\"],         },     ] ) In\u00a0[\u00a0]: Copied! <pre>event_sequence = [stim_1, stim_2]\n</pre> event_sequence = [stim_1, stim_2] <p>BLOCK DESIGN</p> In\u00a0[\u00a0]: Copied! <pre>block = Block(event_sequence)\nexperiment = Experiment([block])\nexperiment.to_html(\"multichoice.html\")\n</pre> block = Block(event_sequence) experiment = Experiment([block]) experiment.to_html(\"multichoice.html\")"},{"location":"Stimuli/randomdotpatterns/","title":"RandomDotPatterns","text":"<p>Present static arrays of oriented objects where a proportion share a coherent orientation and the remainder are random; no coherent motion is present. Supports multiple apertures to show two arrays simultaneously for comparison or discrimination tasks.</p>"},{"location":"Stimuli/randomdotpatterns/#when-to-use","title":"When To Use","text":"<ul> <li>Orientation coherence tasks without motion.</li> <li>Two-array (dual aperture) comparisons.</li> <li>Varying orientation coherence to control difficulty.</li> </ul>"},{"location":"Stimuli/randomdotpatterns/#example","title":"Example","text":"<p>Two random dot patterns are shown. The participant is asked to press 'y' the number of dots in the right pattern is not equal to the number of dots in the left pattern and 'n' if they are the same.</p> <p></p>"},{"location":"Stimuli/randomdotpatterns/#notes","title":"Notes","text":"<p>Alias: RDP</p>"},{"location":"Stimuli/randomdotpatterns/randomdotpatterns/","title":"Randomdotpatterns","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\" Weber Fechner\n\nAn example for Weber Fechner.  Here, we have a simple stimulus timeline:\n[fixation, blank, rdp, blank, feedback]\n\n\"\"\"\n</pre> \"\"\" Weber Fechner  An example for Weber Fechner.  Here, we have a simple stimulus timeline: [fixation, blank, rdp, blank, feedback]  \"\"\" In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import Blank, Feedback, Fixation, RandomDotPatterns\nfrom sweetbean.variable import TimelineVariable\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import Blank, Feedback, Fixation, RandomDotPatterns from sweetbean.variable import TimelineVariable In\u00a0[\u00a0]: Copied! <pre>timeline = [\n    {\"S1\": 40, \"S2\": 70, \"correct_key\": \"y\"},\n    {\"S1\": 70, \"S2\": 70, \"correct_key\": \"n\"},\n    {\"S1\": 70, \"S2\": 40, \"correct_key\": \"y\"},\n    {\"S1\": 70, \"S2\": 70, \"correct_key\": \"n\"},\n    {\"S1\": 40, \"S2\": 70, \"correct_key\": \"y\"},\n    {\"S1\": 70, \"S2\": 40, \"correct_key\": \"y\"},\n    {\"S1\": 40, \"S2\": 40, \"correct_key\": \"n\"},\n    {\"S1\": 40, \"S2\": 40, \"correct_key\": \"n\"},\n    {\"S1\": 40, \"S2\": 40, \"correct_key\": \"n\"},\n    {\"S1\": 70, \"S2\": 40, \"correct_key\": \"y\"},\n]\n</pre> timeline = [     {\"S1\": 40, \"S2\": 70, \"correct_key\": \"y\"},     {\"S1\": 70, \"S2\": 70, \"correct_key\": \"n\"},     {\"S1\": 70, \"S2\": 40, \"correct_key\": \"y\"},     {\"S1\": 70, \"S2\": 70, \"correct_key\": \"n\"},     {\"S1\": 40, \"S2\": 70, \"correct_key\": \"y\"},     {\"S1\": 70, \"S2\": 40, \"correct_key\": \"y\"},     {\"S1\": 40, \"S2\": 40, \"correct_key\": \"n\"},     {\"S1\": 40, \"S2\": 40, \"correct_key\": \"n\"},     {\"S1\": 40, \"S2\": 40, \"correct_key\": \"n\"},     {\"S1\": 70, \"S2\": 40, \"correct_key\": \"y\"}, ] In\u00a0[\u00a0]: Copied! <pre>fixation = Fixation(800)\n</pre> fixation = Fixation(800) In\u00a0[\u00a0]: Copied! <pre>blank_1 = Blank(400)\nblank_2 = Blank(1000)\n</pre> blank_1 = Blank(400) blank_2 = Blank(1000) In\u00a0[\u00a0]: Copied! <pre>s1 = TimelineVariable(\"S1\")\ns2 = TimelineVariable(\"S2\")\ncorrect_key = TimelineVariable(\"correct_key\")\n</pre> s1 = TimelineVariable(\"S1\") s2 = TimelineVariable(\"S2\") correct_key = TimelineVariable(\"correct_key\") <p>We can use these variables in the stimuli declaration:</p> In\u00a0[\u00a0]: Copied! <pre>rdp = RandomDotPatterns(\n    duration=1000,\n    number_of_oobs=[s1, s2],\n    number_of_apertures=2,\n    choices=[\"y\", \"n\"],\n    correct_key=correct_key,\n)\n</pre> rdp = RandomDotPatterns(     duration=1000,     number_of_oobs=[s1, s2],     number_of_apertures=2,     choices=[\"y\", \"n\"],     correct_key=correct_key, ) In\u00a0[\u00a0]: Copied! <pre>feedback = Feedback(500, window=2)\n</pre> feedback = Feedback(500, window=2) In\u00a0[\u00a0]: Copied! <pre>event_sequence = [fixation, blank_1, rdp, blank_2, feedback]\n</pre> event_sequence = [fixation, blank_1, rdp, blank_2, feedback] In\u00a0[\u00a0]: Copied! <pre>block = Block(event_sequence, timeline)\n</pre> block = Block(event_sequence, timeline) In\u00a0[\u00a0]: Copied! <pre># Create an image of the stimuli sequence of the block\nblock.to_image(\n    \"weber_fechner.png\",\n    data=[None, None, {\"correct\": True}, None, None],\n    zoom_factor=[3, 3, 1, 3, 3],\n    sequence=True,\n)\n</pre> # Create an image of the stimuli sequence of the block block.to_image(     \"weber_fechner.png\",     data=[None, None, {\"correct\": True}, None, None],     zoom_factor=[3, 3, 1, 3, 3],     sequence=True, ) In\u00a0[\u00a0]: Copied! <pre># Create an HTML file of the experiment\nexperiment = Experiment([block])\nexperiment.to_html(\"weber_fechner.html\")\n</pre> # Create an HTML file of the experiment experiment = Experiment([block]) experiment.to_html(\"weber_fechner.html\")"},{"location":"Stimuli/randomobjectkinematogram/","title":"RandomObjectKinematogram","text":"<p>Display oriented objects where a subset moves in a coherent direction and/or shares a coherent orientation, while the remaining objects move and orient randomly. You can control number of objects and apertures, coherence of motion and orientation, speed, positions, and colors to modulate task difficulty.</p>"},{"location":"Stimuli/randomobjectkinematogram/#when-to-use","title":"When To Use","text":"<ul> <li>Global motion / orientation coherence detection tasks.</li> <li>Manipulating coherence level to adjust difficulty.</li> <li>Single- or multi-aperture kinematogram displays.</li> </ul>"},{"location":"Stimuli/randomobjectkinematogram/#example","title":"Example","text":"<p>Triangles that are rotated in a certain direction and move in a certain direction.  A percentage of the triangles are rotated randomly and move randomly.  The more triangles are rotated and moved randomly,  the harder it is to detect the direction of the majority of the triangles.</p> <p></p>"},{"location":"Stimuli/randomobjectkinematogram/#notes","title":"Notes","text":"<p>Alias: ROK</p>"},{"location":"Stimuli/randomobjectkinematogram/randomobjectkinematogram/","title":"Randomobjectkinematogram","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nThe rok presents orientated objects (triangles).\n50% of them move in an angle of 100deg and 50% randomly.\n90% of them are orientated to the right and 10% randomly.\n\"\"\"\n</pre> \"\"\" The rok presents orientated objects (triangles). 50% of them move in an angle of 100deg and 50% randomly. 90% of them are orientated to the right and 10% randomly. \"\"\" In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import RandomObjectKinematogram\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import RandomObjectKinematogram <p>EVENT SEQUENCE</p> In\u00a0[\u00a0]: Copied! <pre>rok = RandomObjectKinematogram(\n    duration=3000,\n    number_of_oobs=500,\n    coherent_movement_direction=100,\n    coherent_orientation=0,\n    coherence_movement=50,\n    coherence_orientation=90,\n    movement_speed=10,\n)\n</pre> rok = RandomObjectKinematogram(     duration=3000,     number_of_oobs=500,     coherent_movement_direction=100,     coherent_orientation=0,     coherence_movement=50,     coherence_orientation=90,     movement_speed=10, ) In\u00a0[\u00a0]: Copied! <pre>event_sequence = [rok]\n</pre> event_sequence = [rok] <p>BLOCK DESIGN</p> In\u00a0[\u00a0]: Copied! <pre>block = Block(event_sequence)\n</pre> block = Block(event_sequence) In\u00a0[\u00a0]: Copied! <pre># Create an image of the stimuli\nblock.to_image(\"./\", data=None, sequence=False, timeline_idx=\"random\", zoom_factor=1)\n</pre> # Create an image of the stimuli block.to_image(\"./\", data=None, sequence=False, timeline_idx=\"random\", zoom_factor=1) In\u00a0[\u00a0]: Copied! <pre># Create an HTML file of the experiment\nexperiment = Experiment([block])\nexperiment.to_html(\"randomobjectkinematogram.html\")\n</pre> # Create an HTML file of the experiment experiment = Experiment([block]) experiment.to_html(\"randomobjectkinematogram.html\")"},{"location":"Stimuli/rsvp/","title":"RSVP","text":"<p>Present one or more rapid serial visual presentation streams where items appear in quick succession. Participants detect or identify target items among distractors, optionally responding via keyboard. You can control stream layout (row/column), order, item timing (duration/ISI), masks, and trial duration. Only works with simple visual items (text, single symbols); for more complex or layered stimuli, consider the Symbol or Html plugins.</p>"},{"location":"Stimuli/rsvp/#when-to-use","title":"When To Use","text":"<ul> <li>Attentional blink or target detection in fast streams.</li> <li>Dual-stream (left/right) RSVP with synchronized or offset sequences.</li> <li>Rapid sequences where precise item timing and ordering matter.</li> </ul>"},{"location":"Stimuli/rsvp/rsvp/","title":"Rsvp","text":"In\u00a0[\u00a0]: Copied! <pre>from sweetbean.block import Block\nfrom sweetbean.experiment import Experiment\nfrom sweetbean.stimulus import RSVP, Feedback, Text\nfrom sweetbean.variable import TimelineVariable\n</pre> from sweetbean.block import Block from sweetbean.experiment import Experiment from sweetbean.stimulus import RSVP, Feedback, Text from sweetbean.variable import TimelineVariable In\u00a0[\u00a0]: Copied! <pre># Trial table (streams are pure content)\ntimeline = [\n    {\n        \"left_stream\": [\"O\", \"O\", \"Q\", \"Q\", \"O\", \"Q\"],\n        \"right_stream\": [\"1\", \"1\", \"2\", \"3\", \"4\", \"5\"],\n        \"left_target_index\": 4,  # zero-based\n        \"left_target_shape\": \"circle\",\n        \"right_target_index\": 4,\n        \"right_target_shape\": \"square\",\n        \"correct_key\": \"o\",\n    },\n    {\n        \"left_stream\": [\"O\", \"Q\", \"Q\", \"O\", \"Q\", \"O\"],\n        \"right_stream\": [\"1\", \"1\", \"2\", \"3\", \"4\", \"5\"],\n        \"left_target_index\": 2,\n        \"left_target_shape\": \"circle\",\n        \"right_target_index\": 2,\n        \"right_target_shape\": \"square\",\n        \"correct_key\": \"q\",\n    },\n    {\n        \"left_stream\": [\"O\", \"O\", \"Q\", \"O\", \"O\", \"O\"],\n        \"right_stream\": [\"1\", \"1\", \"2\", \"3\", \"4\", \"5\"],\n        \"left_target_index\": 2,\n        \"left_target_shape\": \"square\",\n        \"right_target_index\": 2,\n        \"right_target_shape\": \"circle\",\n        \"correct_key\": \"2\",\n    },\n]\n</pre> # Trial table (streams are pure content) timeline = [     {         \"left_stream\": [\"O\", \"O\", \"Q\", \"Q\", \"O\", \"Q\"],         \"right_stream\": [\"1\", \"1\", \"2\", \"3\", \"4\", \"5\"],         \"left_target_index\": 4,  # zero-based         \"left_target_shape\": \"circle\",         \"right_target_index\": 4,         \"right_target_shape\": \"square\",         \"correct_key\": \"o\",     },     {         \"left_stream\": [\"O\", \"Q\", \"Q\", \"O\", \"Q\", \"O\"],         \"right_stream\": [\"1\", \"1\", \"2\", \"3\", \"4\", \"5\"],         \"left_target_index\": 2,         \"left_target_shape\": \"circle\",         \"right_target_index\": 2,         \"right_target_shape\": \"square\",         \"correct_key\": \"q\",     },     {         \"left_stream\": [\"O\", \"O\", \"Q\", \"O\", \"O\", \"O\"],         \"right_stream\": [\"1\", \"1\", \"2\", \"3\", \"4\", \"5\"],         \"left_target_index\": 2,         \"left_target_shape\": \"square\",         \"right_target_index\": 2,         \"right_target_shape\": \"circle\",         \"correct_key\": \"2\",     }, ] In\u00a0[\u00a0]: Copied! <pre>rsvp = RSVP(\n    # Streams are pure content (no \"circle\"/\"square\"/color tokens here)\n    streams=[\n        {\"id\": \"left\", \"items\": TimelineVariable(\"left_stream\")},\n        {\"id\": \"right\", \"items\": TimelineVariable(\"right_stream\")},\n    ],\n    stimulus_duration=200,\n    isi=40,\n    # Disable responses during the RSVP; we ask afterward on a blank screen\n    choices=\"NO_KEYS\",\n    # Convenience arrays \u2014 plugin broadcasts &amp; renders per item\n    target_index=[\n        TimelineVariable(\"left_target_index\"),\n        TimelineVariable(\"right_target_index\"),\n    ],\n    target_side=[\"left\", \"right\"],\n    target_shape=[\n        TimelineVariable(\"left_target_shape\"),\n        TimelineVariable(\"right_target_shape\"),\n    ],\n    # (optional) default outline thickness for targets\n    target_stroke=\"3px\",\n    # No explicit `targets=[...]` needed now; the three arrays above define them\n)\n</pre> rsvp = RSVP(     # Streams are pure content (no \"circle\"/\"square\"/color tokens here)     streams=[         {\"id\": \"left\", \"items\": TimelineVariable(\"left_stream\")},         {\"id\": \"right\", \"items\": TimelineVariable(\"right_stream\")},     ],     stimulus_duration=200,     isi=40,     # Disable responses during the RSVP; we ask afterward on a blank screen     choices=\"NO_KEYS\",     # Convenience arrays \u2014 plugin broadcasts &amp; renders per item     target_index=[         TimelineVariable(\"left_target_index\"),         TimelineVariable(\"right_target_index\"),     ],     target_side=[\"left\", \"right\"],     target_shape=[         TimelineVariable(\"left_target_shape\"),         TimelineVariable(\"right_target_shape\"),     ],     # (optional) default outline thickness for targets     target_stroke=\"3px\",     # No explicit `targets=[...]` needed now; the three arrays above define them ) In\u00a0[\u00a0]: Copied! <pre>response_window = Text(\n    text=\"What was the target symbol?\",\n    choices=list(\"abcdefghijklmnopqrstuvwxyz0123456789\"),\n    correct_key=TimelineVariable(\"correct_key\"),\n)\n</pre> response_window = Text(     text=\"What was the target symbol?\",     choices=list(\"abcdefghijklmnopqrstuvwxyz0123456789\"),     correct_key=TimelineVariable(\"correct_key\"), ) In\u00a0[\u00a0]: Copied! <pre>feedback = Feedback(duration=300)\n</pre> feedback = Feedback(duration=300) In\u00a0[\u00a0]: Copied! <pre>block = Block([rsvp, response_window, feedback], timeline=timeline)\nexp = Experiment([block])\nexp.to_html(\"rsvp.html\")\n</pre> block = Block([rsvp, response_window, feedback], timeline=timeline) exp = Experiment([block]) exp.to_html(\"rsvp.html\")"},{"location":"Stimuli/stroop/","title":"Stroop","text":"<p>Show a text string in a chosen color. Optionally collect keyboard responses while the text is on screen.</p>"},{"location":"Stimuli/stroop/#when-to-use","title":"When To Use","text":"<ul> <li>Simple Stroop-style text displays (color/word).</li> </ul>"},{"location":"Stimuli/stroop/#example","title":"Example","text":"<p>A colored word is displayed. In most variants, the participant is asked to name the color of the word. Here, we show a version where the participant has to decide weather color and word fit (are congruent) or not (are incongruent).</p> <p></p>"},{"location":"Stimuli/stroop/stroop/","title":"Stroop","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nA fixation cross is followed by a blank screen, followed by a Stroop stimulus, followed by another\nblank screen. The fixation cross is shown for 1000ms. The soa and iti durations are indicated by\nthe experimental design. The color of the Stroop task and its words are also indicated by the\nexperimental design. The correct response  to a red word is f, and the correct response to a\ngreen word is j.\n\"\"\"\n</pre> \"\"\" A fixation cross is followed by a blank screen, followed by a Stroop stimulus, followed by another blank screen. The fixation cross is shown for 1000ms. The soa and iti durations are indicated by the experimental design. The color of the Stroop task and its words are also indicated by the experimental design. The correct response  to a red word is f, and the correct response to a green word is j. \"\"\" In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import Text\nfrom sweetbean.variable import DataVariable, FunctionVariable, TimelineVariable\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import Text from sweetbean.variable import DataVariable, FunctionVariable, TimelineVariable In\u00a0[\u00a0]: Copied! <pre>timeline = [\n    {\"color\": \"red\", \"word\": \"RED\", \"so_s\": 200, \"so_f\": 1000},\n    {\"color\": \"green\", \"word\": \"GREEN\", \"so_s\": 1000, \"so_f\": 100},\n    {\"color\": \"green\", \"word\": \"RED\", \"so_s\": 100, \"so_f\": 2000},\n    {\"color\": \"red\", \"word\": \"GREEN\", \"so_s\": 1000, \"so_f\": 1000},\n]\n</pre> timeline = [     {\"color\": \"red\", \"word\": \"RED\", \"so_s\": 200, \"so_f\": 1000},     {\"color\": \"green\", \"word\": \"GREEN\", \"so_s\": 1000, \"so_f\": 100},     {\"color\": \"green\", \"word\": \"RED\", \"so_s\": 100, \"so_f\": 2000},     {\"color\": \"red\", \"word\": \"GREEN\", \"so_s\": 1000, \"so_f\": 1000}, ] <p>EVENT SEQUENCE</p> In\u00a0[\u00a0]: Copied! <pre>color = TimelineVariable(\"color\")\nword = TimelineVariable(\"word\")\nso_s_duration = TimelineVariable(\"so_s\")\nso_f_duration = TimelineVariable(\"so_f\")\n</pre> color = TimelineVariable(\"color\") word = TimelineVariable(\"word\") so_s_duration = TimelineVariable(\"so_s\") so_f_duration = TimelineVariable(\"so_f\") In\u00a0[\u00a0]: Copied! <pre>def correct_key_fct(color, word):\n    if color.lower() == word.lower():\n        return \"f\"\n    return \"j\"\n</pre> def correct_key_fct(color, word):     if color.lower() == word.lower():         return \"f\"     return \"j\" In\u00a0[\u00a0]: Copied! <pre>correct_key = FunctionVariable(\"correct_key\", correct_key_fct, [color, word])\n</pre> correct_key = FunctionVariable(\"correct_key\", correct_key_fct, [color, word]) In\u00a0[\u00a0]: Copied! <pre>last_correct = DataVariable(\"correct\", 1)\n</pre> last_correct = DataVariable(\"correct\", 1) In\u00a0[\u00a0]: Copied! <pre>feedback_text = FunctionVariable(\n    \"feedback_text\",\n    lambda lc: \"Correct!\" if lc else \"False!\",\n    [last_correct],\n)\n</pre> feedback_text = FunctionVariable(     \"feedback_text\",     lambda lc: \"Correct!\" if lc else \"False!\",     [last_correct], ) In\u00a0[\u00a0]: Copied! <pre>fixation = Text(800, \"+\")\nso_s = Text(so_s_duration)\nstroop = Text(2000, word, color, choices=[\"f\", \"j\"], correct_key=correct_key)\nfeedback = Text(800, feedback_text)\nso_f = Text(so_f_duration)\n</pre> fixation = Text(800, \"+\") so_s = Text(so_s_duration) stroop = Text(2000, word, color, choices=[\"f\", \"j\"], correct_key=correct_key) feedback = Text(800, feedback_text) so_f = Text(so_f_duration) <p>BLOCK DESIGN</p> In\u00a0[\u00a0]: Copied! <pre>block = Block([fixation, so_s, stroop, feedback, so_f], timeline)\n</pre> block = Block([fixation, so_s, stroop, feedback, so_f], timeline) In\u00a0[\u00a0]: Copied! <pre># Create an image of the stimuli sequence of the block\nblock.to_image(\n    \"stroop.png\",\n    data=[None, None, {\"correct\": True}, None, None],\n    zoom_factor=3,\n    sequence=True,\n)\n</pre> # Create an image of the stimuli sequence of the block block.to_image(     \"stroop.png\",     data=[None, None, {\"correct\": True}, None, None],     zoom_factor=3,     sequence=True, ) In\u00a0[\u00a0]: Copied! <pre># Create an HTML file of the experiment\nexperiment = Experiment([block])\nexperiment.to_html(\"stroop.html\")\n</pre> # Create an HTML file of the experiment experiment = Experiment([block]) experiment.to_html(\"stroop.html\")"},{"location":"Stimuli/symbols/","title":"Symbol","text":"<p>Render layered geometric shapes\u2014each with an optional texture\u2014to build anything from a single cue to a multi-element stimulus. You pass an items list (or a single shape fast-path); the plugin draws them in order of z (higher = on top). Shapes fill with either a color or a texture (texture takes precedence), and you can use blend modes for richer composites.</p>"},{"location":"Stimuli/symbols/#when-to-use","title":"When To Use","text":"<ul> <li>Minimal, highly controlled visual tokens (fixation, cues, placeholders).</li> <li>Simple one-off stimuli (e.g., a red triangle for 500 ms).</li> <li>Layered composites (e.g., plaid from two stripe textures + a ring overlay).</li> <li>Rapid prototyping of visual search, priming, Posner, DMS tasks.</li> <li>Adding lightweight noise masks or textured fills without image files.</li> </ul>"},{"location":"Stimuli/symbols/dm_same_diff/","title":"Dm same diff","text":"In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import Symbol\nfrom sweetbean.variable import FunctionVariable, TimelineVariable\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import Symbol from sweetbean.variable import FunctionVariable, TimelineVariable In\u00a0[\u00a0]: Copied! <pre>timeline = [\n    {\"sample_color\": \"red\", \"probe_color\": \"red\"},\n    {\"sample_color\": \"green\", \"probe_color\": \"red\"},\n]\n</pre> timeline = [     {\"sample_color\": \"red\", \"probe_color\": \"red\"},     {\"sample_color\": \"green\", \"probe_color\": \"red\"}, ] In\u00a0[\u00a0]: Copied! <pre>sample = Symbol(\n    shape=\"triangle\",\n    color=TimelineVariable(\"sample_color\"),\n    duration=500,\n)\n</pre> sample = Symbol(     shape=\"triangle\",     color=TimelineVariable(\"sample_color\"),     duration=500, ) In\u00a0[\u00a0]: Copied! <pre>delay = Symbol(\n    shape=\"cross\",\n    color=\"#888\",\n    duration=800,\n)\n</pre> delay = Symbol(     shape=\"cross\",     color=\"#888\",     duration=800, ) In\u00a0[\u00a0]: Copied! <pre>probe = Symbol(\n    shape=\"triangle\",\n    color=TimelineVariable(\"probe_color\"),\n    duration=1500,\n    choices=[\"f\", \"j\"],\n    response_ends_trial=True,\n    # F = same, J = different\n    correct_key=FunctionVariable(\n        \"ck\",\n        lambda s, p: \"f\" if str(s).lower() == str(p).lower() else \"j\",\n        [TimelineVariable(\"sample_color\"), TimelineVariable(\"probe_color\")],\n    ),\n)\n</pre> probe = Symbol(     shape=\"triangle\",     color=TimelineVariable(\"probe_color\"),     duration=1500,     choices=[\"f\", \"j\"],     response_ends_trial=True,     # F = same, J = different     correct_key=FunctionVariable(         \"ck\",         lambda s, p: \"f\" if str(s).lower() == str(p).lower() else \"j\",         [TimelineVariable(\"sample_color\"), TimelineVariable(\"probe_color\")],     ), ) In\u00a0[\u00a0]: Copied! <pre>block = Block([sample, delay, probe], timeline)\nExperiment([block]).to_html(\"dms_same_diff.html\")\n</pre> block = Block([sample, delay, probe], timeline) Experiment([block]).to_html(\"dms_same_diff.html\")"},{"location":"Stimuli/symbols/plaid_demo/","title":"Plaid demo","text":"In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import Feedback, Symbol, Text\nfrom sweetbean.variable import FunctionVariable, TimelineVariable\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import Feedback, Symbol, Text from sweetbean.variable import FunctionVariable, TimelineVariable In\u00a0[\u00a0]: Copied! <pre># --- constants / helpers ---\nR_INNER = 100\nR_OUTER = 180\nBAR_PX = 12\nGRAY55 = \"#8c8c8c\"\n</pre> # --- constants / helpers --- R_INNER = 100 R_OUTER = 180 BAR_PX = 12 GRAY55 = \"#8c8c8c\" In\u00a0[\u00a0]: Copied! <pre># Plaid contrast via two-tone palettes\nSTRONG_COLORS = [\"#bbbbbb\", \"#333333\"]\nWEAK_COLORS = [\"#999999\", \"#666666\"]\n</pre> # Plaid contrast via two-tone palettes STRONG_COLORS = [\"#bbbbbb\", \"#333333\"] WEAK_COLORS = [\"#999999\", \"#666666\"] In\u00a0[\u00a0]: Copied! <pre>timeline_left_right = [\n    {\n        \"prime_deg\": 0,\n        \"plaid_weak_deg\": 135,\n        \"plaid_strong_deg\": 45,\n    },  # vertical prime, left-leaning weak, right-leaning strong\n    {\n        \"prime_deg\": 90,\n        \"plaid_weak_deg\": 45,\n        \"plaid_strong_deg\": 135,\n    },  # horizontal prime, right-leaning weak, left-leaning strong\n    {\"prime_deg\": 45, \"plaid_weak_deg\": 180, \"plaid_strong_deg\": 45},\n    {\"prime_deg\": 135, \"plaid_weak_deg\": 90, \"plaid_strong_deg\": 135},\n]\n</pre> timeline_left_right = [     {         \"prime_deg\": 0,         \"plaid_weak_deg\": 135,         \"plaid_strong_deg\": 45,     },  # vertical prime, left-leaning weak, right-leaning strong     {         \"prime_deg\": 90,         \"plaid_weak_deg\": 45,         \"plaid_strong_deg\": 135,     },  # horizontal prime, right-leaning weak, left-leaning strong     {\"prime_deg\": 45, \"plaid_weak_deg\": 180, \"plaid_strong_deg\": 45},     {\"prime_deg\": 135, \"plaid_weak_deg\": 90, \"plaid_strong_deg\": 135}, ] In\u00a0[\u00a0]: Copied! <pre>timeline_same_diff = [\n    {\"prime_deg\": 0, \"plaid_weak_deg\": 135, \"plaid_strong_deg\": 45, \"probe_ori\": 45},\n    {\"prime_deg\": 90, \"plaid_weak_deg\": 45, \"plaid_strong_deg\": 135, \"probe_ori\": 45},\n    {\"prime_deg\": 45, \"plaid_weak_deg\": 180, \"plaid_strong_deg\": 90, \"probe_ori\": 0},\n    {\"prime_deg\": 135, \"plaid_weak_deg\": 90, \"plaid_strong_deg\": 0, \"probe_ori\": 135},\n]\n</pre> timeline_same_diff = [     {\"prime_deg\": 0, \"plaid_weak_deg\": 135, \"plaid_strong_deg\": 45, \"probe_ori\": 45},     {\"prime_deg\": 90, \"plaid_weak_deg\": 45, \"plaid_strong_deg\": 135, \"probe_ori\": 45},     {\"prime_deg\": 45, \"plaid_weak_deg\": 180, \"plaid_strong_deg\": 90, \"probe_ori\": 0},     {\"prime_deg\": 135, \"plaid_weak_deg\": 90, \"plaid_strong_deg\": 0, \"probe_ori\": 135}, ] In\u00a0[\u00a0]: Copied! <pre># Fixation\nfixation = Symbol(shape=\"cross\", color=\"#4d4d4d\", duration=200)\n</pre> # Fixation fixation = Symbol(shape=\"cross\", color=\"#4d4d4d\", duration=200) In\u00a0[\u00a0]: Copied! <pre># Gray ring placeholder\nplaceholder = Symbol(\n    items=[\n        {\n            \"shape\": \"ring\",\n            \"innerRadius\": R_INNER,\n            \"outerRadius\": R_OUTER,\n            \"color\": GRAY55,\n        }\n    ],\n    duration=80,\n)\n</pre> # Gray ring placeholder placeholder = Symbol(     items=[         {             \"shape\": \"ring\",             \"innerRadius\": R_INNER,             \"outerRadius\": R_OUTER,             \"color\": GRAY55,         }     ],     duration=80, ) In\u00a0[\u00a0]: Copied! <pre># Prime: circle filled with oriented stripes\nprime = Symbol(\n    items=[\n        {\n            \"shape\": \"circle\",\n            \"radius\": R_INNER,\n            \"color\": \"#777\",\n            \"texture\": {\n                \"type\": \"stripes\",\n                \"bar\": BAR_PX,\n                \"duty\": 0.5,\n                \"angle\": TimelineVariable(\"prime_deg\"),\n            },\n        }\n    ],\n    duration=100,\n)\n</pre> # Prime: circle filled with oriented stripes prime = Symbol(     items=[         {             \"shape\": \"circle\",             \"radius\": R_INNER,             \"color\": \"#777\",             \"texture\": {                 \"type\": \"stripes\",                 \"bar\": BAR_PX,                 \"duty\": 0.5,                 \"angle\": TimelineVariable(\"prime_deg\"),             },         }     ],     duration=100, ) In\u00a0[\u00a0]: Copied! <pre># Plaid: multiply two stripe-filled circles + overlay the ring\nplaid = Symbol(\n    items=[\n        {\n            \"shape\": \"circle\",\n            \"radius\": R_INNER,\n            \"color\": \"#777\",\n            \"blend\": \"multiply\",\n            \"texture\": {\n                \"type\": \"stripes\",\n                \"bar\": BAR_PX,\n                \"duty\": 0.5,\n                \"angle\": TimelineVariable(\"plaid_weak_deg\"),\n                \"colors\": WEAK_COLORS,\n            },\n        },\n        {\n            \"shape\": \"circle\",\n            \"radius\": R_INNER,\n            \"color\": \"#777\",\n            \"blend\": \"multiply\",\n            \"texture\": {\n                \"type\": \"stripes\",\n                \"bar\": BAR_PX,\n                \"duty\": 0.5,\n                \"angle\": TimelineVariable(\"plaid_strong_deg\"),\n                \"colors\": STRONG_COLORS,\n            },\n        },\n        {\n            \"shape\": \"ring\",\n            \"innerRadius\": R_INNER,\n            \"outerRadius\": R_OUTER,\n            \"color\": GRAY55,\n            \"z\": 10,\n        },\n    ],\n    duration=80,\n)\n</pre> # Plaid: multiply two stripe-filled circles + overlay the ring plaid = Symbol(     items=[         {             \"shape\": \"circle\",             \"radius\": R_INNER,             \"color\": \"#777\",             \"blend\": \"multiply\",             \"texture\": {                 \"type\": \"stripes\",                 \"bar\": BAR_PX,                 \"duty\": 0.5,                 \"angle\": TimelineVariable(\"plaid_weak_deg\"),                 \"colors\": WEAK_COLORS,             },         },         {             \"shape\": \"circle\",             \"radius\": R_INNER,             \"color\": \"#777\",             \"blend\": \"multiply\",             \"texture\": {                 \"type\": \"stripes\",                 \"bar\": BAR_PX,                 \"duty\": 0.5,                 \"angle\": TimelineVariable(\"plaid_strong_deg\"),                 \"colors\": STRONG_COLORS,             },         },         {             \"shape\": \"ring\",             \"innerRadius\": R_INNER,             \"outerRadius\": R_OUTER,             \"color\": GRAY55,             \"z\": 10,         },     ],     duration=80, ) In\u00a0[\u00a0]: Copied! <pre># Mask: circle filled with noise + ring overlay\nmask = Symbol(\n    items=[\n        {\n            \"shape\": \"circle\",\n            \"radius\": R_INNER,\n            \"color\": \"#777\",\n            \"texture\": {\n                \"type\": \"noise\",\n                \"cell\": 6,\n                \"seed\": 1337,\n                \"mix\": 0.6,\n                \"colors\": [\"#333\", \"#ccc\"],\n            },\n        },\n        {\n            \"shape\": \"ring\",\n            \"innerRadius\": R_INNER,\n            \"outerRadius\": R_OUTER,\n            \"color\": GRAY55,\n            \"z\": 10,\n        },\n    ],\n    duration=500,\n)\n</pre> # Mask: circle filled with noise + ring overlay mask = Symbol(     items=[         {             \"shape\": \"circle\",             \"radius\": R_INNER,             \"color\": \"#777\",             \"texture\": {                 \"type\": \"noise\",                 \"cell\": 6,                 \"seed\": 1337,                 \"mix\": 0.6,                 \"colors\": [\"#333\", \"#ccc\"],             },         },         {             \"shape\": \"ring\",             \"innerRadius\": R_INNER,             \"outerRadius\": R_OUTER,             \"color\": GRAY55,             \"z\": 10,         },     ],     duration=500, ) In\u00a0[\u00a0]: Copied! <pre># Forced-choice (left/right) correctness\ndef is_correct(darker_strong_deg):\n    return \"f\" if darker_strong_deg == 135 else \"j\"\n</pre> # Forced-choice (left/right) correctness def is_correct(darker_strong_deg):     return \"f\" if darker_strong_deg == 135 else \"j\" In\u00a0[\u00a0]: Copied! <pre>correct_key_left_right = FunctionVariable(\n    name=\"correct_key\", fct=is_correct, args=[TimelineVariable(\"plaid_strong_deg\")]\n)\n</pre> correct_key_left_right = FunctionVariable(     name=\"correct_key\", fct=is_correct, args=[TimelineVariable(\"plaid_strong_deg\")] ) In\u00a0[\u00a0]: Copied! <pre>resp_left_right = Text(\n    text=(\n        \"Which orientation was darker?&lt;br&gt;F = Left-leaning &amp;nbsp;&amp;nbsp; J = Right-leaning\"\n    ),\n    choices=[\"f\", \"j\"],\n    correct_key=correct_key_left_right,\n)\n</pre> resp_left_right = Text(     text=(         \"Which orientation was darker?F = Left-leaning \u00a0\u00a0 J = Right-leaning\"     ),     choices=[\"f\", \"j\"],     correct_key=correct_key_left_right, ) In\u00a0[\u00a0]: Copied! <pre># Feedback\nfeedback = Feedback(duration=1000)\n</pre> # Feedback feedback = Feedback(duration=1000) In\u00a0[\u00a0]: Copied! <pre># Probe: a thin rotated rectangle (was 'stripe')\nprobe_stripe = Symbol(\n    items=[\n        {\n            \"shape\": \"rectangle\",\n            \"width\": 10,\n            \"height\": 600,\n            \"rotation\": TimelineVariable(\"probe_ori\"),\n            \"color\": \"#999\",\n        },\n        {\n            \"shape\": \"circle\",\n            \"radius\": R_INNER,\n            \"color\": \"#777\",\n            \"texture\": {\n                \"type\": \"noise\",\n                \"cell\": 6,\n                \"seed\": 2024,\n                \"mix\": 0.6,\n                \"colors\": [\"#333\", \"#ccc\"],\n            },\n        },\n        {\n            \"shape\": \"ring\",\n            \"innerRadius\": R_INNER,\n            \"outerRadius\": R_OUTER,\n            \"color\": GRAY55,\n            \"z\": 10,\n        },\n    ],\n    duration=500,\n)\n</pre> # Probe: a thin rotated rectangle (was 'stripe') probe_stripe = Symbol(     items=[         {             \"shape\": \"rectangle\",             \"width\": 10,             \"height\": 600,             \"rotation\": TimelineVariable(\"probe_ori\"),             \"color\": \"#999\",         },         {             \"shape\": \"circle\",             \"radius\": R_INNER,             \"color\": \"#777\",             \"texture\": {                 \"type\": \"noise\",                 \"cell\": 6,                 \"seed\": 2024,                 \"mix\": 0.6,                 \"colors\": [\"#333\", \"#ccc\"],             },         },         {             \"shape\": \"ring\",             \"innerRadius\": R_INNER,             \"outerRadius\": R_OUTER,             \"color\": GRAY55,             \"z\": 10,         },     ],     duration=500, ) In\u00a0[\u00a0]: Copied! <pre># Same/Different correctness\ndef is_same(probe_ori, plaid_strong_deg):\n    return \"f\" if probe_ori == plaid_strong_deg else \"j\"\n</pre> # Same/Different correctness def is_same(probe_ori, plaid_strong_deg):     return \"f\" if probe_ori == plaid_strong_deg else \"j\" In\u00a0[\u00a0]: Copied! <pre>correct_key_same_diff = FunctionVariable(\n    name=\"correct_key\",\n    fct=is_same,\n    args=[TimelineVariable(\"probe_ori\"), TimelineVariable(\"plaid_strong_deg\")],\n)\n</pre> correct_key_same_diff = FunctionVariable(     name=\"correct_key\",     fct=is_same,     args=[TimelineVariable(\"probe_ori\"), TimelineVariable(\"plaid_strong_deg\")], ) In\u00a0[\u00a0]: Copied! <pre>resp_same_diff = Text(\n    text=(\n        \"Is the outer gray stripe in the same direction as the darker set of lines?&lt;br&gt;\"\n        \"F = Same &amp;nbsp;&amp;nbsp; J = Different\"\n    ),\n    choices=[\"f\", \"j\"],\n    correct_key=correct_key_same_diff,\n)\n</pre> resp_same_diff = Text(     text=(         \"Is the outer gray stripe in the same direction as the darker set of lines?\"         \"F = Same \u00a0\u00a0 J = Different\"     ),     choices=[\"f\", \"j\"],     correct_key=correct_key_same_diff, ) In\u00a0[\u00a0]: Copied! <pre># ----------- Build and export -----------\ntrial_sequence_left_right = [\n    fixation,\n    placeholder,\n    prime,\n    plaid,\n    mask,\n    resp_left_right,\n    feedback,\n]\ntrial_sequence_same_diff = [\n    fixation,\n    placeholder,\n    prime,\n    plaid,\n    mask,\n    probe_stripe,\n    resp_same_diff,\n    feedback,\n]\n</pre> # ----------- Build and export ----------- trial_sequence_left_right = [     fixation,     placeholder,     prime,     plaid,     mask,     resp_left_right,     feedback, ] trial_sequence_same_diff = [     fixation,     placeholder,     prime,     plaid,     mask,     probe_stripe,     resp_same_diff,     feedback, ] In\u00a0[\u00a0]: Copied! <pre>block_left_right = Block(trial_sequence_left_right, timeline_left_right)\nblock_same_diff = Block(trial_sequence_same_diff, timeline_same_diff)\n</pre> block_left_right = Block(trial_sequence_left_right, timeline_left_right) block_same_diff = Block(trial_sequence_same_diff, timeline_same_diff) In\u00a0[\u00a0]: Copied! <pre>Experiment([block_left_right, block_same_diff]).to_html(\"plaid_demo.html\")\n</pre> Experiment([block_left_right, block_same_diff]).to_html(\"plaid_demo.html\")"},{"location":"Stimuli/symbols/posner/","title":"Posner","text":"In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import Symbol\nfrom sweetbean.variable import FunctionVariable, TimelineVariable\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import Symbol from sweetbean.variable import FunctionVariable, TimelineVariable In\u00a0[\u00a0]: Copied! <pre># constants\nPPD = 60\nX_LEFT = int(round(-6 * PPD))  # -360 px\nX_RIGHT = int(round(6 * PPD))  # 360 px\nR_CUE = int(round(0.4 * PPD))  # 24 px\nR_TGT = int(round(0.35 * PPD))  # 21 px\n</pre> # constants PPD = 60 X_LEFT = int(round(-6 * PPD))  # -360 px X_RIGHT = int(round(6 * PPD))  # 360 px R_CUE = int(round(0.4 * PPD))  # 24 px R_TGT = int(round(0.35 * PPD))  # 21 px In\u00a0[\u00a0]: Copied! <pre>timeline = [\n    {\"cue_side\": \"left\", \"target_side\": \"left\"},  # valid\n    {\"cue_side\": \"right\", \"target_side\": \"left\"},  # invalid\n]\n</pre> timeline = [     {\"cue_side\": \"left\", \"target_side\": \"left\"},  # valid     {\"cue_side\": \"right\", \"target_side\": \"left\"},  # invalid ] In\u00a0[\u00a0]: Copied! <pre>fix = Symbol(shape=\"cross\", color=\"#4d4d4d\", duration=300)\n</pre> fix = Symbol(shape=\"cross\", color=\"#4d4d4d\", duration=300) In\u00a0[\u00a0]: Copied! <pre>cue = Symbol(\n    items=[\n        {\"shape\": \"circle\", \"x\": X_LEFT, \"y\": 0, \"color\": \"#666\"},\n        {\"shape\": \"circle\", \"x\": X_RIGHT, \"y\": 0, \"color\": \"#666\"},\n        {\n            \"shape\": \"circle\",\n            \"x\": FunctionVariable(\n                \"x\",\n                lambda side, L, R: L if side == \"left\" else R,\n                [TimelineVariable(\"cue_side\"), X_LEFT, X_RIGHT],\n            ),\n            \"y\": 0,\n            \"color\": \"#fff\",\n            \"radius\": R_CUE,\n        },\n    ],\n    duration=100,\n)\n</pre> cue = Symbol(     items=[         {\"shape\": \"circle\", \"x\": X_LEFT, \"y\": 0, \"color\": \"#666\"},         {\"shape\": \"circle\", \"x\": X_RIGHT, \"y\": 0, \"color\": \"#666\"},         {             \"shape\": \"circle\",             \"x\": FunctionVariable(                 \"x\",                 lambda side, L, R: L if side == \"left\" else R,                 [TimelineVariable(\"cue_side\"), X_LEFT, X_RIGHT],             ),             \"y\": 0,             \"color\": \"#fff\",             \"radius\": R_CUE,         },     ],     duration=100, ) In\u00a0[\u00a0]: Copied! <pre>isi = Symbol(shape=\"cross\", color=\"#4d4d4d\", duration=200)\n</pre> isi = Symbol(shape=\"cross\", color=\"#4d4d4d\", duration=200) In\u00a0[\u00a0]: Copied! <pre>target = Symbol(\n    items=[\n        {\"shape\": \"circle\", \"x\": X_LEFT, \"y\": 0, \"color\": \"#fff\", \"radius\": R_TGT},\n        {\"shape\": \"circle\", \"x\": X_RIGHT, \"y\": 0, \"color\": \"#fff\", \"radius\": R_TGT},\n        {\n            # mask the non-target by making it gray\n            \"shape\": \"circle\",\n            \"x\": FunctionVariable(\n                \"x\",\n                lambda side, L, R: R\n                if side == \"left\"\n                else L,  # opposite of target side\n                [TimelineVariable(\"target_side\"), X_LEFT, X_RIGHT],\n            ),\n            \"y\": 0,\n            \"color\": \"#808080\",\n            \"radius\": R_TGT,\n        },\n    ],\n    duration=1200,\n    choices=[\"f\", \"j\"],\n    response_ends_trial=True,\n    # F = left, J = right\n    correct_key=FunctionVariable(\n        \"ck\",\n        lambda side: \"f\" if side == \"left\" else \"j\",\n        [TimelineVariable(\"target_side\")],\n    ),\n)\n</pre> target = Symbol(     items=[         {\"shape\": \"circle\", \"x\": X_LEFT, \"y\": 0, \"color\": \"#fff\", \"radius\": R_TGT},         {\"shape\": \"circle\", \"x\": X_RIGHT, \"y\": 0, \"color\": \"#fff\", \"radius\": R_TGT},         {             # mask the non-target by making it gray             \"shape\": \"circle\",             \"x\": FunctionVariable(                 \"x\",                 lambda side, L, R: R                 if side == \"left\"                 else L,  # opposite of target side                 [TimelineVariable(\"target_side\"), X_LEFT, X_RIGHT],             ),             \"y\": 0,             \"color\": \"#808080\",             \"radius\": R_TGT,         },     ],     duration=1200,     choices=[\"f\", \"j\"],     response_ends_trial=True,     # F = left, J = right     correct_key=FunctionVariable(         \"ck\",         lambda side: \"f\" if side == \"left\" else \"j\",         [TimelineVariable(\"target_side\")],     ), ) In\u00a0[\u00a0]: Copied! <pre>block = Block([fix, cue, isi, target], timeline)\nExperiment([block]).to_html(\"posner.html\")\n</pre> block = Block([fix, cue, isi, target], timeline) Experiment([block]).to_html(\"posner.html\")"},{"location":"Stimuli/symbols/symbols/","title":"Symbols","text":"In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import Symbol, Text\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import Symbol, Text In\u00a0[\u00a0]: Copied! <pre>stim_1 = Text(\n    text=\"Welcome! We show some Symbols. Press SPACE to continue\", choices=[\" \"]\n)\n</pre> stim_1 = Text(     text=\"Welcome! We show some Symbols. Press SPACE to continue\", choices=[\" \"] ) In\u00a0[\u00a0]: Copied! <pre>stim_2 = Symbol(\n    shape=\"rectangle\", color=\"#f0f\", duration=1000, choices=[\"f\", \"j\"], correct_key=\"f\"\n)\nstim_3 = Symbol(\n    shape=\"triangle\", color=\"red\", duration=1000, choices=[\"f\", \"j\"], correct_key=\"f\"\n)\nstim_4 = Symbol(\n    shape=\"circle\", color=\"green\", duration=1000, choices=[\"f\", \"j\"], correct_key=\"j\"\n)\n</pre> stim_2 = Symbol(     shape=\"rectangle\", color=\"#f0f\", duration=1000, choices=[\"f\", \"j\"], correct_key=\"f\" ) stim_3 = Symbol(     shape=\"triangle\", color=\"red\", duration=1000, choices=[\"f\", \"j\"], correct_key=\"f\" ) stim_4 = Symbol(     shape=\"circle\", color=\"green\", duration=1000, choices=[\"f\", \"j\"], correct_key=\"j\" ) In\u00a0[\u00a0]: Copied! <pre>block = Block([stim_1, stim_2, stim_3, stim_4])\n</pre> block = Block([stim_1, stim_2, stim_3, stim_4]) In\u00a0[\u00a0]: Copied! <pre>Experiment([block]).to_html(\"symbols.html\")\n</pre> Experiment([block]).to_html(\"symbols.html\")"},{"location":"Stimuli/symbols/visual_search/","title":"Visual search","text":"In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import Symbol\nfrom sweetbean.variable import TimelineVariable\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import Symbol from sweetbean.variable import TimelineVariable In\u00a0[\u00a0]: Copied! <pre>timeline = [\n    {\n        \"items\": [\n            {\"shape\": \"circle\", \"x\": -300, \"y\": 0, \"color\": \"#666\"},\n            {\"shape\": \"circle\", \"x\": 0, \"y\": 0, \"color\": \"#666\"},\n            {\"shape\": \"triangle\", \"x\": 300, \"y\": 0, \"color\": \"red\"},  # target\n        ],\n        \"correct_key\": \"f\",  # F = present, J = absent\n    },\n    {\n        \"items\": [\n            {\"shape\": \"circle\", \"x\": -300, \"y\": 0, \"color\": \"#666\"},\n            {\"shape\": \"circle\", \"x\": 0, \"y\": 0, \"color\": \"#666\"},\n            {\"shape\": \"circle\", \"x\": 300, \"y\": 0, \"color\": \"#666\"},\n        ],\n        \"correct_key\": \"j\",\n    },\n]\n</pre> timeline = [     {         \"items\": [             {\"shape\": \"circle\", \"x\": -300, \"y\": 0, \"color\": \"#666\"},             {\"shape\": \"circle\", \"x\": 0, \"y\": 0, \"color\": \"#666\"},             {\"shape\": \"triangle\", \"x\": 300, \"y\": 0, \"color\": \"red\"},  # target         ],         \"correct_key\": \"f\",  # F = present, J = absent     },     {         \"items\": [             {\"shape\": \"circle\", \"x\": -300, \"y\": 0, \"color\": \"#666\"},             {\"shape\": \"circle\", \"x\": 0, \"y\": 0, \"color\": \"#666\"},             {\"shape\": \"circle\", \"x\": 300, \"y\": 0, \"color\": \"#666\"},         ],         \"correct_key\": \"j\",     }, ] In\u00a0[\u00a0]: Copied! <pre>fix = Symbol(shape=\"cross\", color=\"#4d4d4d\", duration=400)\n</pre> fix = Symbol(shape=\"cross\", color=\"#4d4d4d\", duration=400) In\u00a0[\u00a0]: Copied! <pre>search = Symbol(\n    items=TimelineVariable(\"items\"),\n    duration=2000,\n    choices=[\"f\", \"j\"],\n    correct_key=TimelineVariable(\"correct_key\"),\n)\n</pre> search = Symbol(     items=TimelineVariable(\"items\"),     duration=2000,     choices=[\"f\", \"j\"],     correct_key=TimelineVariable(\"correct_key\"), ) In\u00a0[\u00a0]: Copied! <pre>block = Block([fix, search], timeline)\n</pre> block = Block([fix, search], timeline) In\u00a0[\u00a0]: Copied! <pre>Experiment([block]).to_html(\"visual_search.html\")\n</pre> Experiment([block]).to_html(\"visual_search.html\")"},{"location":"Stimuli/text/","title":"Text","text":"<p>Show a text string in a chosen color. Optionally collect keyboard responses while the text is on screen.</p>"},{"location":"Stimuli/text/#when-to-use","title":"When To Use","text":"<ul> <li>Present brief instructions, cues, or labels in text form.</li> <li>Simple Stroop-style text displays (color/word).</li> <li>A lightweight alternative to full HTML when you just need colored text.</li> </ul>"},{"location":"Stimuli/text/#example-flanker-task","title":"Example: Flanker Task","text":"<p>A central target stimulus is flanked by distractor stimuli. The participant is asked to respond to the direction of the target stimulus while ignoring the distractors.</p> <p></p>"},{"location":"Stimuli/text/#example-stroop-task","title":"Example: Stroop Task","text":"<p>A colored word is displayed. In most variants, the participant is asked to name the color of the word. Here, we show a version where the participnat has to decide weather color and word fit (are congruent) or not (are incongruent).</p> <p></p>"},{"location":"Stimuli/text/text/","title":"Text","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nThe text 'press a or b or wait' is shown in pink for 2000ms. The allowed responses are 'a' and 'b'.\n\"\"\"\n</pre> \"\"\" The text 'press a or b or wait' is shown in pink for 2000ms. The allowed responses are 'a' and 'b'. \"\"\" In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import Text\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import Text <p>EVENT SEQUENCE</p> In\u00a0[\u00a0]: Copied! <pre>text = Text(\n    duration=2000, text=\"press a or b or wait\", color=\"pink\", choices=[\"a\", \"b\"]\n)\n</pre> text = Text(     duration=2000, text=\"press a or b or wait\", color=\"pink\", choices=[\"a\", \"b\"] ) In\u00a0[\u00a0]: Copied! <pre>event_sequence = [text]\n</pre> event_sequence = [text] <p>BLOCK DESIGN</p> In\u00a0[\u00a0]: Copied! <pre>block = Block(event_sequence)\nexperiment = Experiment([block])\n</pre> block = Block(event_sequence) experiment = Experiment([block]) In\u00a0[\u00a0]: Copied! <pre>experiment.to_html(\"text.html\")\n</pre> experiment.to_html(\"text.html\")"},{"location":"Stimuli/textsurvey/","title":"TextSurvey","text":"<p>Present one or more free-text questions with text input fields. Participants type their answers; each response is recorded per question. Useful for short answers, open-ended prompts, and typed recall.</p>"},{"location":"Stimuli/textsurvey/#when-to-use","title":"When To Use","text":"<ul> <li>Open-ended responses or brief written answers</li> <li>Typed recall, explanations, or comments</li> <li>Optional text capture after another stimulus</li> </ul>"},{"location":"Stimuli/textsurvey/textsurvey/","title":"Textsurvey","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nAfter the participant is greeted with 'Welcome! We show a survey. Press SPACE to continue' until\nthey press the spacebar, they are asked free-from questions about how old they are, their gender,\nand their handedness.\n\"\"\"\n</pre> \"\"\" After the participant is greeted with 'Welcome! We show a survey. Press SPACE to continue' until they press the spacebar, they are asked free-from questions about how old they are, their gender, and their handedness. \"\"\" In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import Text, TextSurvey\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import Text, TextSurvey <p>EVENT SEQUENCE</p> In\u00a0[\u00a0]: Copied! <pre>stim_1 = Text(\n    text=\"Welcome! We show a survey. Press SPACE to continue\",\n    choices=[\" \"],\n)\n</pre> stim_1 = Text(     text=\"Welcome! We show a survey. Press SPACE to continue\",     choices=[\" \"], ) In\u00a0[\u00a0]: Copied! <pre>stim_2 = TextSurvey(\n    questions=[\"How old are you?\", \"What is your gender?\", \"What is your handedness?\"]\n)\n</pre> stim_2 = TextSurvey(     questions=[\"How old are you?\", \"What is your gender?\", \"What is your handedness?\"] ) In\u00a0[\u00a0]: Copied! <pre>event_sequence = [stim_1, stim_2]\n</pre> event_sequence = [stim_1, stim_2] <p>BLOCK DESIGN</p> In\u00a0[\u00a0]: Copied! <pre>block = Block(event_sequence)\nexperiment = Experiment([block])\nexperiment.to_html(\"textsurvey.html\")\n</pre> block = Block(event_sequence) experiment = Experiment([block]) experiment.to_html(\"textsurvey.html\")"},{"location":"Stimuli/video/","title":"Video","text":"<p>Present a video clip and optionally collect a keyboard response while it plays or after it ends. Supports single or multiple source files, auto-play, end-on-finish behavior, and optional sizing/controls.</p>"},{"location":"Stimuli/video/#when-to-use","title":"When To Use","text":"<ul> <li>Trials where a short video is the primary stimulus.</li> <li>You want responses during/after playback with reaction time.</li> <li>Stimuli referenced by file paths or URLs in your data.</li> </ul>"},{"location":"Stimuli/video/video/","title":"Video","text":"<p>docs/Stimuli/video/basic.py</p> In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import Text, Video\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import Text, Video In\u00a0[\u00a0]: Copied! <pre># Gate: require a keypress so browsers allow autoplay\ngate = Text(\n    text=\"Press SPACE to start the videos\",\n    color=\"white\",\n    choices=[\" \"],  # spacebar\n    duration=None,\n)\n</pre> # Gate: require a keypress so browsers allow autoplay gate = Text(     text=\"Press SPACE to start the videos\",     color=\"white\",     choices=[\" \"],  # spacebar     duration=None, ) In\u00a0[\u00a0]: Copied! <pre># Example 1 \u2014 play a video from a URL; trial ends when the video finishes.\nvideo_trial = Video(\n    stimulus=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\",\n    choices=[\"f\", \"j\"],  # collect keypress during playback\n    trial_ends_after_video=True,  # end automatically at video end\n    autoplay=True,\n    controls=False,\n    width=640,\n    height=360,\n)\n</pre> # Example 1 \u2014 play a video from a URL; trial ends when the video finishes. video_trial = Video(     stimulus=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\",     choices=[\"f\", \"j\"],  # collect keypress during playback     trial_ends_after_video=True,  # end automatically at video end     autoplay=True,     controls=False,     width=640,     height=360, ) In\u00a0[\u00a0]: Copied! <pre># Example 2 \u2014 allow a 2s response window after the video ends.\npost_window = Video(\n    stimulus=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\",\n    choices=[\"f\", \"j\"],\n    trial_ends_after_video=False,  # don't end on finish\n    duration=2000,  # alias for trial_duration (keeps trial alive 2s)\n    autoplay=True,\n    controls=False,\n)\n</pre> # Example 2 \u2014 allow a 2s response window after the video ends. post_window = Video(     stimulus=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\",     choices=[\"f\", \"j\"],     trial_ends_after_video=False,  # don't end on finish     duration=2000,  # alias for trial_duration (keeps trial alive 2s)     autoplay=True,     controls=False, ) In\u00a0[\u00a0]: Copied! <pre># Example 3 \u2014 multiple sources (browser compatibility); still OK with URLs.\nmulti_source = Video(\n    stimulus=[\n        \"https://media.w3.org/2010/05/sintel/trailer.webm\",\n        \"https://media.w3.org/2010/05/sintel/trailer.mp4\",\n    ],\n    choices=[\"f\", \"j\"],\n    trial_ends_after_video=True,\n    autoplay=True,\n    controls=True,\n)\n</pre> # Example 3 \u2014 multiple sources (browser compatibility); still OK with URLs. multi_source = Video(     stimulus=[         \"https://media.w3.org/2010/05/sintel/trailer.webm\",         \"https://media.w3.org/2010/05/sintel/trailer.mp4\",     ],     choices=[\"f\", \"j\"],     trial_ends_after_video=True,     autoplay=True,     controls=True, ) In\u00a0[\u00a0]: Copied! <pre>block = Block([gate, video_trial, post_window, multi_source])\nexperiment = Experiment([block])\nexperiment.to_html(\"video.html\")\n</pre> block = Block([gate, video_trial, post_window, multi_source]) experiment = Experiment([block]) experiment.to_html(\"video.html\")"},{"location":"Use%20Case%20Tutorials/","title":"Use Case Tutorials","text":"<p>This section provides examples of experiments generated by SweetBean. This may serve as a starting point for your own experiments. </p>"},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/","title":"Comparing LLM and human behavior","text":"<p>SweetBean experiments can be run online or with via language models. This makes SweetBean a convenient package to collect data from real participants and compare it to data generated by language models. For example, to finetune a model on the collected data for alignment.</p>"},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/Bandit%20Task/","title":"Reinforcement Learning","text":"In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import Bandit, Text\nfrom sweetbean.variable import (\n    DataVariable,\n    FunctionVariable,\n    SharedVariable,\n    SideEffect,\n    TimelineVariable,\n)\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import Bandit, Text from sweetbean.variable import (     DataVariable,     FunctionVariable,     SharedVariable,     SideEffect,     TimelineVariable, ) In\u00a0[\u00a0]: Copied! <pre>timeline = []\nfor i in range(11):\n    timeline.append(\n        {\n            \"bandit_1\": {\"color\": \"orange\", \"value\": 10 - i},\n            \"bandit_2\": {\"color\": \"blue\", \"value\": i},\n        }\n    )\n</pre> timeline = [] for i in range(11):     timeline.append(         {             \"bandit_1\": {\"color\": \"orange\", \"value\": 10 - i},             \"bandit_2\": {\"color\": \"blue\", \"value\": i},         }     ) In\u00a0[\u00a0]: Copied! <pre>bandit_1 = TimelineVariable(\"bandit_1\")\nbandit_2 = TimelineVariable(\"bandit_2\")\n\nscore = SharedVariable(\"score\", 0)\nvalue = DataVariable(\"value\", 0)\n\nupdate_score = FunctionVariable(\n    \"update_score\", lambda sc, val: sc + val, [score, value]\n)\n\nupdate_score_side_effect = SideEffect(score, update_score)\n\nbandit_task = Bandit(\n    bandits=[bandit_1, bandit_2],\n    side_effects=[update_score_side_effect],\n)\n\nscore_text = FunctionVariable(\"score_text\", lambda sc: f\"Score: {sc}\", [score])\n\nshow_score = Text(duration=2000, text=score_text)\n\ntrial_sequence = Block([bandit_task, show_score], timeline=timeline)\nexperiment = Experiment([trial_sequence])\n</pre> bandit_1 = TimelineVariable(\"bandit_1\") bandit_2 = TimelineVariable(\"bandit_2\")  score = SharedVariable(\"score\", 0) value = DataVariable(\"value\", 0)  update_score = FunctionVariable(     \"update_score\", lambda sc, val: sc + val, [score, value] )  update_score_side_effect = SideEffect(score, update_score)  bandit_task = Bandit(     bandits=[bandit_1, bandit_2],     side_effects=[update_score_side_effect], )  score_text = FunctionVariable(\"score_text\", lambda sc: f\"Score: {sc}\", [score])  show_score = Text(duration=2000, text=score_text)  trial_sequence = Block([bandit_task, show_score], timeline=timeline) experiment = Experiment([trial_sequence]) <p>Export the experiment to a html file and run it in the browser.</p> In\u00a0[\u00a0]: Copied! <pre>experiment.to_html(\"bandit.html\", path_local_download=\"bandit.json\")\n</pre> experiment.to_html(\"bandit.html\", path_local_download=\"bandit.json\") In\u00a0[\u00a0]: Copied! <pre>import json\nfrom sweetbean.data import process_js, get_n_responses, until_response\n\nwith open(\"bandit.json\") as f:\n    data_raw = json.load(f)\n    \ndata = process_js(data_raw)\n</pre> import json from sweetbean.data import process_js, get_n_responses, until_response  with open(\"bandit.json\") as f:     data_raw = json.load(f)      data = process_js(data_raw) <p>We can now get the number of times a response was made and get the data until before the third response:</p> In\u00a0[\u00a0]: Copied! <pre>n_responses = get_n_responses(data)\ndata_third_response = until_response(data, 3)\n</pre> n_responses = get_n_responses(data) data_third_response = until_response(data, 3) In\u00a0[\u00a0]: Copied! <pre>data_input, _ = experiment.run_on_language(input, data=data_third_response)\n</pre> data_input, _ = experiment.run_on_language(input, data=data_third_response) In\u00a0[\u00a0]: Copied! <pre>print(data_input)\n</pre> print(data_input) <p>Instead of running the experiment manually, we can also use a large language model. In this case, we use centaur. This model has been trained on similar tasks as the two-armed bandit task. We can use the model to predict the next response and then run the experiment on the model. We can then compare the results with the actual data.</p> <p>First, we need to install unsloth</p> In\u00a0[\u00a0]: Copied! <pre>!pip install unsloth \"xformers==0.0.28.post2\"\n</pre> !pip install unsloth \"xformers==0.0.28.post2\" <p>Then, we load the model:</p> In\u00a0[\u00a0]: Copied! <pre>from unsloth import FastLanguageModel\nimport transformers\n\nmodel, tokenizer = FastLanguageModel.from_pretrained(\n  model_name = \"marcelbinz/Llama-3.1-Centaur-8B-adapter\",\n  max_seq_length = 32768,\n  dtype = None,\n  load_in_4bit = True,\n)\nFastLanguageModel.for_inference(model)\n\npipe = transformers.pipeline(\n            \"text-generation\",\n            model=model,\n            tokenizer=tokenizer,\n            trust_remote_code=True,\n            pad_token_id=0,\n            do_sample=True,\n            temperature=1.0,\n            max_new_tokens=1,\n)\n</pre> from unsloth import FastLanguageModel import transformers  model, tokenizer = FastLanguageModel.from_pretrained(   model_name = \"marcelbinz/Llama-3.1-Centaur-8B-adapter\",   max_seq_length = 32768,   dtype = None,   load_in_4bit = True, ) FastLanguageModel.for_inference(model)  pipe = transformers.pipeline(             \"text-generation\",             model=model,             tokenizer=tokenizer,             trust_remote_code=True,             pad_token_id=0,             do_sample=True,             temperature=1.0,             max_new_tokens=1, ) <p>Finally, we create a function to pass into the experiment:</p> In\u00a0[\u00a0]: Copied! <pre>def generate(prompt):\n    return pipe(prompt)[0]['generated_text'][len(prompt):]\n</pre> def generate(prompt):     return pipe(prompt)[0]['generated_text'][len(prompt):] <p>We can use this to run the full experiment:</p> In\u00a0[\u00a0]: Copied! <pre>data_centaur_full = experiment.run_on_language(generate)\n</pre> data_centaur_full = experiment.run_on_language(generate) <p>Or we can run the experiment from the third response</p> In\u00a0[\u00a0]: Copied! <pre>data_centaur_partial = experiment.run_on_language(generate, data=data_third_response)\n\n# Print the data:\nprint(data_centaur_full)\nprint(data_centaur_partial)\nprint(data)\n</pre> data_centaur_partial = experiment.run_on_language(generate, data=data_third_response)  # Print the data: print(data_centaur_full) print(data_centaur_partial) print(data) In\u00a0[\u00a0]: Copied! <pre>score_human = sum([d[\"value\"] for d in data])\nscore_centaur = sum([d[\"value\"] for d in data_centaur_full])\n\nprint(f\"Score human: {score_human}\")\nprint(f\"Score centaur: {score_centaur}\")\n</pre> score_human = sum([d[\"value\"] for d in data]) score_centaur = sum([d[\"value\"] for d in data_centaur_full])  print(f\"Score human: {score_human}\") print(f\"Score centaur: {score_centaur}\")"},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/Bandit%20Task/#reinforcement-learning","title":"Reinforcement Learning\u00b6","text":"<p>Bandit tasks are used to study human reinforcement learning behavior. Here, we will implement a simple two-armed bandit task. We then run the same task on a language model specifically trained on tasks like these (centaur) and compare the results.</p>"},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/Bandit%20Task/#two-armed-bandit-task","title":"Two-Armed Bandit Task\u00b6","text":""},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/Bandit%20Task/#imports","title":"Imports\u00b6","text":""},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/Bandit%20Task/#timeline","title":"Timeline\u00b6","text":"<p>Here, we slowly change the values of <code>bandit_1</code> 10 to 0 and for <code>bandit_2</code> in reverse order from 0 to 10.</p>"},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/Bandit%20Task/#implementation","title":"Implementation\u00b6","text":"<p>We also keep track of the score with a shared variable to present it between the bandit tasks.</p>"},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/Bandit%20Task/#results","title":"Results\u00b6","text":"<p>After running bandit.html, there should be a file called <code>bandit.json</code> in the download directory. You can open the file in your browser to see the results. First, we process it so that it only contains relevant data:</p>"},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/Bandit%20Task/#experiment-on-language-model","title":"Experiment on language model\u00b6","text":"<p>With the partial data, we can now run the experiment up to that point and then run the rest of the experiment on language input. To test this, we run it manually:</p>"},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/Bandit%20Task/#comparison","title":"Comparison\u00b6","text":"<p>We can compare the results of the actual data with the data from the language model. For example, we can compare the number overall scores reached by humans and the language model:</p>"},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/Bandit%20Task/#conclusion","title":"Conclusion\u00b6","text":"<p>This notebook demonstrates how to run a simple bandit task via a website or a language model. The results can, for example, be compared to analyse the language model or can be used in fine-tuning the model.</p> <p>SweetBean is also integrated in AutoRa, a platform for running the same experiments automatically via prolific. This allows for automatic data collection and analysis while using large language models either for prototyping, in finding good experimental design or for automatic fine-tuning.</p>"},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/Trolley%20Problem/","title":"Trolley Problem","text":"In\u00a0[\u00a0]: Copied! <pre>!pip install sweetbean\n</pre> !pip install sweetbean In\u00a0[\u00a0]: Copied! <pre>import random\n\nnumbers = ['one', 'two', 'three', 'four', 'five']\ncharacters = [\n    ('person', 'people'), ('girl', 'girls'), ('baby', 'babies'), ('woman', 'women'),\n    ('boy', 'boys'), ('man', 'men'), ('prisoner', 'prisoners'), ('rich person', 'rich people'),\n    ('old lady', 'old ladies'), ('old man', 'old men'), ('poor person', 'poor people'),\n    ('mother', 'mothers'), ('father', 'fathers'), ('relative', 'relatives'), ('friend', 'friends'),\n    ('stranger', 'strangers'), ('teacher', 'teachers'), ('doctor', 'doctors'), ('nurse', 'nurses'), \n    ('politician', 'politicians'), ('criminal', 'criminals'), ('thief', 'thieves'), ('murderer', 'murderers'),\n    ('dog', 'dogs'), ('cat', 'cats'), ('lobster', 'lobsters'), ('horse', 'horses'), ('tiger', 'tigers'),\n    ('polar bear', 'polar bears')\n    ]\n\noptions = []\nfor n in numbers:\n    for c in characters:\n        if n == 'one':\n            options.append(f'{n} {c[0]}')\n        else:\n            options.append(f'{n} {c[1]}')\n\ntimeline = []\n\nfor _ in range(4):\n    timeline.append(\n        {'main': random.choice(options),\n         'side': random.choice(options)\n         })\n</pre> import random  numbers = ['one', 'two', 'three', 'four', 'five'] characters = [     ('person', 'people'), ('girl', 'girls'), ('baby', 'babies'), ('woman', 'women'),     ('boy', 'boys'), ('man', 'men'), ('prisoner', 'prisoners'), ('rich person', 'rich people'),     ('old lady', 'old ladies'), ('old man', 'old men'), ('poor person', 'poor people'),     ('mother', 'mothers'), ('father', 'fathers'), ('relative', 'relatives'), ('friend', 'friends'),     ('stranger', 'strangers'), ('teacher', 'teachers'), ('doctor', 'doctors'), ('nurse', 'nurses'),      ('politician', 'politicians'), ('criminal', 'criminals'), ('thief', 'thieves'), ('murderer', 'murderers'),     ('dog', 'dogs'), ('cat', 'cats'), ('lobster', 'lobsters'), ('horse', 'horses'), ('tiger', 'tigers'),     ('polar bear', 'polar bears')     ]  options = [] for n in numbers:     for c in characters:         if n == 'one':             options.append(f'{n} {c[0]}')         else:             options.append(f'{n} {c[1]}')  timeline = []  for _ in range(4):     timeline.append(         {'main': random.choice(options),          'side': random.choice(options)          }) In\u00a0[\u00a0]: Copied! <pre>from sweetbean.stimulus import Text\n\nintroduction_welcome = Text(\n    text=\"Welcome to our experiment.&lt;br&gt;&lt;br&gt;\"\n         \"Press the SPACE key to continue.\",\n    choices=[' '])\n\nintroduction_trolley = Text(\n    text=\"You will be presented with trolley problems where you must decide whether to pull a lever.&lt;br&gt;\"\n         \"- Pulling the lever will change the trolley's trajectory to the side track.&lt;br&gt;\"\n         \"- If you do nothing, the trolley will remain on the main track.&lt;br&gt;&lt;br&gt;\"\n         \"Press the SPACE key to BEGIN the experiment.\",\n    choices=[' '])\n</pre> from sweetbean.stimulus import Text  introduction_welcome = Text(     text=\"Welcome to our experiment.\"          \"Press the SPACE key to continue.\",     choices=[' '])  introduction_trolley = Text(     text=\"You will be presented with trolley problems where you must decide whether to pull a lever.\"          \"- Pulling the lever will change the trolley's trajectory to the side track.\"          \"- If you do nothing, the trolley will remain on the main track.\"          \"Press the SPACE key to BEGIN the experiment.\",     choices=[' ']) In\u00a0[\u00a0]: Copied! <pre>from sweetbean.variable import TimelineVariable, FunctionVariable\nfrom sweetbean.stimulus import MultiChoiceSurvey\n\nmain = TimelineVariable('main')\nside = TimelineVariable('side')\n\n\ndef get_question(m, s):\n    txt = 'You are standing by the railroad tracks when you notice an empty boxcar rolling out of control. It is moving so fast that anyone it hits will die.'\n    txt += ' Ahead on the main track'\n    if m[:3] == 'one':\n        txt += f' is {m}.'\n    else:\n        txt += f' are {m}.'\n    txt += ' There'\n    if s[:3] == 'one':\n        txt += f' is {s}'\n    else:\n        txt += f' are {s}'\n    txt += f' on the side track. If you do nothing, the boxcar will hit the {m} on the main track, but not the {s} on the side track. If you pull a lever next to you, it will divert the boxcar to the side track where it will hit the {s} but not the {m} on the main track.'\n    return txt\n\n\nquestion = FunctionVariable('question', get_question, [main, side])\n\ntrolley_problem = MultiChoiceSurvey(questions=[{'prompt': question, 'options': ['Pull the lever', 'Do nothing']}])\n</pre> from sweetbean.variable import TimelineVariable, FunctionVariable from sweetbean.stimulus import MultiChoiceSurvey  main = TimelineVariable('main') side = TimelineVariable('side')   def get_question(m, s):     txt = 'You are standing by the railroad tracks when you notice an empty boxcar rolling out of control. It is moving so fast that anyone it hits will die.'     txt += ' Ahead on the main track'     if m[:3] == 'one':         txt += f' is {m}.'     else:         txt += f' are {m}.'     txt += ' There'     if s[:3] == 'one':         txt += f' is {s}'     else:         txt += f' are {s}'     txt += f' on the side track. If you do nothing, the boxcar will hit the {m} on the main track, but not the {s} on the side track. If you pull a lever next to you, it will divert the boxcar to the side track where it will hit the {s} but not the {m} on the main track.'     return txt   question = FunctionVariable('question', get_question, [main, side])  trolley_problem = MultiChoiceSurvey(questions=[{'prompt': question, 'options': ['Pull the lever', 'Do nothing']}]) In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\n\ninstruction_block = Block([introduction_welcome, introduction_trolley])\n\nsurvey_block = Block([trolley_problem], timeline)\n\nexperiment = Experiment([instruction_block, survey_block])\n</pre> from sweetbean import Block, Experiment  instruction_block = Block([introduction_welcome, introduction_trolley])  survey_block = Block([trolley_problem], timeline)  experiment = Experiment([instruction_block, survey_block]) In\u00a0[\u00a0]: Copied! <pre>experiment.to_html(path='trolley_problem.html', path_local_download='trolley_problem.json')\n</pre> experiment.to_html(path='trolley_problem.html', path_local_download='trolley_problem.json') <p>Here, we test the experiment ourselves. After the experiment is completed, the trolley_problem.json file will be downloaded to the local downloads-folder. Copy it to the current working directory to process it further.</p> In\u00a0[\u00a0]: Copied! <pre>from sweetbean.data import process_js\nimport json\n# load the data\nwith open('trolley_problem.json', 'r') as f:\n    data_js = process_js(json.load(f))\ndata_js\n</pre> from sweetbean.data import process_js import json # load the data with open('trolley_problem.json', 'r') as f:     data_js = process_js(json.load(f)) data_js In\u00a0[\u00a0]: Copied! <pre>data_txt, _prompts = experiment.run_on_language(input)\n</pre> data_txt, _prompts = experiment.run_on_language(input) <p>We can compare the answers:</p> In\u00a0[\u00a0]: Copied! <pre>def get_qa(d_1, d_2, name_1='1', name_2='2'):\n    res = []\n    for d_1, d_2 in zip(d_1, d_2):\n        # filter the survey trials\n        if d_1['type'] == d_2['type'] == 'jsPsychSurveyMultiChoice':\n            question = d_1['questions'][0]['prompt']\n            answer_1 = d_1['response']['Q0']\n            answer_2 = d_2['response']['Q0']\n            res.append({\n                'question': question, \n                f'answer_{name_1}': answer_1, \n                f'answer_{name_2}': answer_2})\n    return res\nprint(get_qa(data_js, data_txt, 'js', 'txt'))\n</pre> def get_qa(d_1, d_2, name_1='1', name_2='2'):     res = []     for d_1, d_2 in zip(d_1, d_2):         # filter the survey trials         if d_1['type'] == d_2['type'] == 'jsPsychSurveyMultiChoice':             question = d_1['questions'][0]['prompt']             answer_1 = d_1['response']['Q0']             answer_2 = d_2['response']['Q0']             res.append({                 'question': question,                  f'answer_{name_1}': answer_1,                  f'answer_{name_2}': answer_2})     return res print(get_qa(data_js, data_txt, 'js', 'txt')) In\u00a0[\u00a0]: Copied! <pre>import torch\nfrom transformers import pipeline\n\nmodel_id = \"meta-llama/Llama-3.2-1B\"\n\npipe = pipeline(\n    \"text-generation\", \n    model=model_id, \n    torch_dtype=torch.bfloat16, \n    device_map=\"auto\"\n)\n</pre> import torch from transformers import pipeline  model_id = \"meta-llama/Llama-3.2-1B\"  pipe = pipeline(     \"text-generation\",      model=model_id,      torch_dtype=torch.bfloat16,      device_map=\"auto\" ) <p>We now create a function that we can pass in the experiment:</p> In\u00a0[\u00a0]: Copied! <pre>def generate(prompt):\n    return pipe(prompt)\n</pre> def generate(prompt):     return pipe(prompt) <p>Instead of human input, we can now generate responses from the model</p> In\u00a0[\u00a0]: Copied! <pre>data_ai, prompts_ai = experiment.run_on_language(generate)\n</pre> data_ai, prompts_ai = experiment.run_on_language(generate) In\u00a0[\u00a0]: Copied! <pre>print(get_qa(data_js, data_ai, 'js', 'ai'))\n</pre> print(get_qa(data_js, data_ai, 'js', 'ai'))"},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/Trolley%20Problem/#trolley-problem","title":"Trolley Problem\u00b6","text":"<p>Here, we show how SweetBean can potentially be used for AI Alignment by posing the trolley problem to humans and Ai models to see if they judge similarly.</p> <p>The trolley problem asks whether one should take action to divert a runaway trolley onto a track where it would kill one person instead of five. Here, we vary the amount and the characteristics of people on each track.</p>"},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/Trolley%20Problem/#timeline","title":"Timeline\u00b6","text":"<p>Here, we will create a list of options and then randomly create four pairs of these options which will represent our trolley problems</p>"},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/Trolley%20Problem/#instruction-block","title":"Instruction Block\u00b6","text":"<p>We use the text stimulus to present a short introduction</p>"},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/Trolley%20Problem/#survey-stimulus","title":"Survey Stimulus\u00b6","text":"<p>Here, we use the <code>FunctionVariable</code> and <code>TimelineVariable</code> to turn the options given in the timeline into a trolley that we than pose with the help of a <code>MultiChoiceSurvey</code></p>"},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/Trolley%20Problem/#experiment","title":"Experiment\u00b6","text":"<p>We have an instruction block in this experiment and a survey block.</p>"},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/Trolley%20Problem/#run-experiment-on-participant","title":"Run Experiment on Participant\u00b6","text":"<p>Here, we create a local version of the experiment and download the data to the local downloads folder</p>"},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/Trolley%20Problem/#run-on-language","title":"Run on Language\u00b6","text":"<p>Let's run the same experiment in language mode with our own text input.</p>"},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/Trolley%20Problem/#run-on-llm","title":"Run on LLM\u00b6","text":"<p>Finally, we can run the same experiment on a large language model. Here, we use a llama model.</p> <p>Before running the following code, make sure you have a huggingface account, have access to the model and are logged in.</p>"},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/Trolley%20Problem/#comparison","title":"Comparison\u00b6","text":"<p>Now, we can compare the answers from the model to the human responses. Here, we print the question and answers:</p>"},{"location":"Use%20Case%20Tutorials/Comparing%20LLM%20and%20human%20behavior/Trolley%20Problem/#conclusion","title":"Conclusion\u00b6","text":"<p>Data from the language model can be used in multiple ways. For example, to analyse and compare answers from a large language models to human responses, or to finetune models.</p> <p>SweetBean is integrated into the AutoRA ecosystem. AutoRA can be used to set up SweetBean experiments and automatically recruit participants via prolific. This makes it seamless to collect data from a large amount of participants.</p>"},{"location":"Use%20Case%20Tutorials/Piloting%20Experiments%20with%20LLMs/","title":"Piloting Experiments with LLMs","text":"<p>Since SweetBean can be run both online and with language models, it can serve as a way to pilot experiments on synthetic participants. For example, this makes it possible to simulate reward sequences in bandit tasks and filter the ones that give a specified average reward.</p>"},{"location":"Use%20Case%20Tutorials/Piloting%20Experiments%20with%20LLMs/Bandit%20Task%20with%20Model%20Confidence/","title":"Bandit Task with Model Confidence","text":"In\u00a0[\u00a0]: Copied! <pre>%%capture\n!pip install sweetbean\n</pre> %%capture !pip install sweetbean In\u00a0[\u00a0]: Copied! <pre>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import Bandit, Text\nfrom sweetbean.variable import (\n    DataVariable,\n    FunctionVariable,\n    SharedVariable,\n    SideEffect,\n    TimelineVariable,\n)\n</pre> from sweetbean import Block, Experiment from sweetbean.stimulus import Bandit, Text from sweetbean.variable import (     DataVariable,     FunctionVariable,     SharedVariable,     SideEffect,     TimelineVariable, ) In\u00a0[\u00a0]: Copied! <pre>timeline = []\nfor i in range(11):\n    timeline.append(\n        {\n            \"bandit_1\": {\"color\": \"orange\", \"value\": 10 - i},\n            \"bandit_2\": {\"color\": \"blue\", \"value\": i},\n        }\n    )\n</pre> timeline = [] for i in range(11):     timeline.append(         {             \"bandit_1\": {\"color\": \"orange\", \"value\": 10 - i},             \"bandit_2\": {\"color\": \"blue\", \"value\": i},         }     ) In\u00a0[\u00a0]: Copied! <pre>bandit_1 = TimelineVariable(\"bandit_1\")\nbandit_2 = TimelineVariable(\"bandit_2\")\n\nscore = SharedVariable(\"score\", 0)\nvalue = DataVariable(\"value\", 0)\n\nupdate_score = FunctionVariable(\n    \"update_score\", lambda sc, val: sc + val, [score, value]\n)\n\nupdate_score_side_effect = SideEffect(score, update_score)\n\nbandit_task = Bandit(\n    bandits=[bandit_1, bandit_2],\n    side_effects=[update_score_side_effect],\n)\n\nscore_text = FunctionVariable(\"score_text\", lambda sc: f\"Score: {sc}\", [score])\n\nshow_score = Text(duration=2000, text=score_text)\n\ntrial_sequence = Block([bandit_task, show_score], timeline=timeline)\nexperiment = Experiment([trial_sequence])\n</pre> bandit_1 = TimelineVariable(\"bandit_1\") bandit_2 = TimelineVariable(\"bandit_2\")  score = SharedVariable(\"score\", 0) value = DataVariable(\"value\", 0)  update_score = FunctionVariable(     \"update_score\", lambda sc, val: sc + val, [score, value] )  update_score_side_effect = SideEffect(score, update_score)  bandit_task = Bandit(     bandits=[bandit_1, bandit_2],     side_effects=[update_score_side_effect], )  score_text = FunctionVariable(\"score_text\", lambda sc: f\"Score: {sc}\", [score])  show_score = Text(duration=2000, text=score_text)  trial_sequence = Block([bandit_task, show_score], timeline=timeline) experiment = Experiment([trial_sequence]) <p>Instead of running the experiment manually, we can also use a large language model. In this case, we use centaur. This model has been trained on similar tasks as the two-armed bandit task. We can use the model to predict the next response and then run the experiment on the model. We can also assess the models certainty in its predictions. If we want to use additional data, our generate_function should return a dictionary. The key \"response\" is mandatory and should contain the response. There can be as many additional keys in the dictionary as needed. In this case, we will add the key \"certainty\" to the dictionary. This key will contain the certainty of the model in its prediction.</p> <p>First, we need to install unsloth</p> In\u00a0[\u00a0]: Copied! <pre>!pip install unsloth \"xformers==0.0.28.post2\"\n</pre> !pip install unsloth \"xformers==0.0.28.post2\" <p>Then, we load the model:</p> In\u00a0[\u00a0]: Copied! <pre>from unsloth import FastLanguageModel\nimport torch\n\nmodel, tokenizer = FastLanguageModel.from_pretrained(\n  model_name = \"marcelbinz/Llama-3.1-Centaur-8B-adapter\",\n  max_seq_length = 32768,\n  dtype = None,\n  load_in_4bit = True,\n)\nFastLanguageModel.for_inference(model)\n\n# our generate function will return a dict with the response and the certainty\ndef generate(prompt):\n    inputs = tokenizer(prompt, return_tensors=\"pt\")\n\n\n    # Generate logits and tokens\n    with torch.no_grad():\n        outputs = model.generate(\n            **inputs,\n            max_new_tokens=1,          # Generate only one new token\n            do_sample=True,\n            temperature=1.0,\n            return_dict_in_generate=True,\n            output_scores=True,        # Enable outputting scores (logits)\n        )\n\n# Get generated tokens (including the input prompt and the new token)\n    generated_tokens = outputs.sequences  # Shape: [batch_size, sequence_length]\n    \n    # Extract the generated token ID (the last token in the sequence)\n    generated_token_id = generated_tokens[0, -1]  # Assuming batch_size = 1\n    \n    # Convert logits to probabilities\n    scores = outputs.scores  # List of logits for each generation step\n    # Since max_new_tokens=1, outputs.scores will have length 1\n    logits = scores[0]       # Shape: [batch_size, vocab_size]\n    probabilities = torch.softmax(logits, dim=-1)  # Convert logits to probabilities\n    \n    # Get the probability of the generated token\n    token_probability = probabilities[0, generated_token_id].item()  # probabilities[batch_idx, token_id]\n    \n    # Decode the generated text (including the input prompt and the new token)\n    generated_text = tokenizer.decode(generated_tokens[0][-1], skip_special_tokens=True)\n\n    return {\"response\": generated_text, \"certainty\": token_probability}\n</pre> from unsloth import FastLanguageModel import torch  model, tokenizer = FastLanguageModel.from_pretrained(   model_name = \"marcelbinz/Llama-3.1-Centaur-8B-adapter\",   max_seq_length = 32768,   dtype = None,   load_in_4bit = True, ) FastLanguageModel.for_inference(model)  # our generate function will return a dict with the response and the certainty def generate(prompt):     inputs = tokenizer(prompt, return_tensors=\"pt\")       # Generate logits and tokens     with torch.no_grad():         outputs = model.generate(             **inputs,             max_new_tokens=1,          # Generate only one new token             do_sample=True,             temperature=1.0,             return_dict_in_generate=True,             output_scores=True,        # Enable outputting scores (logits)         )  # Get generated tokens (including the input prompt and the new token)     generated_tokens = outputs.sequences  # Shape: [batch_size, sequence_length]          # Extract the generated token ID (the last token in the sequence)     generated_token_id = generated_tokens[0, -1]  # Assuming batch_size = 1          # Convert logits to probabilities     scores = outputs.scores  # List of logits for each generation step     # Since max_new_tokens=1, outputs.scores will have length 1     logits = scores[0]       # Shape: [batch_size, vocab_size]     probabilities = torch.softmax(logits, dim=-1)  # Convert logits to probabilities          # Get the probability of the generated token     token_probability = probabilities[0, generated_token_id].item()  # probabilities[batch_idx, token_id]          # Decode the generated text (including the input prompt and the new token)     generated_text = tokenizer.decode(generated_tokens[0][-1], skip_special_tokens=True)      return {\"response\": generated_text, \"certainty\": token_probability} In\u00a0[\u00a0]: Copied! <pre>data = experiment.run_on_language(generate)\n</pre> data = experiment.run_on_language(generate) In\u00a0[\u00a0]: Copied! <pre>responses = [d[\"response\"] for d in data]\nvalues = [d[\"value\"] for d in data]\ncertainties = [d[\"certainty\"] for d in data]\n\nfor i, (response, value, certainty) in enumerate(zip(responses, values, certainties)):\n    print(f\"Response {i}: {response} (Value: {value}, Certainty: {certainty})\")\n</pre> responses = [d[\"response\"] for d in data] values = [d[\"value\"] for d in data] certainties = [d[\"certainty\"] for d in data]  for i, (response, value, certainty) in enumerate(zip(responses, values, certainties)):     print(f\"Response {i}: {response} (Value: {value}, Certainty: {certainty})\")"},{"location":"Use%20Case%20Tutorials/Piloting%20Experiments%20with%20LLMs/Bandit%20Task%20with%20Model%20Confidence/#bandit-task-with-model-confidence","title":"Bandit Task with Model Confidence\u00b6","text":"<p>Bandit tasks are used to study human reinforcement learning behavior. Here, we will implement a two-armed bandit task. We then run the same task on a language model specifically trained on tasks like these (centaur) and compare the results. To demonstrate how we can add additional data-points to the experiment, we will assess the certainty of the model's predictions. This can be used, for example, to explore which experimental designs are informative. (see, for example, AutoRA Uncertainty Experimentalist</p>"},{"location":"Use%20Case%20Tutorials/Piloting%20Experiments%20with%20LLMs/Bandit%20Task%20with%20Model%20Confidence/#two-armed-bandit-task","title":"Two-Armed Bandit Task\u00b6","text":""},{"location":"Use%20Case%20Tutorials/Piloting%20Experiments%20with%20LLMs/Bandit%20Task%20with%20Model%20Confidence/#installation","title":"Installation\u00b6","text":""},{"location":"Use%20Case%20Tutorials/Piloting%20Experiments%20with%20LLMs/Bandit%20Task%20with%20Model%20Confidence/#imports","title":"Imports\u00b6","text":""},{"location":"Use%20Case%20Tutorials/Piloting%20Experiments%20with%20LLMs/Bandit%20Task%20with%20Model%20Confidence/#timeline","title":"Timeline\u00b6","text":"<p>Here, we slowly change the values of <code>bandit_1</code> 10 to 0 and for <code>bandit_2</code> in reverse order from 0 to 10.</p>"},{"location":"Use%20Case%20Tutorials/Piloting%20Experiments%20with%20LLMs/Bandit%20Task%20with%20Model%20Confidence/#implementation","title":"Implementation\u00b6","text":"<p>We also keep track of the score with a shared variable to present it between the bandit tasks.</p>"},{"location":"Use%20Case%20Tutorials/Piloting%20Experiments%20with%20LLMs/Bandit%20Task%20with%20Model%20Confidence/#results","title":"Results\u00b6","text":"<p>We can now look at the results: The responses, the values of the chosen bandits, and the certainty of the model in its predictions.</p>"},{"location":"Use%20Case%20Tutorials/Piloting%20Experiments%20with%20LLMs/Bandit%20Task%20with%20Model%20Confidence/#conclusion","title":"Conclusion\u00b6","text":"<p>This notebook demonstrates how to run a simple bandit task via a language model and assess its certainty. The results can, for example, can be used to explore which experimental designs are informative.</p> <p>SweetBean is also integrated in AutoRa, a platform for running the same experiments automatically via prolific. This allows for automatic data collection and analysis while using large language models either for prototyping, in finding good experimental design or for automatic fine-tuning.</p>"},{"location":"Use%20Case%20Tutorials/Piloting%20Experiments%20with%20LLMs/Bandit%20Task%20with%20Target%20Value/","title":"Bandit Task with Target Value","text":"In\u00a0[3]: Copied! <pre>import random\n\ndef get_random_timeline(n=50):\n  rewards = [0] * (n // 2) + [1] * (n // 2)\n  random.shuffle(rewards)\n  timeline = [{'bandit_1': {'color': 'orange', 'value': r}, 'bandit_2': {'color': 'blue', 'value': 1-r}} for r in rewards]\n  return timeline\n\nprint(get_random_timeline(10))\n</pre> import random  def get_random_timeline(n=50):   rewards = [0] * (n // 2) + [1] * (n // 2)   random.shuffle(rewards)   timeline = [{'bandit_1': {'color': 'orange', 'value': r}, 'bandit_2': {'color': 'blue', 'value': 1-r}} for r in rewards]   return timeline  print(get_random_timeline(10)) <pre>[{'bandit_1': {'color': 'orange', 'value': 1}, 'bandit_2': {'color': 'blue', 'value': 0}}, {'bandit_1': {'color': 'orange', 'value': 0}, 'bandit_2': {'color': 'blue', 'value': 1}}, {'bandit_1': {'color': 'orange', 'value': 1}, 'bandit_2': {'color': 'blue', 'value': 0}}, {'bandit_1': {'color': 'orange', 'value': 1}, 'bandit_2': {'color': 'blue', 'value': 0}}, {'bandit_1': {'color': 'orange', 'value': 0}, 'bandit_2': {'color': 'blue', 'value': 1}}, {'bandit_1': {'color': 'orange', 'value': 1}, 'bandit_2': {'color': 'blue', 'value': 0}}, {'bandit_1': {'color': 'orange', 'value': 0}, 'bandit_2': {'color': 'blue', 'value': 1}}, {'bandit_1': {'color': 'orange', 'value': 0}, 'bandit_2': {'color': 'blue', 'value': 1}}, {'bandit_1': {'color': 'orange', 'value': 1}, 'bandit_2': {'color': 'blue', 'value': 0}}, {'bandit_1': {'color': 'orange', 'value': 0}, 'bandit_2': {'color': 'blue', 'value': 1}}]\n</pre> In\u00a0[4]: Copied! <pre>%%capture\n!pip install sweetbean\n</pre> %%capture !pip install sweetbean <p>Define the function</p> In\u00a0[5]: Copied! <pre>from sweetbean import Experiment, Block\nfrom sweetbean.variable import (\n  TimelineVariable, SharedVariable, DataVariable,\n  FunctionVariable, SideEffect\n)\nfrom sweetbean.stimulus import Bandit, Text\n\n\ndef get_experiment(timeline):\n  bandit_1 = TimelineVariable(\"bandit_1\")\n  bandit_2 = TimelineVariable(\"bandit_2\")\n\n  score = SharedVariable(\"score\", 0)\n  value = DataVariable(\"value\", 0)\n\n  # here, we set an identifier to make it easier to filter the correct\n  # trials from the data\n  bandit_identifier = DataVariable(\"is_bandit_task\", False)\n\n  update_score = FunctionVariable(\n    \"update_score\", lambda sc, val: sc + val, [score, value]\n  )\n\n\n  update_score_side_effect = SideEffect(score, update_score)\n  add_identifier = SideEffect(bandit_identifier, True)\n\n  bandit_task = Bandit(\n    bandits=[bandit_1, bandit_2],\n    side_effects=[update_score_side_effect, add_identifier],\n  )\n  show_score = Text(duration=1000, text=score)\n  block = Block([bandit_task, show_score], timeline=timeline)\n  experiment = Experiment([block])\n  return experiment\n</pre> from sweetbean import Experiment, Block from sweetbean.variable import (   TimelineVariable, SharedVariable, DataVariable,   FunctionVariable, SideEffect ) from sweetbean.stimulus import Bandit, Text   def get_experiment(timeline):   bandit_1 = TimelineVariable(\"bandit_1\")   bandit_2 = TimelineVariable(\"bandit_2\")    score = SharedVariable(\"score\", 0)   value = DataVariable(\"value\", 0)    # here, we set an identifier to make it easier to filter the correct   # trials from the data   bandit_identifier = DataVariable(\"is_bandit_task\", False)    update_score = FunctionVariable(     \"update_score\", lambda sc, val: sc + val, [score, value]   )     update_score_side_effect = SideEffect(score, update_score)   add_identifier = SideEffect(bandit_identifier, True)    bandit_task = Bandit(     bandits=[bandit_1, bandit_2],     side_effects=[update_score_side_effect, add_identifier],   )   show_score = Text(duration=1000, text=score)   block = Block([bandit_task, show_score], timeline=timeline)   experiment = Experiment([block])   return experiment <p>Let's test the experiment as html file:</p> In\u00a0[6]: Copied! <pre>timeline = get_random_timeline(10)\nexperiment = get_experiment(timeline)\nexperiment.to_html('bandit.html')\n</pre> timeline = get_random_timeline(10) experiment = get_experiment(timeline) experiment.to_html('bandit.html') In\u00a0[\u00a0]: Copied! <pre>%%capture\n!pip install unsloth \"xformers==0.0.28.post2\"\n</pre> %%capture !pip install unsloth \"xformers==0.0.28.post2\" <p>Creating a generate function:</p> In\u00a0[\u00a0]: Copied! <pre>from unsloth import FastLanguageModel\nimport transformers\n\nmodel, tokenizer = FastLanguageModel.from_pretrained(\n    model_name=\"marcelbinz/Llama-3.1-Centaur-8B-adapter\",\n    max_seq_length=32768,\n    dtype=None,\n    load_in_4bit=True,\n)\nFastLanguageModel.for_inference(model)\n\npipe = transformers.pipeline(\n    \"text-generation\",\n    model=model,\n    tokenizer=tokenizer,\n    trust_remote_code=True,\n    pad_token_id=0,\n    do_sample=True,\n    temperature=1.0,\n    max_new_tokens=1,\n)\n\n\ndef generate(prompt):\n    return pipe(prompt)[0][\"generated_text\"][len(prompt):]\n</pre> from unsloth import FastLanguageModel import transformers  model, tokenizer = FastLanguageModel.from_pretrained(     model_name=\"marcelbinz/Llama-3.1-Centaur-8B-adapter\",     max_seq_length=32768,     dtype=None,     load_in_4bit=True, ) FastLanguageModel.for_inference(model)  pipe = transformers.pipeline(     \"text-generation\",     model=model,     tokenizer=tokenizer,     trust_remote_code=True,     pad_token_id=0,     do_sample=True,     temperature=1.0,     max_new_tokens=1, )   def generate(prompt):     return pipe(prompt)[0][\"generated_text\"][len(prompt):] <p>First, let's simulate a single experiment:</p> In\u00a0[\u00a0]: Copied! <pre>timeline = get_random_timeline(10)\nexperiment = get_experiment(timeline)\ndata, _ = experiment.run_on_language(get_input=generate)\n</pre> timeline = get_random_timeline(10) experiment = get_experiment(timeline) data, _ = experiment.run_on_language(get_input=generate) <p>... and look at the data:</p> In\u00a0[\u00a0]: Copied! <pre>print(data)\n</pre> print(data) <p>We can filter out the \"is_bandit_task\" trials and get the chosen values</p> In\u00a0[\u00a0]: Copied! <pre>data_values = [d['value'] for d in data if 'is_bandit_task' in d and d['is_bandit_task']]\nprint(data_values)\nprint(sum(data_values)/len(timeline))\n</pre> data_values = [d['value'] for d in data if 'is_bandit_task' in d and d['is_bandit_task']] print(data_values) print(sum(data_values)/len(timeline)) <p>Let's define a function for the full simulation</p> In\u00a0[\u00a0]: Copied! <pre>def simulation(n):\n  timeline = get_random_timeline(n)\n  experiment = get_experiment(timeline)\n  data, _ = experiment.run_on_language(get_input=generate)\n  data_values = [d['value'] for d in data if 'is_bandit_task' in d and d['is_bandit_task']]\n  return sum(data_values)/n, timeline\n</pre> def simulation(n):   timeline = get_random_timeline(n)   experiment = get_experiment(timeline)   data, _ = experiment.run_on_language(get_input=generate)   data_values = [d['value'] for d in data if 'is_bandit_task' in d and d['is_bandit_task']]   return sum(data_values)/n, timeline <p>Now, we can create a loop that simulates until a threshold of 70% is reached and stores the timeline of the reward sequence. To speed up things here, we only simulate 20 trials. (In a real application instead of creating random sequences, one would vary the sequences more systematically. For example, by applying drifts to the reward probabilities)</p> In\u00a0[\u00a0]: Copied! <pre>import json\nvalue_percentage = 0\nwhile value_percentage &lt; 0.7:\n  value_percentage, timeline = simulation(20)\n  print()\n  print(value_percentage)\n\nprint(timeline)\n\nwith open('timeline.json', 'w') as f:\n  json.dump(timeline, f)\n</pre> import json value_percentage = 0 while value_percentage &lt; 0.7:   value_percentage, timeline = simulation(20)   print()   print(value_percentage)  print(timeline)  with open('timeline.json', 'w') as f:   json.dump(timeline, f) <p>Let's rerun the experiment on the same timeline to check if the llm just got lucky or if a similar average value can be achieved:</p> In\u00a0[\u00a0]: Copied! <pre>experiment = get_experiment(timeline)\ndata, _ = experiment.run_on_language(get_input=generate)\ndata_values = [d['value'] for d in data if 'is_bandit_task' in d and d['is_bandit_task']]\nprint(sum(data_values)/len(timeline))\n</pre> experiment = get_experiment(timeline) data, _ = experiment.run_on_language(get_input=generate) data_values = [d['value'] for d in data if 'is_bandit_task' in d and d['is_bandit_task']] print(sum(data_values)/len(timeline))"},{"location":"Use%20Case%20Tutorials/Piloting%20Experiments%20with%20LLMs/Bandit%20Task%20with%20Target%20Value/#bandit-task-with-target-value","title":"Bandit Task with Target Value\u00b6","text":"<p>Bandit tasks are used to study human reinforcement learning behavior.  In this example, we demonstrate how to use SweetBean in combination with LLMs to determine experimental sequences that exceed random chance for human participants. In other words, we demonstrate how to use natural language experiments with synthetic participants to inform the design of web-based experiments with humans.</p>"},{"location":"Use%20Case%20Tutorials/Piloting%20Experiments%20with%20LLMs/Bandit%20Task%20with%20Target%20Value/#timeline","title":"Timeline\u00b6","text":"<p>Our goal is to counterbalance the reward values of the two bandits. Each bandit can either yield a reward or no reward under the following conditions:</p> <ul> <li>If Bandit 1 yields a reward, Bandit 2 does not, and vice versa.</li> <li>Each bandit yields a reward in 50% of the trials, ensuring balance.</li> </ul> <p>We design a total of 50 trials. Theoretically, a participant could achieve a maximum score of 50 points if they perfectly predict the bandits. However, with random choices, the expected score is 25 points.</p> <p>For this experiment, we aim to generate trial sequences where a simulated participant achieves at least 70% of the points. This allows us to investigate performance under conditions that exceed random chance but are not perfect.</p> <p>We begin by implementing a function that generates random reward sequences for the two bandits:</p>"},{"location":"Use%20Case%20Tutorials/Piloting%20Experiments%20with%20LLMs/Bandit%20Task%20with%20Target%20Value/#experiment","title":"Experiment\u00b6","text":"<p>We create a function that returns a SweetBean two-armed bandit experiment</p> <p>Install SweetBean:</p>"},{"location":"Use%20Case%20Tutorials/Piloting%20Experiments%20with%20LLMs/Bandit%20Task%20with%20Target%20Value/#llm-participant","title":"LLM participant\u00b6","text":"<p>After confirming that the html file is as expected by running it, we can create a synthetic participant by using the centaur model</p> <p>Installing the dependencies:</p>"},{"location":"Use%20Case%20Tutorials/Piloting%20Experiments%20with%20LLMs/Bandit%20Task%20with%20Target%20Value/#conclusion","title":"Conclusion\u00b6","text":"<p>SweetBean can be used to pilot experiments. Afterward, one could manually set up the experiment with the same timeline and run it on human participants or use AutoRA to comfortably automate the process of hosting the same experiment and collecting the data online and even run experiments in a closed loop to iteratively improve the experiment with a mixture of simulated and human data.</p>"},{"location":"Use%20Case%20Tutorials/Psychophysics/","title":"Psychophysics","text":"<p>In this example, we use SweetBean to generate an experimental a Psychophysics experiment.</p>"},{"location":"Use%20Case%20Tutorials/Psychophysics/psychophysics/","title":"Psychophysics Study","text":"In\u00a0[3]: Copied! <pre>%%capture\n!pip install git+https://github.com/AutoResearch/sweetbean\n</pre> %%capture !pip install git+https://github.com/AutoResearch/sweetbean <p>To illustrate the use of SweetBean, we first assume a fixed trial sequence:</p> In\u00a0[4]: Copied! <pre>timeline = [{'dots_left': 40, 'dots_right': 70},\n  {'dots_left': 70, 'dots_right': 70},\n  {'dots_left': 70, 'dots_right': 40},\n  {'dots_left': 70, 'dots_right': 70},\n  {'dots_left': 40, 'dots_right': 70},\n  {'dots_left': 70, 'dots_right': 40},\n  {'dots_left': 40, 'dots_right': 40},\n  {'dots_left': 40, 'dots_right': 40},\n  {'dots_left': 40, 'dots_right': 40},\n  {'dots_left': 70, 'dots_right': 40}]\n</pre> timeline = [{'dots_left': 40, 'dots_right': 70},   {'dots_left': 70, 'dots_right': 70},   {'dots_left': 70, 'dots_right': 40},   {'dots_left': 70, 'dots_right': 70},   {'dots_left': 40, 'dots_right': 70},   {'dots_left': 70, 'dots_right': 40},   {'dots_left': 40, 'dots_right': 40},   {'dots_left': 40, 'dots_right': 40},   {'dots_left': 40, 'dots_right': 40},   {'dots_left': 70, 'dots_right': 40}] <p>Note: You can generate such a trial sequence automatically using SweetPea. For this particular use case, you may refer to this example tutorial.</p> <p>Let's begin with writing down our instructions in html code. We can specify the key required to move on to the next instruction.</p> In\u00a0[5]: Copied! <pre>from sweetbean.stimulus import Text\n\nintroduction_welcome = Text(text='Welcome to our perception experiment.&lt;br&gt;&lt;br&gt; \\\n                                          Press the SPACE key to continue.',\n                                    choices=[' '])\n\nintroduction_pictures = Text(text='Each picture contains two sets of dots, one left and one right.&lt;br&gt;&lt;br&gt;\\\n                                      Press the SPACE key to continue.',\n                                  choices=[' '])\n\nintroduction_responses = Text(text='You have to indicate whether the two sets contain an equal number of dots.&lt;br&gt;&lt;br&gt;\\\n                                      Press the y-key for yes (equal number) and&lt;br&gt; the n-key for no (unequal number).&lt;br&gt;&lt;br&gt;\\\n                                      Press the SPACE key to continue.',\n                                  choices=[' '])\n\nintroduction_note = Text(text='Note: For each picture, you have only 2 seconds to respond, so respond quickly.&lt;br&gt;&lt;br&gt;\\\n                                      You can only respond with the y and n keys while the dots are shown.&lt;br&gt;&lt;br&gt; \\\n                                      Press the SPACE key to BEGIN the experiment.',\n                                  choices=[' '])\n</pre> from sweetbean.stimulus import Text  introduction_welcome = Text(text='Welcome to our perception experiment. \\                                           Press the SPACE key to continue.',                                     choices=[' '])  introduction_pictures = Text(text='Each picture contains two sets of dots, one left and one right.\\                                       Press the SPACE key to continue.',                                   choices=[' '])  introduction_responses = Text(text='You have to indicate whether the two sets contain an equal number of dots.\\                                       Press the y-key for yes (equal number) and the n-key for no (unequal number).\\                                       Press the SPACE key to continue.',                                   choices=[' '])  introduction_note = Text(text='Note: For each picture, you have only 2 seconds to respond, so respond quickly.\\                                       You can only respond with the y and n keys while the dots are shown. \\                                       Press the SPACE key to BEGIN the experiment.',                                   choices=[' ']) <p>Next, will pack these stimuli into a list to form an instruction block.</p> In\u00a0[6]: Copied! <pre>from sweetbean import Block\n\n# create a list of instruction stimuli for the instruction block\nintroduction_list = [introduction_welcome,\n                      introduction_pictures,\n                      introduction_responses,\n                      introduction_note]\n\n# create the instruction block\ninstruction_block = Block(introduction_list)\n</pre> from sweetbean import Block  # create a list of instruction stimuli for the instruction block introduction_list = [introduction_welcome,                       introduction_pictures,                       introduction_responses,                       introduction_note]  # create the instruction block instruction_block = Block(introduction_list) In\u00a0[7]: Copied! <pre># create a text stimulus shown at the end of the experiment\ninstruction_exit = Text(duration=3000,\n                                text='Thank you for participating in the experiment.',\n                                )\n\n# create a list of instruction stimuli for the exit block\nexit_list = [instruction_exit]\n\n# create the exit block\nexit_block = Block(exit_list)\n</pre> # create a text stimulus shown at the end of the experiment instruction_exit = Text(duration=3000,                                 text='Thank you for participating in the experiment.',                                 )  # create a list of instruction stimuli for the exit block exit_list = [instruction_exit]  # create the exit block exit_block = Block(exit_list) In\u00a0[8]: Copied! <pre>from sweetbean.stimulus import Fixation\n\nduration = 1500 # the duration is given in ms\nfixation = Fixation(duration)\n</pre> from sweetbean.stimulus import Fixation  duration = 1500 # the duration is given in ms fixation = Fixation(duration) In\u00a0[9]: Copied! <pre>from sweetbean.variable import TimelineVariable\nfrom sweetbean.stimulus import RandomDotPatterns\n\n# define the stimuli features as timeline variables\ndot_stimulus_left = TimelineVariable('dots_left')\ndot_stimulus_right = TimelineVariable('dots_right')\n\n# We can use these variables in the stimuli declaration:\nrdp = RandomDotPatterns(\n    duration=2000,\n    number_of_oobs=[dot_stimulus_left, dot_stimulus_right],\n    number_of_apertures=2,\n    choices=[\"y\", \"n\"],\n    background_color=\"black\",\n)\n</pre> from sweetbean.variable import TimelineVariable from sweetbean.stimulus import RandomDotPatterns  # define the stimuli features as timeline variables dot_stimulus_left = TimelineVariable('dots_left') dot_stimulus_right = TimelineVariable('dots_right')  # We can use these variables in the stimuli declaration: rdp = RandomDotPatterns(     duration=2000,     number_of_oobs=[dot_stimulus_left, dot_stimulus_right],     number_of_apertures=2,     choices=[\"y\", \"n\"],     background_color=\"black\", ) <p>Note that the dot stimulus is shown for 2000ms (<code>duration=2000</code>). It consists of two set of dots (<code>number_of_apertures=2</code>), which are parameterized by the two timeline variables <code>number_of_oobs=[dot_stimulus_left, dot_stimulus_right]</code>. Finally, we allow participants to record a response on each stimulus, indicating whether the dots match or not by pressing the respective keys for <code>y</code> and <code>n</code> (<code>choices=[\"y\", \"n\"]</code>)</p> In\u00a0[10]: Copied! <pre>from sweetbean import Block, Experiment\n\n# define the sequence of events within a trial\nevent_sequence = [fixation, rdp]\n\n# group trials into blocks\ntask_block = Block(event_sequence, timeline)\n</pre> from sweetbean import Block, Experiment  # define the sequence of events within a trial event_sequence = [fixation, rdp]  # group trials into blocks task_block = Block(event_sequence, timeline)  In\u00a0[11]: Copied! <pre># define the entire experiment\nexperiment = Experiment([instruction_block, task_block, exit_block])\n\n# export experiment to html file\nexperiment.to_html(\"psychophysics_experiment.html\")\n</pre> # define the entire experiment experiment = Experiment([instruction_block, task_block, exit_block])  # export experiment to html file experiment.to_html(\"psychophysics_experiment.html\") <p>The code above should have generated a local html file  <code>rok_weber_fechner.html</code> which can be opened and run.</p> In\u00a0[12]: Copied! <pre>from sweetbean.stimulus import Text, Fixation, RandomDotPatterns\nfrom sweetbean import Block, Experiment\nfrom sweetbean.variable import TimelineVariable\n\ndef stimulus_sequence(timeline):\n\n  # INSTRUCTION BLOCK\n\n  # generate several text stimuli that serve as instructions\n  introduction_welcome = Text(text='Welcome to our perception experiment.&lt;br&gt;&lt;br&gt; \\\n                                          Press the SPACE key to continue.',\n                                    choices=[' '])\n\n  introduction_pictures = Text(text='Each picture contains two sets of dots, one left and one right.&lt;br&gt;&lt;br&gt;\\\n                                       Press the SPACE key to continue.',\n                                    choices=[' '])\n\n  introduction_responses = Text(text='You have to indicate whether the two sets contain an equal number of dots.&lt;br&gt;&lt;br&gt;\\\n                                       Press the y-key for yes (equal number) and&lt;br&gt; the n-key for no (unequal number).&lt;br&gt;&lt;br&gt;\\\n                                       Press the SPACE key to continue.',\n                                    choices=[' '])\n\n  introduction_note = Text(text='Note: For each picture, you have only 2 seconds to respond, so respond quickly.&lt;br&gt;&lt;br&gt;\\\n                                       You can only respond with the y and n keys while the dots are shown.&lt;br&gt;&lt;br&gt; \\\n                                       Press the SPACE key to BEGIN the experiment.',\n                                    choices=[' '])\n\n\n  # create a list of instruction stimuli for the instruction block\n  introduction_list = [introduction_welcome,\n                       introduction_pictures,\n                       introduction_responses,\n                       introduction_note]\n\n  # create the instruction block\n  instruction_block = Block(introduction_list)\n\n  # EXIT BLOCK\n\n  # create a text stimulus shown at the end of the experiment\n  instruction_exit = Text(duration=3000,\n                                  text='Thank you for participating in the experiment.',\n                                  )\n\n  # create a list of instruction stimuli for the exit block\n  exit_list = [instruction_exit]\n\n  # create the exit block\n  exit_block = Block(exit_list)\n\n  # TASK BLOCK\n\n  # define fixation cross\n  fixation = Fixation(1500)\n\n  # define the stimuli features as timeline variables\n  dot_stimulus_left = TimelineVariable('dots_left')\n  dot_stimulus_right = TimelineVariable('dots_right')\n\n  # We can define a stimulus as a function of those stimulus features\n  rdp = RandomDotPatterns(\n      duration=2000,\n      number_of_oobs=[dot_stimulus_left, dot_stimulus_right],\n      number_of_apertures=2,\n      choices=[\"y\", \"n\"],\n      background_color=\"black\",\n  )\n\n  # define the sequence of events within a trial\n  event_sequence = [fixation, rdp]\n\n  # group trials into blocks\n  task_block = Block(event_sequence, timeline)\n\n  # EXPERIMENT\n\n  # define the entire experiment\n  experiment = Experiment([instruction_block, task_block, exit_block])\n\n  # return a js string to transfer to autora\n  return experiment.to_js_string(as_function=True, is_async=True)\n</pre> from sweetbean.stimulus import Text, Fixation, RandomDotPatterns from sweetbean import Block, Experiment from sweetbean.variable import TimelineVariable  def stimulus_sequence(timeline):    # INSTRUCTION BLOCK    # generate several text stimuli that serve as instructions   introduction_welcome = Text(text='Welcome to our perception experiment. \\                                           Press the SPACE key to continue.',                                     choices=[' '])    introduction_pictures = Text(text='Each picture contains two sets of dots, one left and one right.\\                                        Press the SPACE key to continue.',                                     choices=[' '])    introduction_responses = Text(text='You have to indicate whether the two sets contain an equal number of dots.\\                                        Press the y-key for yes (equal number) and the n-key for no (unequal number).\\                                        Press the SPACE key to continue.',                                     choices=[' '])    introduction_note = Text(text='Note: For each picture, you have only 2 seconds to respond, so respond quickly.\\                                        You can only respond with the y and n keys while the dots are shown. \\                                        Press the SPACE key to BEGIN the experiment.',                                     choices=[' '])     # create a list of instruction stimuli for the instruction block   introduction_list = [introduction_welcome,                        introduction_pictures,                        introduction_responses,                        introduction_note]    # create the instruction block   instruction_block = Block(introduction_list)    # EXIT BLOCK    # create a text stimulus shown at the end of the experiment   instruction_exit = Text(duration=3000,                                   text='Thank you for participating in the experiment.',                                   )    # create a list of instruction stimuli for the exit block   exit_list = [instruction_exit]    # create the exit block   exit_block = Block(exit_list)    # TASK BLOCK    # define fixation cross   fixation = Fixation(1500)    # define the stimuli features as timeline variables   dot_stimulus_left = TimelineVariable('dots_left')   dot_stimulus_right = TimelineVariable('dots_right')    # We can define a stimulus as a function of those stimulus features   rdp = RandomDotPatterns(       duration=2000,       number_of_oobs=[dot_stimulus_left, dot_stimulus_right],       number_of_apertures=2,       choices=[\"y\", \"n\"],       background_color=\"black\",   )    # define the sequence of events within a trial   event_sequence = [fixation, rdp]    # group trials into blocks   task_block = Block(event_sequence, timeline)    # EXPERIMENT    # define the entire experiment   experiment = Experiment([instruction_block, task_block, exit_block])    # return a js string to transfer to autora   return experiment.to_js_string(as_function=True, is_async=True)"},{"location":"Use%20Case%20Tutorials/Psychophysics/psychophysics/#psychophysics-study","title":"Psychophysics Study\u00b6","text":"<p>In this example, we use SweetBean to generate an experimental sequence for a same-different Psychophysics experiment. In this experiment, each trials has the following sequence of events:</p> <ul> <li>a fixation cross is displayed for 1500 ms</li> <li>a set of two dot stimuli is displayed, one on the left and one on the right for 200ms. Each set contains a certain number of dots and the participant has to indicate whether the numbers of dots in the two sets are the same or different by pressing <code>y</code> or <code>n</code>.</li> </ul>"},{"location":"Use%20Case%20Tutorials/Psychophysics/psychophysics/#installation","title":"Installation\u00b6","text":"<p>First, we will install SweetBean and Setup.</p>"},{"location":"Use%20Case%20Tutorials/Psychophysics/psychophysics/#instruction-block","title":"Instruction Block\u00b6","text":"<p>Many experiments require instructions that tell the participants what to do.</p> <p>Creating instructions in SweetBean is quite simple. First, we define a number of text stimuli that the participant sees. Then, we specify the order of the text stimuli within a block of instructions.</p>"},{"location":"Use%20Case%20Tutorials/Psychophysics/psychophysics/#exit-block","title":"Exit Block\u00b6","text":"<p>Similarly, we can specify a final instruction displayed at the end of the experiment.</p>"},{"location":"Use%20Case%20Tutorials/Psychophysics/psychophysics/#task-block","title":"Task Block\u00b6","text":""},{"location":"Use%20Case%20Tutorials/Psychophysics/psychophysics/#fixation-cross","title":"Fixation Cross\u00b6","text":"<p>First, we define the fixation cross. SweetBean provides a convenient method:</p>"},{"location":"Use%20Case%20Tutorials/Psychophysics/psychophysics/#dots-stimulus","title":"Dots Stimulus\u00b6","text":"<p>Next, we declare our sets of dots as features in the stimulus, using the timeline variables:</p> <p>First, declare the stimulus features <code>dot_stimulus_left</code> and <code>dot_stimulus_right</code> as timeline variables (since they come from the timeline). For the parser, we also need to provide all the possible levels of the stimulus. For now, we assume that each dot display can contain either 40 or 70 dots.</p> <p>Then, we define the entire stimulus which is composed of the two features. SweetPea provides a convenient way of generating a stimulus with two sets of dots via <code>RandomDotPatternsStimulus</code>.</p>"},{"location":"Use%20Case%20Tutorials/Psychophysics/psychophysics/#task-event-sequence","title":"Task Event Sequence\u00b6","text":"<p>Now, we define the event sequence which determines the order of events within a trial. SweetBean groups event into event sequences, and event sequences into blocks. Here, an event sequence corresponds to a trial and a block to series of trials.</p>"},{"location":"Use%20Case%20Tutorials/Psychophysics/psychophysics/#experiment-block-sequence","title":"Experiment Block Sequence\u00b6","text":"<p>Now that we have specified all of our experiment blocks, we put them together into an experiment. The function below compiles the experiment and converts it into a html file.</p>"},{"location":"Use%20Case%20Tutorials/Psychophysics/psychophysics/#optional-writing-a-function-to-automate-the-generation-of-stimulus-sequences","title":"(Optional) Writing a Function to Automate the Generation of Stimulus Sequences\u00b6","text":"<p>You can also integrate SweetBean into closed-loop behavioral research workflows, e.g., using AutoRA. This may involve calling a function that generates a novel jsPsych experiment from scratch, depending on the inputs.</p> <p>The function below compiles the code above into a single function, and returns a web-based (JavaScript) experiment, written in <code>jsPsych</code>.</p> <p>The function takes a timeline, containing a sequence of trials, as input.</p>"},{"location":"Use%20Case%20Tutorials/Psychophysics/sweetpea/","title":"Generating Trial Sequences for a Closed-Loop Psychophysics Study","text":"In\u00a0[\u00a0]: Copied! <pre>%%capture\n!pip install sweetpea\n</pre> %%capture !pip install sweetpea In\u00a0[\u00a0]: Copied! <pre>from sweetpea import Factor\n\n# the first experimental factor indicates the number of dots in the\n# left stimulus. It has two levels, i.e., two possible values for the\n# number of dots, either 40 and or 70 dots.\nnum_dots_left = Factor('dots_left', [40, 70])\n\n# the second experimental factor indicates the number of dots in the\n# right stimulus. It also has two levels: 40 and 70 dots.\nnum_dots_right = Factor('dots_right', [70, 40])\n</pre> from sweetpea import Factor  # the first experimental factor indicates the number of dots in the # left stimulus. It has two levels, i.e., two possible values for the # number of dots, either 40 and or 70 dots. num_dots_left = Factor('dots_left', [40, 70])  # the second experimental factor indicates the number of dots in the # right stimulus. It also has two levels: 40 and 70 dots. num_dots_right = Factor('dots_right', [70, 40]) <p>The code defines the two variables in terms of two experimental factors, respectively: the number of dots in the left stimulus and the number of dots in the right stimulus. Here, we assume that the number of dots can either be 40 or 70.</p> In\u00a0[\u00a0]: Copied! <pre>from sweetpea import MinimumTrials, CrossBlock, synthesize_trials, CMSGen, experiments_to_dicts\n\n# the experimental design includes all relevant factors\n# (whether counterbalanced or not)\ndesign = [num_dots_left, num_dots_right]\n\n# the crossing specifies which factors are fully counterbalanced\ncrossing = [num_dots_left, num_dots_right]\n\n# we also add a constraint to include at least 20 trials\nconstraints = [MinimumTrials(20)]\n\n# next, we define an experimental block based on the design, crossing,\n# and constraints\nblock = CrossBlock(design, crossing, constraints)\n\n# we then use a SAT-Solver to find one suitable experimental sequence\nexperiment = synthesize_trials(block, 1, CMSGen)\n</pre> from sweetpea import MinimumTrials, CrossBlock, synthesize_trials, CMSGen, experiments_to_dicts  # the experimental design includes all relevant factors # (whether counterbalanced or not) design = [num_dots_left, num_dots_right]  # the crossing specifies which factors are fully counterbalanced crossing = [num_dots_left, num_dots_right]  # we also add a constraint to include at least 20 trials constraints = [MinimumTrials(20)]  # next, we define an experimental block based on the design, crossing, # and constraints block = CrossBlock(design, crossing, constraints)  # we then use a SAT-Solver to find one suitable experimental sequence experiment = synthesize_trials(block, 1, CMSGen) <p>We can print the resulting experiment:</p> In\u00a0[\u00a0]: Copied! <pre>from sweetpea import print_experiments\n\nprint_experiments(block, experiment)\n</pre> from sweetpea import print_experiments  print_experiments(block, experiment) <p>And we can store the resulting experimental sequence in a dictionary:</p> In\u00a0[\u00a0]: Copied! <pre># we can export the experimental sequence as a dictionary\nsequence = experiments_to_dicts(block, experiment)\nprint(sequence)\n</pre> # we can export the experimental sequence as a dictionary sequence = experiments_to_dicts(block, experiment) print(sequence) <p>Next, we wrap the code above into a function that will generate an experimental sequence for an arbitrary set of two stimulus intensities, e.g., number of dots. We will accept the number of trials as an argument.</p> In\u00a0[\u00a0]: Copied! <pre>from sweetpea import Factor, MinimumTrials, CrossBlock, synthesize_trials, CMSGen, experiments_to_dicts\n\ndef trial_sequence(num_dots_1, num_dots_2, min_trials):\n\n  # define regular factors\n  num_dots_left = Factor('dots_left', [num_dots_1, num_dots_2])\n  num_dots_right = Factor('dots_right', [num_dots_1, num_dots_2])\n\n  # define experimental block\n  design = [num_dots_left, num_dots_right]\n  crossing = [num_dots_left, num_dots_right]\n  constraints = [MinimumTrials(min_trials)]\n\n  block = CrossBlock(design, crossing, constraints)\n\n  # synthesize trial sequence\n  experiment = synthesize_trials(block, 1, CMSGen)\n\n  # export as dictionary\n  return experiments_to_dicts(block, experiment)[0]\n</pre> from sweetpea import Factor, MinimumTrials, CrossBlock, synthesize_trials, CMSGen, experiments_to_dicts  def trial_sequence(num_dots_1, num_dots_2, min_trials):    # define regular factors   num_dots_left = Factor('dots_left', [num_dots_1, num_dots_2])   num_dots_right = Factor('dots_right', [num_dots_1, num_dots_2])    # define experimental block   design = [num_dots_left, num_dots_right]   crossing = [num_dots_left, num_dots_right]   constraints = [MinimumTrials(min_trials)]    block = CrossBlock(design, crossing, constraints)    # synthesize trial sequence   experiment = synthesize_trials(block, 1, CMSGen)    # export as dictionary   return experiments_to_dicts(block, experiment)[0]"},{"location":"Use%20Case%20Tutorials/Psychophysics/sweetpea/#generating-trial-sequences-for-a-closed-loop-psychophysics-study","title":"Generating Trial Sequences for a Closed-Loop Psychophysics Study\u00b6","text":"<p>In this example, we use SweetPea to generate an experimental sequence for a same-different Psychophysics experiment.</p> <p>You can find more in-depth tutorials on automated experimental design at the SweetPea Website.</p>"},{"location":"Use%20Case%20Tutorials/Psychophysics/sweetpea/#installation","title":"Installation\u00b6","text":"<p>First, we will install SweetPea.</p>"},{"location":"Use%20Case%20Tutorials/Psychophysics/sweetpea/#regular-factors","title":"Regular Factors\u00b6","text":"<p>Next, we define the experimental factors of our experiment. In this experiment, select whether the number of dots in the two sets is the same or not.</p> <p>The experiment has two independent variables: The number of dots in the first set and the number of dots in the second set. Here, we want to counterbalance the number of dots for stimulus 1 and stimulus, respectively.</p>"},{"location":"Use%20Case%20Tutorials/Psychophysics/sweetpea/#synthesize-trial-sequences","title":"Synthesize Trial Sequences\u00b6","text":"<p>Next, we generate an experiment trial sequence. In this sequence, we want to counterbalance the levels of both factors. We also want to specify a constraint to include at least 20 trials.</p>"},{"location":"Use%20Case%20Tutorials/Psychophysics/sweetpea/#printing-and-extracting-experimental-sequence","title":"Printing and Extracting Experimental Sequence\u00b6","text":""},{"location":"Use%20Case%20Tutorials/Psychophysics/sweetpea/#writing-a-function-to-automate-the-generation-of-trial-sequences","title":"Writing a Function to Automate the Generation of Trial Sequences\u00b6","text":""},{"location":"User%20Guide/","title":"User Guide","text":"<p>This guide provides an overview over SweetBean.</p>"},{"location":"User%20Guide/#features","title":"Features","text":"<ul> <li>Declarative Specification: SweetBean is a domain-specific programming language in Python built for the declarative   specification of stimuli sequences that can be synthesized into JavaScript or HTML files ready to be served as online   or run with Large Language Models or Vision Models as synthetic participants.</li> <li>SweetBean experiments can be exported to multiple formats:<ul> <li>HTML: SweetBean can export experiments to HTML files that can be served as online experiments.</li> <li>JavaScript: SweetBean can export experiments to JavaScript files that can be run in the browser.</li> <li>AutoRA: SweetBean can be used to run automated Experiments with AutoRA.</li> <li>LLM: SweetBean can be used to run experiments with Large Language Models.</li> <li>Stimulus Sequence: SweetBean can automatically generate an image of the stimulus sequence often used to document   the experiment in papers.</li> <li>Coming soon: Vision Models: SweetBean will be able to run experiments with Vision Models.</li> </ul> </li> </ul>"},{"location":"User%20Guide/#installation","title":"Installation","text":"<p>To install and use SweetBean you need:</p> <ul> <li><code>Python</code> (version \"&gt;=3.8,&lt;4\") and</li> <li>the <code>sweetbean</code> package, including required dependencies specified in the <code>pyproject.toml</code> file.</li> </ul>"},{"location":"User%20Guide/#step-1-install-python","title":"Step 1: Install <code>python</code>","text":"<p>You can install <code>python</code>:</p> <ul> <li>Using the instructions at python.org, or</li> <li>Using a package manager, e.g.   homebrew,    pyenv,   asdf,    rtx,   winget.</li> </ul> <p>If successful, you should be able to run python in your terminal emulator like this: <pre><code>python\n</code></pre></p> <p>...and see some output like this: <pre><code>Python 3.11.3 (main, Apr  7 2023, 20:13:31) [Clang 14.0.0 (clang-1400.0.29.202)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n</code></pre></p>"},{"location":"User%20Guide/#step-2-install-sweetbean","title":"Step 2: Install <code>sweetbean</code>","text":"<p>!!! success     We recommend setting up your development environment using a manager like <code>venv</code>, which creates isolated python      environments. Other environment managers, like      virtualenv,     pipenv,     virtualenvwrapper,      hatch,      poetry,      are available and will likely work, but will have different syntax to the syntax shown here.</p> <p>In the <code>&lt;project directory&gt;</code>, run the following command to create a new virtual environment in the <code>.venv</code> directory</p> <pre><code>python3 -m \"venv\" \".venv\" \n</code></pre> <p>!!! hint     If you have multiple Python versions installed on your system, it may be necessary to specify the Python version when creating a virtual environment. For example, run the following command to specify Python 3.8 for the virtual environment.      <pre><code>python3.8 -m \"venv\" \".venv\" \n</code></pre></p> <p>Activate it by running <pre><code>source \".venv/bin/activate\"\n</code></pre></p> <pre><code>pip install \"autora\"\n</code></pre> <p>Check your installation by running: <pre><code>python -c \"from sweetbean.variable import TimelineVariable\"\n</code></pre></p> <p>You can now start using SweetBean!</p>"},{"location":"User%20Guide/data_variables/","title":"Data Variables","text":"<p>In the previous example, we created a derived parameter that determined the correct key based on the color of the Stroop stimulus. We can now create a data variable that determines whether the participant pressed the correct key. We can then use this data variable to create feedback for the participant.</p> <p>Assume the same timeline as before and the same derived parameter:</p> <pre><code>from sweetbean.variable import (\n    DataVariable,\n    FunctionVariable,\n    TimelineVariable,\n)\nfrom sweetbean import Block, Experiment\nfrom sweetbean.stimulus import Text\n\ntimeline = [\n    {\"color\": \"red\", \"word\": \"RED\"},\n    {\"color\": \"green\", \"word\": \"GREEN\"},\n    {\"color\": \"green\", \"word\": \"RED\"},\n    {\"color\": \"red\", \"word\": \"GREEN\"},\n]\n\n# EVENT SEQUENCE\n\ncolor = TimelineVariable(\"color\", [\"red\", \"green\"])\nword = TimelineVariable(\"word\", [\"RED\", \"GREEN\"])\n\n\ndef correct_key_fct(col):\n    if col == \"red\":\n        return \"f\"\n    elif col == \"green\":\n        return \"j\"\n\n\ncorrect_key = FunctionVariable(\"correct\", correct_key_fct, [color])\n</code></pre> <p>Now we can create a <code>DataVariable</code> that determines whether the participant pressed the correct key. The <code>1</code> in the declaration indicates from which stimulus to get the variable (1 = previous, 2 = second previous, etc.). We can use the <code>DataVariable</code> directly as parameter in stimuli, or we can us it as input for a <code>FunctionVariable</code> to create the feedback text:</p> <pre><code>correct = DataVariable(\"correct\", 1)\n\n# Predicates\ndef feedback_text_fct(was_correct):\n    if was_correct:\n        return \"That was correct!\"\n    else:\n        return \"That was false!\"\n\n\nfeedback_text = feedback_text_fct(\"feedback_text\", feedback_txt_fct, [correct])\n</code></pre> <p>Again, we can use this in a feedback stimulus.</p> <pre><code>fixation = FixationStimulus(500)\nstroop = TextStimulus(2000, word, color, [\"j\", \"f\"], correct_key)\nfeedback = TextStimulus(800, feedback_text)\n\nevent_sequence = [fixation, stroop, feedback]\n\n\ntrain_block = Block(event_sequence, timeline)\nexperiment = Experiment([train_block])\n\nexperiment.to_html(\"stroop.html\")\n</code></pre> <p>There is one additional variable type, that we can use: The shared variable. It is a special variable that can be shared across different trials and can be updated via side effects: Shared Variables And Side Effects</p>"},{"location":"User%20Guide/documentation_stimulus_sequence/","title":"Automated Generation of Stimulus Sequence Figures","text":"<p>SweetBea allows you to automatically generate an image of the stimulus sequence often used in the method section of a paper with a single line of code. This feature is designed to streamline the process of creating the method section of a paper.</p> <p>Assume you have the following block of code representing a Flanker task: <pre><code>from sweetbean import Block\nfrom sweetbean.stimulus import Blank, Feedback, Fixation, Flanker\nfrom sweetbean.variable import TimelineVariable\n\ntimeline = [\n    {\"direction\": \"left\", \"distractor\": \"right\", \"correct_key\": \"f\"},\n    {\"direction\": \"right\", \"distractor\": \"right\", \"correct_key\": \"j\"},\n    {\"direction\": \"left\", \"distractor\": \"left\", \"correct_key\": \"f\"},\n    {\"direction\": \"right\", \"distractor\": \"left\", \"correct_key\": \"j\"},\n]\n\ndirection = TimelineVariable(\"direction\")\ndistractor = TimelineVariable(\"distractor\")\ncorrect_key = TimelineVariable(\"correct_key\")\n\nfixation = Fixation(1000)\nso_s = Blank(400)\nflanker = Flanker(2000, direction, distractor, [\"j\", \"f\"], correct_key)\nso_f = Blank(300)\nfeedback = Feedback(800, window=2)\n\nblock = Block([fixation, so_s, flanker, so_f, feedback], timeline)\n</code></pre></p> <p>You can generate an image of the stimulus sequence with the following line of code: <pre><code>block.to_image(path='stimulus_sequence.png', data=[None, None, {'correct': True}, None, None], sequence=True, timeline_idx='random', zoom_factor=3)\n</code></pre></p> <p>The <code>to_image</code> method takes the following arguments: - <code>path</code>: The path to save the image. If the path is set to None, the function will return a PIL image object. - <code>data</code>: In this case the feedback stimulus expects the <code>correct</code> value of the flanker stimulus to be set. In a real experiment, this would be determined by the response of the participant. Here, we manually set it to <code>True</code>. - <code>sequence</code>: Whether to create one image with the sequence of stimuli or multiple images with each stimulus (then the path should be a directory). - <code>timeline_idx</code>: The index of the timeline element to use for the image. In this case, we set it to <code>random</code> to randomly select a timeline element. It could also be set to a specific index or None to create the image from the full timeline. - <code>zoom_factor</code>: The factor by which to zoom the stimulus (often the stimulus is in the middle of the screen with a large margin). The default is 3. This can also be set as a list to define different zoom factor for each stimulus.</p>"},{"location":"User%20Guide/function_variables/","title":"Function Variables","text":"<p>In the previous examples, we have seen how to create a simple block with a fixed trials. Here, we will introduce function variables. These variables allow us let a <code>FunctionVariable</code> depend on other <code>Variables</code>. This can be useful, for example, when providing feedback as a function of the participant's response. </p> <p>Let us assume the same timeline:</p> <pre><code>timeline = [\n    {\"color\": \"red\", \"word\": \"RED\"},\n    {\"color\": \"green\", \"word\": \"GREEN\"},\n    {\"color\": \"green\", \"word\": \"RED\"},\n    {\"color\": \"red\", \"word\": \"GREEN\"},\n]\n</code></pre> <p>First, we create the timeline variables</p> <pre><code>from sweetbean.variable import TimelineVariable\n\ncolor = TimelineVariable(\"color\")\nword = TimelineVariable(\"word\")\n</code></pre> <p>Now, we can create conditions (in form of functions). Here, we want to specify that the correct key is f if the color of the Stroop Stimulus is red and j if it is green.</p> <pre><code>def correct_key_fct(col):\n    if col == \"red\":\n        return \"f\"\n    elif col == \"green\":\n        return \"j\"\n</code></pre> <p>We can now create a function variable by specifying the name, the function, and which arguments to use (in this case the color)</p> <pre><code>from sweetbean.variable import FunctionVariable\n\ncorrect_key = FunctionVariable(\"correct\", correct_key_fct, [color])\n</code></pre> <p>Now, we can use the function variable in our stimuli:</p> <pre><code>from sweetbean.stimulus import Text, Fixation\n\nfixation = Fixation(1000)\nstroop = Text(2000, word, color, [\"j\", \"f\"], correct_key)\n</code></pre> <p>Finally, we can create a block with the timeline. Here, we pass in the timeline to the block. The event sequence will then be repeated as many times as there are entries in the timeline using the variables defined above.</p> <pre><code>event_sequence = [fixation, stroop]\n\ntrain_block = Block(event_sequence, timeline)\nexperiment = Experiment([train_block])\n\nexperiment.to_html(\"stroop.html\")\n</code></pre> <p>There is one additional variable, that we can use: The data variable. It is a special variable that accesses data from previous stimuli to dynamically adjust the current stimulus. For example, we can create Feedback: Data Variables</p>"},{"location":"User%20Guide/llm_synthetic_participant/","title":"LLM - Synthetic Participant","text":"<p>SweetBean can be used to run experiments with Large Language Models (LLMs) as synthetic participants.</p> <p>We specify the experiment as above:</p> <pre><code>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import Text\nfrom sweetbean.variable import TimelineVariable, DataVariable, FunctionVariable\n\n# TIMELINE\ntimeline = [\n    {\"color\": \"red\", \"word\": \"RED\", \"correct_key\": \"f\"},\n    {\"color\": \"green\", \"word\": \"GREEN\", \"correct_key\": \"j\"},\n    {\"color\": \"green\", \"word\": \"RED\", \"correct_key\": \"f\"},\n    {\"color\": \"red\", \"word\": \"GREEN\", \"correct_key\": \"j\"},\n]\n\n# EVENT SEQUENCE\n\ncolor = TimelineVariable(\"color\")\nword = TimelineVariable(\"word\")\n\n\ndef correct_key_fct(col):\n    if col == \"red\":\n        return \"f\"\n    elif col == \"green\":\n        return \"j\"\n\n\ncorrect_key = FunctionVariable(\"correct\", correct_key_fct, [color])\n\n# Creating a data variable\ncorrect = DataVariable(\"correct\", 2)\n\n\n# Predicates\ndef feedback_text_fct(was_correct):\n    if was_correct:\n        return \"That was correct!\"\n    else:\n        return \"That was false!\"\n\n\nfeedback_text = feedback_text_fct(\"feedback_text\", feedback_text_fct, [correct])\n\n# Using it in the stimulus\nfixation = Text(1000, \"+\")\n\nso_s = Text(400)\nstroop = Text(2000, word, color, [\"j\", \"f\"], correct_key)\nso_f = Text(300)\nfeedback = Text(800, feedback_text)\n\nevent_sequence = [fixation, so_s, stroop, so_f, feedback]\n\n# BLOCK DESIGN\n\ntrain_block = Block(event_sequence, timeline)\nexperiment = Experiment([train_block])\n</code></pre> <p>To test what the LLM \"sees\", we can run the experiment as chat on ourselves. If we set <code>multiturn</code> to true we will not see the full chat history but only the last generated prompt.</p> <pre><code>data = experiment.run_on_language(get_input=input)\n</code></pre> <p>We can run the experiment on any function that takes a string and returns a string. For example, on the centauer model:</p> <pre><code>pip install unsloth \"xformers==0.0.28.post2\"\n</code></pre> <p>We then define a function that generates the next token given a prompt:</p> <pre><code>from unsloth import FastLanguageModel\nimport transformers\n\nmodel, tokenizer = FastLanguageModel.from_pretrained(\n    model_name=\"marcelbinz/Llama-3.1-Centaur-8B-adapter\",\n    max_seq_length=32768,\n    dtype=None,\n    load_in_4bit=True,\n)\nFastLanguageModel.for_inference(model)\n\npipe = transformers.pipeline(\n    \"text-generation\",\n    model=model,\n    tokenizer=tokenizer,\n    trust_remote_code=True,\n    pad_token_id=0,\n    do_sample=True,\n    temperature=1.0,\n    max_new_tokens=1,\n)\n\n\ndef generate(input):\n    return pipe(input)[0][\"generated_text\"][len(input):]\n</code></pre> <p>Now, we can run the experiment on the model:</p> <pre><code>data = experiment.run_on_language(get_input=generate)\n</code></pre> <p>Note: The <code>run_on_language</code> function will return a dictionary with the data from the experiment. Any model (for example, using OpenAI, HuggingFace, LLama, or Google API) can be used as a synthetic participant. In addition to responses from the language model, here, you can find how to assess other metrics like certainty of the language model.</p>"},{"location":"User%20Guide/overview/","title":"Overview","text":""},{"location":"User%20Guide/overview/#installation","title":"Installation","text":"<p>SweetBean can be installed via pip:</p> <pre><code>pip install sweetbean\n</code></pre>"},{"location":"User%20Guide/overview/#usage","title":"Usage","text":""},{"location":"User%20Guide/overview/#a-single-introduction-trial","title":"A single Introduction Trial","text":"<p>To create a SweetBean experiment, you define a sequence of stimuli. For example, the following code defines a simple text stimulus to welcome participants. `:</p> <pre><code>from sweetbean.stimulus import Text\n\nwelcome = Text(\"Welcome to the experiment! Press &gt;&gt;Space&lt;&lt; to begin\", choices=[\" \"])\n</code></pre> <p>We then use stimuli to create a sequence of events:</p> <pre><code>event_sequence = [welcome]\n</code></pre> <p>From sequences, we can create a block:</p> <pre><code>from sweetbean import Block\n\nintroduction_block = Block(event_sequence)\n</code></pre> <p>Finally, we can create the experiment...</p> <pre><code>from sweetbean import Experiment\n\nexperiment = Experiment([indroduction_block])\n</code></pre> <p>... and export the experiment as html file</p> <pre><code>experiment.to_html(\"basic.html\")\n</code></pre>"},{"location":"User%20Guide/overview/#download-data","title":"Download Data","text":"<p>You can run the created file <code>basic.html</code> in any browser to test the experiment. If you want to create an experiment that automatically downloads the created data locally (for example, to look at the data during development), use the  following code:</p> <pre><code>experiment.to_html(\"basic.html\", path_local_download='example.csv') # for csv\n</code></pre> <pre><code>experiment.to_html(\"basic.html\", path_local_download='example.json') # for json\n</code></pre> <p>At the end of an experiment created this way, the data will be automatically stored to your machines <code>download</code> folder.</p>"},{"location":"User%20Guide/overview/#multiple-trials","title":"Multiple Trials","text":"<p>Let us create a stroop experiment. The trials should start with a fixation cross, followed by a colored word:</p> <pre><code>from sweetbean.stimulus import Text, Fixation\n\nfixation_1 = Fixation(duration=500)\nstroop_1 = Text(\"RED\", color=\"red\", choices=[\"r\", \"g\"])\nfixation_2 = Fixation(duration=500)\nstroop_2 = Text(\"GREEN\", color=\"green\", choices=[\"r\", \"g\"])\nfixation_3 = Fixation(duration=500)\n...\n</code></pre> <p>We can then create a sequence of events and blocks as before.</p> <pre><code>event_sequence_stroop = [fixation_1, stroop_1, fixation_2, stroop_2, fixation_3, ...]\nstroop_block = Block(event_sequence_stroop)\nexperiment = Experiment([introduction_block, stroop_block])\nexperiment.to_html(\"stroop.html\")\n</code></pre> <p>This way, we could use loops to create experiments with many trials. But a better way is to use the <code>timeline variables</code>: Timeline Variables</p>"},{"location":"User%20Guide/shared_variables_and_side_effects/","title":"Shared Variables And Side Effects","text":"<p>Shared Variables are variables that can be shared across different trials. They can be updated via Side Effects. This can be useful, for example, when we want to keep track of the participant's score.</p> <p>Assume, we have a two-armed bandit task and want to present the score of the participant after each choice.</p> <p>As in the previous examples, we first define the timeline and the timeline variables: <pre><code>from sweetbean import Block, Experiment\nfrom sweetbean.stimulus import Bandit, Text\nfrom sweetbean.variable import (\n    DataVariable,\n    FunctionVariable,\n    SharedVariable,\n    SideEffect,\n    TimelineVariable,\n)\n\ntimeline = [\n    {\n        \"bandit_1\": {\"color\": \"orange\", \"value\": 10},\n        \"bandit_2\": {\"color\": \"blue\", \"value\": 0},\n    },\n    {\n        \"bandit_1\": {\"color\": \"orange\", \"value\": 9},\n        \"bandit_2\": {\"color\": \"blue\", \"value\": 1},\n    },\n    {\n        \"bandit_1\": {\"color\": \"orange\", \"value\": 8},\n        \"bandit_2\": {\"color\": \"blue\", \"value\": 2},\n    },\n    {\n        \"bandit_1\": {\"color\": \"orange\", \"value\": 7},\n        \"bandit_2\": {\"color\": \"blue\", \"value\": 3},\n    },\n    {\n        \"bandit_1\": {\"color\": \"orange\", \"value\": 6},\n        \"bandit_2\": {\"color\": \"blue\", \"value\": 4},\n    },\n]\n\nbandit_1 = TimelineVariable(\"bandit_1\")\nbandit_2 = TimelineVariable(\"bandit_2\")\n</code></pre></p> <p>Next, we define the shared variable <code>score</code>. The start value will be 0, and we will update it with the <code>update_score</code> function by adding the <code>value</code> of the chosen bandit to the score. Since we need the <code>value</code> of the chosen bandit, we also define a data variable that gets the value with the window 0 (current trial).</p> <pre><code>score = SharedVariable(\"score\", 0)\nvalue = DataVariable(\"value\", 0)\n\nupdated_score = FunctionVariable(\n    \"updated_score\", lambda sc, val: sc + val, [score, value]\n)\n</code></pre> <p>We can now create a side effect that updates the score with the <code>update_score</code> function. We pass the score and the function to the side effect. A side effects takes in the variable to set (in this case the score) and the variable it will be set to (in this case the function variable <code>update_score</code>).</p> <p>We can pass in as many side effects as we want to a stimulus as a list of side effects. Here, we only have one side effect that updates the score.</p> <pre><code>update_score_side_effect = SideEffect(score, updated_score)\n\nbandit_task = Bandit(\n    bandits=[bandit_1, bandit_2, bandit_3],\n    side_effects=[update_score_side_effect],\n)\n</code></pre> <p>Finally, we can show the score after each choice with a text stimulus. We pass the score to the text stimulus.</p> <pre><code>show_score = Text(duration=1000, text=score)\n</code></pre> <p>Then we create the experiment as before and export it as a html file.</p> <pre><code>trial_sequence = Block([bandit_task, show_score], timeline=timeline)\nexperiment = Experiment([trial_sequence])\nexperiment.to_html(\"bandit.html\")\n</code></pre>"},{"location":"User%20Guide/timeline_variables/","title":"Timeline Variables","text":"<p>In the previous examples, we have seen how to create a simple block with a fixed trials. Here, we will introduce timeline variables that can be used to create more complex experiments with multiple trials.</p> <p>Consider the following timeline that consists of words and colors for a Stroop Task:</p> <pre><code>timeline = [\n    {\"color\": \"red\", \"word\": 'RED'},\n    {\"color\": \"green\", \"word\": \"GREEN\"},\n    {\"color\": \"green\", \"word\": \"RED\"},\n    {\"color\": \"red\", \"word\": \"GREEN\"},\n]\n</code></pre> <p>First, we declare SweetBean Timeline Variables:</p> <p>color: The name has to be color (it has to match the key in the timeline) word: The name has to be word (it has to match the key in the timeline)</p> <pre><code>from sweetbean.variable import TimelineVariable\n\ncolor = TimelineVariable(name=\"color\")\nword = TimelineVariable(name=\"word\")\n</code></pre> <p>Now, we can use these timeline variables when defining the stimuli:</p> <pre><code>from sweetbean.stimulus import Text, Fixation\n\nfixation = FixationStimulus(duration=500)\nstroop = TextStimulus(duration=1000, text=word, color=color)\n</code></pre> <p>Finally, we can create a block with the timeline. Here, we pass in the timeline to the block. The event sequence will then be repeated as many times as there are entries in the timeline using the variables defined above.</p> <pre><code>from sweetbean import Block, Experiment\n\nevent_sequence = [fixation, stroop]\nstroop_block = Block(event_sequence, timeline)\nexperiment = Experiment(stroop_block)\nexperiment.to_html(\"stroop.html\")\n</code></pre> <p>Additionally, to timeline variables, we can also create function variables. For example, we can create a variable that gives us the correct key press depending on the word of a StroopStimulus: Derived Variable</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>sweetbean<ul> <li>__init__</li> <li>block</li> <li>data</li> <li>experiment</li> <li>extension<ul> <li>TouchButton</li> <li>__init__</li> </ul> </li> <li>llm_utils<ul> <li>__init__</li> <li>prompts</li> </ul> </li> <li>stimulus<ul> <li>Choice</li> <li>Foraging</li> <li>Gabor</li> <li>Generic</li> <li>HtmlKeyboardResponse</li> <li>Image</li> <li>RO</li> <li>RSVP</li> <li>Survey</li> <li>Symbol</li> <li>Video</li> <li>__init__</li> </ul> </li> <li>util<ul> <li>__init__</li> <li>data_process</li> <li>io</li> </ul> </li> <li>variable<ul> <li>__init__</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/sweetbean/","title":"sweetbean","text":""},{"location":"reference/sweetbean/#sweetbean.check_java","title":"<code>check_java()</code>","text":"<p>Ensure that Java is installed.</p> Source code in <code>sweetbean/__init__.py</code> <pre><code>def check_java():\n    \"\"\"Ensure that Java is installed.\"\"\"\n    java_path = shutil.which(\"java\")\n    if java_path is None:\n        sys.stderr.write(\n            \"\\nError: Java is required but not found.\\n\"\n            \"   Please install Java using one of the following.\\n\"\n        )\n        sys.exit(1)\n</code></pre>"},{"location":"reference/sweetbean/block/","title":"sweetbean.block","text":""},{"location":"reference/sweetbean/block/#sweetbean.block.Block","title":"<code>Block</code>","text":"<p>A block of stimuli (for example, an instruction, training, or test block)</p> Source code in <code>sweetbean/block.py</code> <pre><code>class Block:\n    \"\"\"\n    A block of stimuli (for example, an instruction, training, or test block)\n    \"\"\"\n\n    stimuli: List[Any] = []\n    js = \"\"\n    timeline = None\n    extensions: Dict = {}\n\n    def __init__(self, stimuli, timeline=None):\n        \"\"\"\n        Arguments:\n            stimuli: a list of stimuli\n            timeline: a list of dictionaries with the name of the timeline variables\n        \"\"\"\n        if timeline is None:\n            timeline = []\n        self.stimuli = stimuli\n        self.timeline = timeline\n        self.extensions[\"touch_layouts\"] = []\n\n    def to_js(self):\n        self.js = \"{timeline: [\"\n        for s in self.stimuli:\n            self.extensions[\"touch_layouts\"].append(s.create_touch_layout())\n            s.to_js()\n            self.js += s.js + \",\"\n        self.js = self.js[:-1]\n        if isinstance(self.timeline, CodeVariable):\n            self.js += f\"], timeline_variables: {self.timeline.name}\" + \"}\"\n        else:\n            self.js += f\"], timeline_variables: {self.timeline}\" + \"}\"\n\n    def to_image(self, path, data, sequence=True, timeline_idx=\"random\", zoom_factor=3):\n        \"\"\"\n        Create an image of the stimuli sequence of the block\n        Arguments:\n            path: the path to save the image\n            data: if needed data can be passed in for the stimuli\n                (for example, correct if the sequence contains a feedback stimulus)\n            sequence: if True, the images are combined into one image else they are\n                stored separately\n            timeline_idx: the index of the timeline element to use, if \"random\" a random\n                timeline element is chosen, if none, the whole timeline is shown\n            zoom_factor: the factor by which the images are zoomed (can be a list if\n                different zoom factors for each stimulus are needed)\n\n        \"\"\"\n\n        data_in = []\n        shared_variables = {}\n        for s in self.stimuli:\n            _shared_variables = s.return_shared_variables()\n            for s_key in _shared_variables:\n                shared_variables[s_key] = _shared_variables[s_key].value\n        if not self.timeline:\n            timeline = [{}]\n        else:\n            timeline = self.timeline\n\n        if timeline_idx == \"random\":\n            timeline = [timeline[random.randint(0, len(timeline) - 1)]]\n        elif timeline_idx is not None:\n            timeline = [timeline[timeline_idx]]\n\n        k = 0\n        images = []\n        durations = []\n        for t in timeline:\n            for s in self.stimuli:\n                if s.arg[\"duration\"] == 0:\n                    continue\n                html = HTML_PREAMBLE\n                html += \"jsPsych = initJsPsych();\\n\"\n                html += \"trials = [\\n\"\n                s._prepare_args_l(t, data_in, shared_variables)\n                s.to_js_for_image()\n                html += s.js\n                html += \"];\\n\"\n                html += \"jsPsych.run(trials);\"\n                html += HTML_APPENDIX\n                image = asyncio.run(render_html_to_image(html))\n                duration = s.l_args[\"duration\"] if \"duration\" in s.l_args else 0\n                images.append(image)\n                durations.append(duration)\n                if data and k &lt; len(data):\n                    data_in.append(data[k])\n                k += 1\n\n        if not sequence:\n            if path:\n                for idx, i in enumerate(images):\n                    i.save(f\"{path}/stimulus_{idx}.png\")\n                return\n            return images, durations\n        result_image = create_stimulus_sequence(\n            images, durations, zoom_factor=zoom_factor\n        )\n        if path:\n            result_image.save(path)\n            return\n        return result_image\n</code></pre>"},{"location":"reference/sweetbean/block/#sweetbean.block.Block.__init__","title":"<code>__init__(stimuli, timeline=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>stimuli</code> <p>a list of stimuli</p> required <code>timeline</code> <p>a list of dictionaries with the name of the timeline variables</p> <code>None</code> Source code in <code>sweetbean/block.py</code> <pre><code>def __init__(self, stimuli, timeline=None):\n    \"\"\"\n    Arguments:\n        stimuli: a list of stimuli\n        timeline: a list of dictionaries with the name of the timeline variables\n    \"\"\"\n    if timeline is None:\n        timeline = []\n    self.stimuli = stimuli\n    self.timeline = timeline\n    self.extensions[\"touch_layouts\"] = []\n</code></pre>"},{"location":"reference/sweetbean/block/#sweetbean.block.Block.to_image","title":"<code>to_image(path, data, sequence=True, timeline_idx='random', zoom_factor=3)</code>","text":"<p>Create an image of the stimuli sequence of the block Arguments:     path: the path to save the image     data: if needed data can be passed in for the stimuli         (for example, correct if the sequence contains a feedback stimulus)     sequence: if True, the images are combined into one image else they are         stored separately     timeline_idx: the index of the timeline element to use, if \"random\" a random         timeline element is chosen, if none, the whole timeline is shown     zoom_factor: the factor by which the images are zoomed (can be a list if         different zoom factors for each stimulus are needed)</p> Source code in <code>sweetbean/block.py</code> <pre><code>def to_image(self, path, data, sequence=True, timeline_idx=\"random\", zoom_factor=3):\n    \"\"\"\n    Create an image of the stimuli sequence of the block\n    Arguments:\n        path: the path to save the image\n        data: if needed data can be passed in for the stimuli\n            (for example, correct if the sequence contains a feedback stimulus)\n        sequence: if True, the images are combined into one image else they are\n            stored separately\n        timeline_idx: the index of the timeline element to use, if \"random\" a random\n            timeline element is chosen, if none, the whole timeline is shown\n        zoom_factor: the factor by which the images are zoomed (can be a list if\n            different zoom factors for each stimulus are needed)\n\n    \"\"\"\n\n    data_in = []\n    shared_variables = {}\n    for s in self.stimuli:\n        _shared_variables = s.return_shared_variables()\n        for s_key in _shared_variables:\n            shared_variables[s_key] = _shared_variables[s_key].value\n    if not self.timeline:\n        timeline = [{}]\n    else:\n        timeline = self.timeline\n\n    if timeline_idx == \"random\":\n        timeline = [timeline[random.randint(0, len(timeline) - 1)]]\n    elif timeline_idx is not None:\n        timeline = [timeline[timeline_idx]]\n\n    k = 0\n    images = []\n    durations = []\n    for t in timeline:\n        for s in self.stimuli:\n            if s.arg[\"duration\"] == 0:\n                continue\n            html = HTML_PREAMBLE\n            html += \"jsPsych = initJsPsych();\\n\"\n            html += \"trials = [\\n\"\n            s._prepare_args_l(t, data_in, shared_variables)\n            s.to_js_for_image()\n            html += s.js\n            html += \"];\\n\"\n            html += \"jsPsych.run(trials);\"\n            html += HTML_APPENDIX\n            image = asyncio.run(render_html_to_image(html))\n            duration = s.l_args[\"duration\"] if \"duration\" in s.l_args else 0\n            images.append(image)\n            durations.append(duration)\n            if data and k &lt; len(data):\n                data_in.append(data[k])\n            k += 1\n\n    if not sequence:\n        if path:\n            for idx, i in enumerate(images):\n                i.save(f\"{path}/stimulus_{idx}.png\")\n            return\n        return images, durations\n    result_image = create_stimulus_sequence(\n        images, durations, zoom_factor=zoom_factor\n    )\n    if path:\n        result_image.save(path)\n        return\n    return result_image\n</code></pre>"},{"location":"reference/sweetbean/data/","title":"sweetbean.data","text":""},{"location":"reference/sweetbean/data/#sweetbean.data.get_n_responses","title":"<code>get_n_responses(data)</code>","text":"<p>Get the number of responses in the data.</p> Source code in <code>sweetbean/data.py</code> <pre><code>def get_n_responses(data):\n    \"\"\"\n    Get the number of responses in the data.\n    \"\"\"\n    n = 0\n    for d in data:\n        if \"response\" in d and d[\"response\"] is not None:\n            n += 1\n    return n\n</code></pre>"},{"location":"reference/sweetbean/data/#sweetbean.data.process_js","title":"<code>process_js(js_data)</code>","text":"<p>Process the data from a SweetBean generated jsPsych experiment.</p> Source code in <code>sweetbean/data.py</code> <pre><code>def process_js(js_data):\n    \"\"\"\n    Process the data from a SweetBean generated jsPsych experiment.\n    \"\"\"\n    res = []\n    for d in js_data:\n        res_dict = {}\n        for key, value in d.items():\n            if key in [\"rt\", \"stimulus\", \"type\", \"response\"]:\n                res_dict[key] = value\n            if key.startswith(\"bean_\"):\n                res_dict[key[5:]] = value\n        res.append(res_dict)\n    return res\n</code></pre>"},{"location":"reference/sweetbean/data/#sweetbean.data.until_response","title":"<code>until_response(data, n)</code>","text":"<p>Get the data until the nth response. (This is helpful, for example, to get the data up a certain point and then run the rest of the experiment with <code>run_on_language</code>)</p> Source code in <code>sweetbean/data.py</code> <pre><code>def until_response(data, n):\n    \"\"\"\n    Get the data until the nth response.\n    (This is helpful, for example, to get the data up a certain point\n    and then run the rest of the experiment with `run_on_language`)\n    \"\"\"\n    i = 0\n    for idx, d in enumerate(data):\n        if \"response\" in d and d[\"response\"] is not None:\n            i += 1\n        if i &gt; n:\n            return data[:idx]\n</code></pre>"},{"location":"reference/sweetbean/experiment/","title":"sweetbean.experiment","text":""},{"location":"reference/sweetbean/experiment/#sweetbean.experiment.Experiment","title":"<code>Experiment</code>","text":"<p>An experiment consisting of blocks</p> Source code in <code>sweetbean/experiment.py</code> <pre><code>class Experiment:\n    \"\"\"\n    An experiment consisting of blocks\n    \"\"\"\n\n    blocks: List[Block] = []\n    js = \"\"\n\n    def __init__(self, blocks: List[Block]):\n        \"\"\"\n        Arguments:\n            blocks: a list of blocks\n        \"\"\"\n        self.blocks = blocks\n\n    def to_js(self, path_local_download=None):\n        self.js = \"\"\n        shared_variables = {}\n        extensions = \"\"\n        for b in self.blocks:\n            b.to_js()\n            extensions += _initialize_extensions(b.extensions)\n            for s in b.stimuli:\n                shared_variables.update(s.return_shared_variables())\n        for s_key in shared_variables:\n            self.js += f\"{shared_variables[s_key].set()}\\n\"\n        if path_local_download:\n            if path_local_download.endswith(\".json\"):\n                if extensions == \"\":\n                    self.js += \"jsPsych = initJsPsych(\"\n                else:\n                    self.js += f\"jsPsych = initJsPsych({extensions},\"\n                self.js += (\n                    f\"{{on_finish:()=&gt;jsPsych.data.get().localSave('json',\"\n                    f\"'{path_local_download}')}});\\n\"\n                )\n            elif path_local_download.endswith(\".csv\"):\n                if extensions == \"\":\n                    self.js += \"jsPsych = initJsPsych(\"\n                else:\n                    self.js += f\"jsPsych = initJsPsych({extensions},\"\n                self.js += (\n                    f\"{{on_finish:()=&gt;jsPsych.data.get().localSave('csv',\"\n                    f\"'{path_local_download}')}});\\n\"\n                )\n            else:\n                raise Exception(\n                    \"Unknown file format for local download. \"\n                    \"Only .json or .csv are supported.\"\n                )\n        else:\n            self.js += f\"jsPsych = initJsPsych({extensions});\\n\"\n        self.js += \"trials = [\\n\"\n        for b in self.blocks:\n            self.js += b.js\n            self.js += \",\"\n        self.js = self.js[:-1] + \"]\\n\"\n        self.js += \";jsPsych.run(trials)\"\n\n    def to_html(self, path, path_local_download=None):\n        \"\"\"\n        Save the experiment to an HTML file\n        \"\"\"\n        self.to_js(path_local_download)\n        html = HTML_PREAMBLE\n        blocks = 0\n\n        if blocks &gt; 0:\n            html += \"&lt;/script&gt;&lt;script&gt;\\n\"\n        html += f\"{self.js}\" + HTML_APPENDIX\n\n        with open(path, \"w\") as f:\n            f.write(html)\n\n    def to_js_string(self, as_function=True, is_async=True):\n        \"\"\"\n        Return the experiment as a JavaScript string\n        \"\"\"\n        text = FUNCTION_PREAMBLE(is_async) if as_function else \"\"\n        extensions = \"\"\n        for b in self.blocks:\n            b.to_js()\n            extensions += _initialize_extensions(b.extensions)\n            for s in b.stimuli:\n\n                shared_variables = s.return_shared_variables()\n                for s_key in shared_variables:\n                    text += f\"{shared_variables[s_key].set()}\\n\"\n        text += f\"const jsPsych = initJsPsych({extensions})\\n\"\n        text += \"const trials = [\\n\"\n        for b in self.blocks:\n            text += b.js\n            text += \",\"\n        text = text[:-1] + \"]\\n\"\n        text += FUNCTION_APPENDIX(is_async) if as_function else TEXT_APPENDIX(is_async)\n        return text\n\n    def run_on_language(\n        self,\n        get_input=input,\n        multi_turn=False,\n        preamble=\"\",\n        data=None,\n    ):\n        \"\"\"\n        Run the experiment in a language\n\n        Arguments:\n            get_input: a function to get input from the response\n                (for example, a function that prompts language model and returns the response)\n            multi_turn: a boolean to allow multi-turn input.\n                If True, the prompts are not concatenated.\n            preamble: a string to be added before the prompts\n            data: a list of dictionaries with the data.\n                This will rerun the experiment with the data as input.\n                If the data is not provided for the full experiment,\n                the rest of it will be simulated with the get_input function.\n        \"\"\"\n        out_data = []\n        prompts = []\n        shared_variables = {}\n        for b in self.blocks:\n            for s in b.stimuli:\n                _shared_variables = s.return_shared_variables()\n                for s_key in _shared_variables:\n                    shared_variables[s_key] = _shared_variables[s_key].value\n        datum_index = 0\n        for b in self.blocks:\n            timeline = b.timeline\n            stimuli = b.stimuli\n            if not timeline:\n                timeline = [{}]\n            for timeline_element in timeline:\n                out_data, prompts, shared_variables, datum_index = run_stimuli(\n                    stimuli,\n                    timeline_element,\n                    out_data,\n                    shared_variables,\n                    prompts,\n                    get_input,\n                    multi_turn,\n                    datum_index,\n                    data,\n                    preamble,\n                )\n        return out_data, prompts\n</code></pre>"},{"location":"reference/sweetbean/experiment/#sweetbean.experiment.Experiment.__init__","title":"<code>__init__(blocks)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>blocks</code> <code>List[Block]</code> <p>a list of blocks</p> required Source code in <code>sweetbean/experiment.py</code> <pre><code>def __init__(self, blocks: List[Block]):\n    \"\"\"\n    Arguments:\n        blocks: a list of blocks\n    \"\"\"\n    self.blocks = blocks\n</code></pre>"},{"location":"reference/sweetbean/experiment/#sweetbean.experiment.Experiment.run_on_language","title":"<code>run_on_language(get_input=input, multi_turn=False, preamble='', data=None)</code>","text":"<p>Run the experiment in a language</p> <p>Parameters:</p> Name Type Description Default <code>get_input</code> <p>a function to get input from the response (for example, a function that prompts language model and returns the response)</p> <code>input</code> <code>multi_turn</code> <p>a boolean to allow multi-turn input. If True, the prompts are not concatenated.</p> <code>False</code> <code>preamble</code> <p>a string to be added before the prompts</p> <code>''</code> <code>data</code> <p>a list of dictionaries with the data. This will rerun the experiment with the data as input. If the data is not provided for the full experiment, the rest of it will be simulated with the get_input function.</p> <code>None</code> Source code in <code>sweetbean/experiment.py</code> <pre><code>def run_on_language(\n    self,\n    get_input=input,\n    multi_turn=False,\n    preamble=\"\",\n    data=None,\n):\n    \"\"\"\n    Run the experiment in a language\n\n    Arguments:\n        get_input: a function to get input from the response\n            (for example, a function that prompts language model and returns the response)\n        multi_turn: a boolean to allow multi-turn input.\n            If True, the prompts are not concatenated.\n        preamble: a string to be added before the prompts\n        data: a list of dictionaries with the data.\n            This will rerun the experiment with the data as input.\n            If the data is not provided for the full experiment,\n            the rest of it will be simulated with the get_input function.\n    \"\"\"\n    out_data = []\n    prompts = []\n    shared_variables = {}\n    for b in self.blocks:\n        for s in b.stimuli:\n            _shared_variables = s.return_shared_variables()\n            for s_key in _shared_variables:\n                shared_variables[s_key] = _shared_variables[s_key].value\n    datum_index = 0\n    for b in self.blocks:\n        timeline = b.timeline\n        stimuli = b.stimuli\n        if not timeline:\n            timeline = [{}]\n        for timeline_element in timeline:\n            out_data, prompts, shared_variables, datum_index = run_stimuli(\n                stimuli,\n                timeline_element,\n                out_data,\n                shared_variables,\n                prompts,\n                get_input,\n                multi_turn,\n                datum_index,\n                data,\n                preamble,\n            )\n    return out_data, prompts\n</code></pre>"},{"location":"reference/sweetbean/experiment/#sweetbean.experiment.Experiment.to_html","title":"<code>to_html(path, path_local_download=None)</code>","text":"<p>Save the experiment to an HTML file</p> Source code in <code>sweetbean/experiment.py</code> <pre><code>def to_html(self, path, path_local_download=None):\n    \"\"\"\n    Save the experiment to an HTML file\n    \"\"\"\n    self.to_js(path_local_download)\n    html = HTML_PREAMBLE\n    blocks = 0\n\n    if blocks &gt; 0:\n        html += \"&lt;/script&gt;&lt;script&gt;\\n\"\n    html += f\"{self.js}\" + HTML_APPENDIX\n\n    with open(path, \"w\") as f:\n        f.write(html)\n</code></pre>"},{"location":"reference/sweetbean/experiment/#sweetbean.experiment.Experiment.to_js_string","title":"<code>to_js_string(as_function=True, is_async=True)</code>","text":"<p>Return the experiment as a JavaScript string</p> Source code in <code>sweetbean/experiment.py</code> <pre><code>def to_js_string(self, as_function=True, is_async=True):\n    \"\"\"\n    Return the experiment as a JavaScript string\n    \"\"\"\n    text = FUNCTION_PREAMBLE(is_async) if as_function else \"\"\n    extensions = \"\"\n    for b in self.blocks:\n        b.to_js()\n        extensions += _initialize_extensions(b.extensions)\n        for s in b.stimuli:\n\n            shared_variables = s.return_shared_variables()\n            for s_key in shared_variables:\n                text += f\"{shared_variables[s_key].set()}\\n\"\n    text += f\"const jsPsych = initJsPsych({extensions})\\n\"\n    text += \"const trials = [\\n\"\n    for b in self.blocks:\n        text += b.js\n        text += \",\"\n    text = text[:-1] + \"]\\n\"\n    text += FUNCTION_APPENDIX(is_async) if as_function else TEXT_APPENDIX(is_async)\n    return text\n</code></pre>"},{"location":"reference/sweetbean/extension/","title":"sweetbean.extension","text":""},{"location":"reference/sweetbean/extension/TouchButton/","title":"sweetbean.extension.TouchButton","text":""},{"location":"reference/sweetbean/extension/TouchButton/#sweetbean.extension.TouchButton.TouchButton","title":"<code>TouchButton</code>","text":"<p>A class to create touch buttons as input instead of key presses (https://github.com/jspsych/jspsych-contrib/tree/main/packages/extension-touchscreen-buttons)</p> Source code in <code>sweetbean/extension/TouchButton.py</code> <pre><code>class TouchButton:\n    \"\"\"\n    A class to create touch buttons as input instead of key presses\n    (https://github.com/jspsych/jspsych-contrib/tree/main/packages/extension-touchscreen-buttons)\n    \"\"\"\n\n    def __init__(self, key, layout):\n        \"\"\"\n        Arguments:\n            key: the key that is emulated by the touch button\n            layout: the layout of the touch button\n        \"\"\"\n        self.key = key\n        self.layout = layout\n\n    def to_js(self):\n        return f'\"{self.key}\"'\n\n    def __eq__(self, other):\n        return self.key == other.key\n\n    def __hash__(self):\n        return hash(self.key)\n\n    @classmethod\n    def left(cls, color=None):\n        \"\"\"\n        Convenience Function to create a touch button on the left side of the screen\n        \"\"\"\n        if color is None:\n            color = \"#fff\"\n        return cls(key=\"l\", layout={\"key\": \"l\", \"color\": color, \"preset\": \"left\"})\n\n    @classmethod\n    def right(cls, color=None):\n        \"\"\"\n        Convenience Function to create a touch button on the right side of the screen\n        \"\"\"\n        if color is None:\n            color = \"#fff\"\n        return cls(key=\"r\", layout={\"key\": \"r\", \"color\": color, \"preset\": \"right\"})\n\n    @classmethod\n    def bottom_left(cls, color=None):\n        \"\"\"\n        Convenience Function to create a touch button on the bottom left side of the screen\n        \"\"\"\n        if color is None:\n            color = \"#fff\"\n        return cls(\n            key=\"l\", layout={\"key\": \"l\", \"color\": color, \"preset\": \"bottom_left\"}\n        )\n\n    @classmethod\n    def bottom_right(cls, color=None):\n        \"\"\"\n        Convenience Function to create a touch button on the bottom right side of the screen\n        \"\"\"\n        if color is None:\n            color = \"#fff\"\n        return cls(\n            key=\"r\", layout={\"key\": \"r\", \"color\": color, \"preset\": \"bottom_right\"}\n        )\n\n    @classmethod\n    def top_left(cls, color=None):\n        \"\"\"\n        Convenience Function to create a touch button on the top left side of the screen\n        \"\"\"\n        if color is None:\n            color = \"#fff\"\n        return cls(key=\"l\", layout={\"key\": \"l\", \"color\": color, \"preset\": \"top_left\"})\n\n    @classmethod\n    def top_right(cls, color=None):\n        \"\"\"\n        Convenience Function to create a touch button on the top right side of the screen\n        \"\"\"\n        if color is None:\n            color = \"#fff\"\n        return cls(key=\"r\", layout={\"key\": \"r\", \"color\": color, \"preset\": \"top_right\"})\n</code></pre>"},{"location":"reference/sweetbean/extension/TouchButton/#sweetbean.extension.TouchButton.TouchButton.__init__","title":"<code>__init__(key, layout)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>key</code> <p>the key that is emulated by the touch button</p> required <code>layout</code> <p>the layout of the touch button</p> required Source code in <code>sweetbean/extension/TouchButton.py</code> <pre><code>def __init__(self, key, layout):\n    \"\"\"\n    Arguments:\n        key: the key that is emulated by the touch button\n        layout: the layout of the touch button\n    \"\"\"\n    self.key = key\n    self.layout = layout\n</code></pre>"},{"location":"reference/sweetbean/extension/TouchButton/#sweetbean.extension.TouchButton.TouchButton.bottom_left","title":"<code>bottom_left(color=None)</code>  <code>classmethod</code>","text":"<p>Convenience Function to create a touch button on the bottom left side of the screen</p> Source code in <code>sweetbean/extension/TouchButton.py</code> <pre><code>@classmethod\ndef bottom_left(cls, color=None):\n    \"\"\"\n    Convenience Function to create a touch button on the bottom left side of the screen\n    \"\"\"\n    if color is None:\n        color = \"#fff\"\n    return cls(\n        key=\"l\", layout={\"key\": \"l\", \"color\": color, \"preset\": \"bottom_left\"}\n    )\n</code></pre>"},{"location":"reference/sweetbean/extension/TouchButton/#sweetbean.extension.TouchButton.TouchButton.bottom_right","title":"<code>bottom_right(color=None)</code>  <code>classmethod</code>","text":"<p>Convenience Function to create a touch button on the bottom right side of the screen</p> Source code in <code>sweetbean/extension/TouchButton.py</code> <pre><code>@classmethod\ndef bottom_right(cls, color=None):\n    \"\"\"\n    Convenience Function to create a touch button on the bottom right side of the screen\n    \"\"\"\n    if color is None:\n        color = \"#fff\"\n    return cls(\n        key=\"r\", layout={\"key\": \"r\", \"color\": color, \"preset\": \"bottom_right\"}\n    )\n</code></pre>"},{"location":"reference/sweetbean/extension/TouchButton/#sweetbean.extension.TouchButton.TouchButton.left","title":"<code>left(color=None)</code>  <code>classmethod</code>","text":"<p>Convenience Function to create a touch button on the left side of the screen</p> Source code in <code>sweetbean/extension/TouchButton.py</code> <pre><code>@classmethod\ndef left(cls, color=None):\n    \"\"\"\n    Convenience Function to create a touch button on the left side of the screen\n    \"\"\"\n    if color is None:\n        color = \"#fff\"\n    return cls(key=\"l\", layout={\"key\": \"l\", \"color\": color, \"preset\": \"left\"})\n</code></pre>"},{"location":"reference/sweetbean/extension/TouchButton/#sweetbean.extension.TouchButton.TouchButton.right","title":"<code>right(color=None)</code>  <code>classmethod</code>","text":"<p>Convenience Function to create a touch button on the right side of the screen</p> Source code in <code>sweetbean/extension/TouchButton.py</code> <pre><code>@classmethod\ndef right(cls, color=None):\n    \"\"\"\n    Convenience Function to create a touch button on the right side of the screen\n    \"\"\"\n    if color is None:\n        color = \"#fff\"\n    return cls(key=\"r\", layout={\"key\": \"r\", \"color\": color, \"preset\": \"right\"})\n</code></pre>"},{"location":"reference/sweetbean/extension/TouchButton/#sweetbean.extension.TouchButton.TouchButton.top_left","title":"<code>top_left(color=None)</code>  <code>classmethod</code>","text":"<p>Convenience Function to create a touch button on the top left side of the screen</p> Source code in <code>sweetbean/extension/TouchButton.py</code> <pre><code>@classmethod\ndef top_left(cls, color=None):\n    \"\"\"\n    Convenience Function to create a touch button on the top left side of the screen\n    \"\"\"\n    if color is None:\n        color = \"#fff\"\n    return cls(key=\"l\", layout={\"key\": \"l\", \"color\": color, \"preset\": \"top_left\"})\n</code></pre>"},{"location":"reference/sweetbean/extension/TouchButton/#sweetbean.extension.TouchButton.TouchButton.top_right","title":"<code>top_right(color=None)</code>  <code>classmethod</code>","text":"<p>Convenience Function to create a touch button on the top right side of the screen</p> Source code in <code>sweetbean/extension/TouchButton.py</code> <pre><code>@classmethod\ndef top_right(cls, color=None):\n    \"\"\"\n    Convenience Function to create a touch button on the top right side of the screen\n    \"\"\"\n    if color is None:\n        color = \"#fff\"\n    return cls(key=\"r\", layout={\"key\": \"r\", \"color\": color, \"preset\": \"top_right\"})\n</code></pre>"},{"location":"reference/sweetbean/llm_utils/","title":"sweetbean.llm_utils","text":""},{"location":"reference/sweetbean/llm_utils/prompts/","title":"sweetbean.llm_utils.prompts","text":""},{"location":"reference/sweetbean/llm_utils/prompts/#sweetbean.llm_utils.prompts.demographic","title":"<code>demographic(age, gender)</code>","text":"<p>Creates a personalized message using age and gender.</p> <p>Parameters:</p> Name Type Description Default <code>age</code> <code>int</code> <p>The age of the individual.</p> required <code>gender</code> <code>str</code> <p>The gender of the individual (e.g., 'man', 'woman').</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>A formatted message based on the given demographics.</p> Example <p>demographic(52, 'woman') 'You are a 52-year-old woman.'</p> Source code in <code>sweetbean/llm_utils/prompts.py</code> <pre><code>def demographic(age, gender):\n    \"\"\"\n    Creates a personalized message using age and gender.\n\n    Parameters:\n        age (int): The age of the individual.\n        gender (str): The gender of the individual (e.g., 'man', 'woman').\n\n    Returns:\n        str: A formatted message based on the given demographics.\n\n    Example:\n        &gt;&gt;&gt; demographic(52, 'woman')\n        'You are a 52-year-old woman.'\n\n    \"\"\"\n\n    # Template for generating the message\n    template = \"You are a {{ age }}-year-old {{ gender }}.\"\n\n    # Render the template with local variables\n    return Template(template).render(age=age, gender=gender)\n</code></pre>"},{"location":"reference/sweetbean/stimulus/","title":"sweetbean.stimulus","text":""},{"location":"reference/sweetbean/stimulus/Choice/","title":"sweetbean.stimulus.Choice","text":""},{"location":"reference/sweetbean/stimulus/Choice/#sweetbean.stimulus.Choice.Bandit","title":"<code>Bandit</code>","text":"<p>               Bases: <code>HtmlChoice</code></p> <p>Multi-armed bandit screen built on HtmlChoice.</p> <p>Displays N colored \u201cslot machine\u201d squares laid out in a grid. Clicking a square selects that bandit. The grid HTML and the <code>values</code> array are generated from <code>bandits=[{\"color\": &lt;css_color&gt;, \"value\": &lt;number/label&gt;}, ...]</code>. Records the selected index as <code>choice</code> and its associated <code>value</code>, mirrored to <code>bean_response</code> and <code>bean_value</code>. Exposes a short post-response window that shows the value of the chosen bandit.</p> Source code in <code>sweetbean/stimulus/Choice.py</code> <pre><code>class Bandit(HtmlChoice):\n    \"\"\"\n    Multi-armed bandit screen built on HtmlChoice.\n\n    Displays N colored \u201cslot machine\u201d squares laid out in a grid. Clicking a square\n    selects that bandit. The grid HTML and the `values` array are generated from\n    `bandits=[{\"color\": &lt;css_color&gt;, \"value\": &lt;number/label&gt;}, ...]`. Records the\n    selected index as `choice` and its associated `value`, mirrored to `bean_response`\n    and `bean_value`. Exposes a short post-response window that shows the value of the\n    chosen bandit.\n    \"\"\"\n\n    type = \"jsPsychHtmlChoice\"\n\n    def __init__(\n        self,\n        duration=None,\n        bandits=None,\n        time_after_response=2000,\n        side_effects=None,\n    ):\n        \"\"\"\n        Arguments:\n            duration (int | None): Stimulus display time in ms. If None, runs until a bandit is\n                chosen.\n            bandits (list): List of dicts, each with:\n                - color (str): CSS color to outline the square\n                - value (any): payout/label recorded when the bandit is chosen\n            time_after_response (int): Extra time in ms after a click for \u201cslot machine\u201d animation.\n            side_effects (dict | None): Optional side-effect configuration.\n\n        Layout &amp; styling:\n            - Squares are arranged in a near-square grid (rows \u00d7 cols) computed from N.\n            - CSS custom properties are set before the trial:\n                --slotmachine-time, --slotmachine-time-after  (both ~ time_after_response/2)\n\n        Emits (adds to jsPsych data) \u2014 same as HtmlChoice:\n            - choice (int), value (any), bean_response (int), bean_value (any)\n        \"\"\"\n        if bandits is None:\n            bandits = []\n\n        def bandits_to_html(bdts):\n            n = len(bdts)\n            cols = math.ceil(math.sqrt(n))\n            rows = math.ceil(n / cols)\n\n            # Calculate square size\n            square_width = (100 - (cols + 1) * 10) / cols\n            square_height = (100 - (rows + 1) * 10) / rows\n            square_size = min(square_width, square_height)\n\n            # Generate square positions\n            positions = []\n            for r in range(rows):\n                # Calculate the number of squares in this row\n                if r == rows - 1 and n % cols != 0:  # Last row and it's not full\n                    row_squares = n % cols\n                else:\n                    row_squares = cols\n\n                # Calculate the starting x position to center the row\n                total_row_width = row_squares * square_size + (row_squares - 1) * 10\n                start_x = (100 - total_row_width) / 2\n\n                for c in range(row_squares):\n                    x = start_x + c * (square_size + 10)\n                    y = 10 + r * (square_size + 10)\n                    positions.append((x, y, square_size))\n            html = []\n            for bdt, p in zip(bdts, positions):\n                html.append(\n                    f'&lt;div class=\"slotmachine\" '\n                    f'style=\"position: absolute; top:{p[1]}vh; left:{p[0]}vw; '\n                    f'width: {p[2]}vw; height: {p[2]}vh; border-color: {bdt[\"color\"]}\"&gt;'\n                    f\"&lt;/div&gt;\"\n                )\n            return html\n\n        def vals(bdts):\n            return [b[\"value\"] for b in bdts]\n\n        html_array = FunctionVariable(\"html_array\", bandits_to_html, [bandits])\n        values = FunctionVariable(\"values\", vals, [bandits])\n\n        super().__init__(\n            duration=duration,\n            html_array=html_array,\n            values=values,\n            time_after_response=time_after_response,\n            side_effects=side_effects,\n        )\n        self.arg.update({\"bandits\": bandits})\n\n    def _set_before(self):\n        res = \"const root=document.documentElement;\"\n        res += (\n            f'root.style.setProperty(\"--slotmachine-time\",'\n            f'`${{({to_js(self.arg_js[\"time_after_response\"])})/2}}ms`);'\n        )\n        res += (\n            f'root.style.setProperty(\"--slotmachine-time-after\",'\n            f'`${{({to_js(self.arg_js[\"time_after_response\"])})/2}}ms`);'\n        )\n        self.js_before = f\"on_load:()=&gt;{{{res}}},\"\n\n    def process_l(self, prompts, get_input, multi_turn, datum=None):\n        current_prompt = f' You see {len(self.l_args[\"bandits\"])} bandits.'\n        for idx, bandit in enumerate(self.l_args[\"bandits\"]):\n            current_prompt += f' Bandit {idx + 1} is {bandit[\"color\"]}.'\n        current_prompt += (\n            \" Choose a bandit by naming the number of the bandit. You name \"\n        )\n        if not multi_turn:\n            in_prompt = \" \".join([p for p in prompts]) + current_prompt + \"&lt;&lt;\"\n        else:\n            in_prompt = current_prompt + \"&lt;&lt;\"\n        rest_data = None\n        if not datum:\n            _r = get_input(in_prompt)\n            if isinstance(_r, str):\n                response = _r\n            elif isinstance(_r, dict):\n                if \"response\" not in _r:\n                    raise Exception(f\"{_r} has an invalid response format\")\n                response = _r[\"response\"]\n                _r.pop(\"response\")\n                rest_data = _r\n\n            else:\n                raise Exception(f\"{_r} has an invalid response format\")\n            # response = get_input(in_prompt)\n        else:\n            response = datum[\"response\"] + 1\n        if int(response) &lt; 1 or int(response) &gt; len(self.l_args[\"bandits\"]):\n            prompts.append(\n                current_prompt + f\"&lt;&lt;{response}&gt;&gt;. \" f\"The response was invalid.\"\n            )\n            value = 0\n        else:\n            prompts.append(\n                current_prompt + f\"&lt;&lt;{response}&gt;&gt;. \"\n                f\"The value of the chosen bandit was {self.l_args['values'][int(response) - 1]}.\"\n            )\n            value = self.l_args[\"values\"][int(response) - 1]\n        data = self.l_args.copy()\n        data.update(\n            {\n                \"response\": int(response) - 1,\n                \"value\": value,\n            }\n        )\n        if rest_data:\n            data.update(rest_data)\n        return data, prompts\n</code></pre>"},{"location":"reference/sweetbean/stimulus/Choice/#sweetbean.stimulus.Choice.Bandit.__init__","title":"<code>__init__(duration=None, bandits=None, time_after_response=2000, side_effects=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>duration</code> <code>int | None</code> <p>Stimulus display time in ms. If None, runs until a bandit is chosen.</p> <code>None</code> <code>bandits</code> <code>list</code> <p>List of dicts, each with: - color (str): CSS color to outline the square - value (any): payout/label recorded when the bandit is chosen</p> <code>None</code> <code>time_after_response</code> <code>int</code> <p>Extra time in ms after a click for \u201cslot machine\u201d animation.</p> <code>2000</code> <code>side_effects</code> <code>dict | None</code> <p>Optional side-effect configuration.</p> <code>None</code> <p>Layout &amp; styling:     - Squares are arranged in a near-square grid (rows \u00d7 cols) computed from N.     - CSS custom properties are set before the trial:         --slotmachine-time, --slotmachine-time-after  (both ~ time_after_response/2)</p> <p>Emits (adds to jsPsych data) \u2014 same as HtmlChoice:     - choice (int), value (any), bean_response (int), bean_value (any)</p> Source code in <code>sweetbean/stimulus/Choice.py</code> <pre><code>def __init__(\n    self,\n    duration=None,\n    bandits=None,\n    time_after_response=2000,\n    side_effects=None,\n):\n    \"\"\"\n    Arguments:\n        duration (int | None): Stimulus display time in ms. If None, runs until a bandit is\n            chosen.\n        bandits (list): List of dicts, each with:\n            - color (str): CSS color to outline the square\n            - value (any): payout/label recorded when the bandit is chosen\n        time_after_response (int): Extra time in ms after a click for \u201cslot machine\u201d animation.\n        side_effects (dict | None): Optional side-effect configuration.\n\n    Layout &amp; styling:\n        - Squares are arranged in a near-square grid (rows \u00d7 cols) computed from N.\n        - CSS custom properties are set before the trial:\n            --slotmachine-time, --slotmachine-time-after  (both ~ time_after_response/2)\n\n    Emits (adds to jsPsych data) \u2014 same as HtmlChoice:\n        - choice (int), value (any), bean_response (int), bean_value (any)\n    \"\"\"\n    if bandits is None:\n        bandits = []\n\n    def bandits_to_html(bdts):\n        n = len(bdts)\n        cols = math.ceil(math.sqrt(n))\n        rows = math.ceil(n / cols)\n\n        # Calculate square size\n        square_width = (100 - (cols + 1) * 10) / cols\n        square_height = (100 - (rows + 1) * 10) / rows\n        square_size = min(square_width, square_height)\n\n        # Generate square positions\n        positions = []\n        for r in range(rows):\n            # Calculate the number of squares in this row\n            if r == rows - 1 and n % cols != 0:  # Last row and it's not full\n                row_squares = n % cols\n            else:\n                row_squares = cols\n\n            # Calculate the starting x position to center the row\n            total_row_width = row_squares * square_size + (row_squares - 1) * 10\n            start_x = (100 - total_row_width) / 2\n\n            for c in range(row_squares):\n                x = start_x + c * (square_size + 10)\n                y = 10 + r * (square_size + 10)\n                positions.append((x, y, square_size))\n        html = []\n        for bdt, p in zip(bdts, positions):\n            html.append(\n                f'&lt;div class=\"slotmachine\" '\n                f'style=\"position: absolute; top:{p[1]}vh; left:{p[0]}vw; '\n                f'width: {p[2]}vw; height: {p[2]}vh; border-color: {bdt[\"color\"]}\"&gt;'\n                f\"&lt;/div&gt;\"\n            )\n        return html\n\n    def vals(bdts):\n        return [b[\"value\"] for b in bdts]\n\n    html_array = FunctionVariable(\"html_array\", bandits_to_html, [bandits])\n    values = FunctionVariable(\"values\", vals, [bandits])\n\n    super().__init__(\n        duration=duration,\n        html_array=html_array,\n        values=values,\n        time_after_response=time_after_response,\n        side_effects=side_effects,\n    )\n    self.arg.update({\"bandits\": bandits})\n</code></pre>"},{"location":"reference/sweetbean/stimulus/Choice/#sweetbean.stimulus.Choice.HtmlChoice","title":"<code>HtmlChoice</code>","text":"<p>               Bases: <code>_BaseStimulus</code></p> <p>Clickable HTML choice screen.</p> <p>Renders an array of arbitrary HTML elements; a mouse click selects one item. Records <code>choice</code> (0-based index) and <code>value</code> of the selected item from the provided lists, and mirrors them to <code>bean_response</code> and <code>bean_value</code>. Supports an optional post-response delay to allow animations to complete.</p> Source code in <code>sweetbean/stimulus/Choice.py</code> <pre><code>class HtmlChoice(_BaseStimulus):\n    \"\"\"\n    Clickable HTML choice screen.\n\n    Renders an array of arbitrary HTML elements; a mouse click selects one item.\n    Records `choice` (0-based index) and `value` of the selected item from the\n    provided lists, and mirrors them to `bean_response` and `bean_value`.\n    Supports an optional post-response delay to allow animations to complete.\n    \"\"\"\n\n    type = \"jsPsychHtmlChoice\"\n\n    def __init__(\n        self,\n        duration=None,\n        html_array=None,\n        values=None,\n        time_after_response=3000,\n        side_effects=None,\n    ):\n        \"\"\"\n        Arguments:\n            duration (int | None): Stimulus display time in ms. If None, runs until a choice is\n                made.\n            html_array (list): List of HTML strings to display as clickable options. Must align 1:1\n                with `values`.\n            values (list): List of opaque values (numbers/strings/objects) mapped to `html_array`\n                items. The selected entry is emitted as both `value` and `bean_value`.\n            time_after_response (int): Extra time in ms after a click before ending the trial\n                (useful for short animations/visual confirmation).\n            side_effects Optional side-effect configuration passed to the runtime. This expects\n                a list of SideEffect definitions (see SweetBean docs) which can be\n                used to update global data like overall score or trial counter.\n\n        Emits (adds to jsPsych data):\n            - choice (int): 0-based index of the clicked item\n            - value (any): the corresponding entry from `values`\n            - bean_response (int): copy of `choice` for downstream consistency\n            - bean_value (any): copy of `value`\n\n        Notes:\n            - `len(html_array)` should equal `len(values)`. Empty lists are allowed but will yield\n                no clickable options.\n            - This stimulus collects responses via mouse/touch clicks on the provided elements.\n        \"\"\"\n        if values is None:\n            values = []\n        if html_array is None:\n            html_array = []\n        super().__init__(locals(), side_effects)\n\n    def _add_special_param(self):\n        pass\n\n    def _process_response(self):\n        self.js_data += 'data[\"bean_value\"] = data[\"value\"];'\n        self.js_data += 'data[\"bean_response\"] = data[\"choice\"];'\n\n    def _set_before(self):\n        pass\n\n    def process_l(self, prompts, get_input, multi_turn):\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/sweetbean/stimulus/Choice/#sweetbean.stimulus.Choice.HtmlChoice.__init__","title":"<code>__init__(duration=None, html_array=None, values=None, time_after_response=3000, side_effects=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>duration</code> <code>int | None</code> <p>Stimulus display time in ms. If None, runs until a choice is made.</p> <code>None</code> <code>html_array</code> <code>list</code> <p>List of HTML strings to display as clickable options. Must align 1:1 with <code>values</code>.</p> <code>None</code> <code>values</code> <code>list</code> <p>List of opaque values (numbers/strings/objects) mapped to <code>html_array</code> items. The selected entry is emitted as both <code>value</code> and <code>bean_value</code>.</p> <code>None</code> <code>time_after_response</code> <code>int</code> <p>Extra time in ms after a click before ending the trial (useful for short animations/visual confirmation).</p> <code>3000</code> <p>Emits (adds to jsPsych data):     - choice (int): 0-based index of the clicked item     - value (any): the corresponding entry from <code>values</code>     - bean_response (int): copy of <code>choice</code> for downstream consistency     - bean_value (any): copy of <code>value</code></p> Notes <ul> <li><code>len(html_array)</code> should equal <code>len(values)</code>. Empty lists are allowed but will yield     no clickable options.</li> <li>This stimulus collects responses via mouse/touch clicks on the provided elements.</li> </ul> Source code in <code>sweetbean/stimulus/Choice.py</code> <pre><code>def __init__(\n    self,\n    duration=None,\n    html_array=None,\n    values=None,\n    time_after_response=3000,\n    side_effects=None,\n):\n    \"\"\"\n    Arguments:\n        duration (int | None): Stimulus display time in ms. If None, runs until a choice is\n            made.\n        html_array (list): List of HTML strings to display as clickable options. Must align 1:1\n            with `values`.\n        values (list): List of opaque values (numbers/strings/objects) mapped to `html_array`\n            items. The selected entry is emitted as both `value` and `bean_value`.\n        time_after_response (int): Extra time in ms after a click before ending the trial\n            (useful for short animations/visual confirmation).\n        side_effects Optional side-effect configuration passed to the runtime. This expects\n            a list of SideEffect definitions (see SweetBean docs) which can be\n            used to update global data like overall score or trial counter.\n\n    Emits (adds to jsPsych data):\n        - choice (int): 0-based index of the clicked item\n        - value (any): the corresponding entry from `values`\n        - bean_response (int): copy of `choice` for downstream consistency\n        - bean_value (any): copy of `value`\n\n    Notes:\n        - `len(html_array)` should equal `len(values)`. Empty lists are allowed but will yield\n            no clickable options.\n        - This stimulus collects responses via mouse/touch clicks on the provided elements.\n    \"\"\"\n    if values is None:\n        values = []\n    if html_array is None:\n        html_array = []\n    super().__init__(locals(), side_effects)\n</code></pre>"},{"location":"reference/sweetbean/stimulus/Foraging/","title":"sweetbean.stimulus.Foraging","text":""},{"location":"reference/sweetbean/stimulus/Foraging/#sweetbean.stimulus.Foraging.Foraging","title":"<code>Foraging</code>","text":"<p>               Bases: <code>_BaseStimulus</code></p> <p>Visual Foraging stimulus (wraps @sweet-jspsych/plugin-foraging)</p> Arrays-only API <ul> <li>targets:     list[ItemSpec]</li> <li>distractors: list[ItemSpec]</li> </ul> <p>ItemSpec fields (each item defines ONE of {html|text|shape|src}, plus options):   - html: str   - text: str   - shape: Literal[\"circle\",\"square\",\"triangle\"]   - src: str   - color: str                      # overrides overlay_pool sampling   - rotationDeg: int                # overrides rotation_pool sampling   - pos: dict                       # {mode:\"abs\"|\"grid\"|\"circle\", ...}   - size: str                       # e.g., \"12vmin\"   - fontSize: str   - id: str   - attrs: dict[str,str]</p> Notes <ul> <li>By default, randomized non-overlapping placement in a centered square arena.</li> <li>Trial ends when all targets found unless you change <code>end_when_found=False</code>   or set an explicit <code>trial_duration</code>.</li> </ul> Source code in <code>sweetbean/stimulus/Foraging.py</code> <pre><code>class Foraging(_BaseStimulus):\n    \"\"\"\n    Visual Foraging stimulus (wraps @sweet-jspsych/plugin-foraging)\n\n    Arrays-only API:\n      - targets:     list[ItemSpec]\n      - distractors: list[ItemSpec]\n\n    ItemSpec fields (each item defines ONE of {html|text|shape|src}, plus options):\n      - html: str\n      - text: str\n      - shape: Literal[\"circle\",\"square\",\"triangle\"]\n      - src: str\n      - color: str                      # overrides overlay_pool sampling\n      - rotationDeg: int                # overrides rotation_pool sampling\n      - pos: dict                       # {mode:\"abs\"|\"grid\"|\"circle\", ...}\n      - size: str                       # e.g., \"12vmin\"\n      - fontSize: str\n      - id: str\n      - attrs: dict[str,str]\n\n    Notes:\n      - By default, randomized non-overlapping placement in a centered square arena.\n      - Trial ends when all targets found unless you change `end_when_found=False`\n        or set an explicit `trial_duration`.\n    \"\"\"\n\n    # IMPORTANT: For SweetBean, keep a string \"type\" so SweetBean emits\n    # a declarative config object. The browser bundle must set window.jsPsychForaging.\n    type = \"jsPsychForaging\"\n\n    def __init__(\n        self,\n        # Required-ish (can be empty)\n        targets: Optional[Union[List[Dict[str, Any]], TimelineVariable]] = None,\n        distractors: Optional[Union[List[Dict[str, Any]], TimelineVariable]] = None,\n        # Layout &amp; placement\n        position_mode: str = \"random\",  # \"random\" | \"grid\" | \"circle\"\n        grid_cols: Optional[int] = None,\n        grid_rows: Optional[int] = None,\n        ring_radius_vmin: float = 30,\n        randomize_positions: bool = True,  # grid/circle only\n        # Arena &amp; spacing\n        arena_size_vmin: float = 92,  # centered square side (vmin)\n        placement_inset_vmin: float = 6,  # inner margin\n        min_gap_vmin: float = 2.5,  # extra pairwise gap\n        # Visuals\n        background: str = \"#000000\",  # default black\n        color: str = \"#ffffff\",  # default foreground (text/border)\n        token_box_size: str = \"12vmin\",\n        token_font_size: str = \"10vmin\",\n        # Pools (defaults are in the plugin too; pass to control sampling)\n        overlay_pool: Optional[List[str]] = None,\n        rotation_pool: Optional[List[int]] = None,\n        # Timing &amp; control\n        trial_duration: Optional[\n            int\n        ] = None,  # None =&gt; ends when all targets found (if end_when_found=True)\n        end_when_found: bool = True,\n        response_ends_trial: bool = False,\n        # Determinism\n        seed: Optional[int] = None,\n        # Feedback\n        show_star_feedback: bool = False,  # OFF by default\n        star_color: str = \"#f6b500\",\n        # Hooks / triggers\n        # Example: {\"on_all_targets_collected\": \"end_trial\"}\n        triggers: Optional[Dict[str, Any]] = None,\n        # SweetBean convenience\n        duration: Optional[int] = None,  # mirrors RSVP: alias for trial_duration\n        side_effects: Optional[Dict[str, Any]] = None,\n    ):\n        \"\"\"\n        Arguments:\n            targets (list[dict] | TimelineVariable | None):\n                Trial\u2019s target items. Accepts a concrete list or a TimelineVariable\n                that evaluates per trial to a list. Each item is an ItemSpec dict\n                that defines exactly ONE of {html | text | shape | src} plus\n                optional styling/placement fields:\n\n                  Content (choose exactly one)\n                  - html (str): Raw HTML.\n                  - text (str): Plain text (rendered in a token box).\n                  - shape (str): One of \"circle\", \"square\", \"triangle\".\n                  - src (str): Image URL/path.\n\n                  Optional appearance/identity\n                  - color (str): CSS color; overrides overlay_pool sampling.\n                  - rotationDeg (int): Rotation in degrees; overrides rotation_pool.\n                  - size (str): CSS size of the token box (e.g., \"12vmin\").\n                  - fontSize (str): For text content (e.g., \"10vmin\").\n                  - id (str): Opaque label copied to data.\n                  - attrs (dict[str,str]): Arbitrary HTML attributes.\n\n                  Placement override (optional; else global placement rules apply)\n                  - pos (dict): One of the following shapes:\n                        {\"mode\": \"abs\", \"x_vmin\": &lt;float&gt;, \"y_vmin\": &lt;float&gt;}\n                        {\"mode\": \"grid\", \"row\": &lt;int&gt;, \"col\": &lt;int&gt;}\n                        {\"mode\": \"circle\", \"angle_deg\": &lt;float&gt;, \"radius_vmin\": &lt;float&gt;}\n\n            distractors (list[dict] | TimelineVariable | None):\n                Same ItemSpec structure as `targets`. May be empty.\n\n            position_mode (str):\n                Global placement policy when items don\u2019t provide an explicit `pos`.\n                One of \"random\" | \"grid\" | \"circle\". Default \"random\".\n            grid_cols (int | None):\n                Number of columns for \"grid\" placement. If None, inferred from count.\n            grid_rows (int | None):\n                Number of rows for \"grid\" placement. If None, inferred from count.\n            ring_radius_vmin (float):\n                Ring radius for \"circle\" placement, in vmin units. Default 30.\n            randomize_positions (bool):\n                If True, jitter positions within the grid cell / along the ring for\n                \"grid\"/\"circle\" modes. Default True.\n\n            arena_size_vmin (float):\n                Side length (vmin) of the centered square arena. Default 92.\n            placement_inset_vmin (float):\n                Inner safety margin from arena edges. Default 6.\n            min_gap_vmin (float):\n                Extra minimum pairwise spacing between item centers. Default 2.5.\n\n            background (str):\n                Arena background color. Default \"#000000\".\n            color (str):\n                Default foreground color (text/borders). Default \"#ffffff\".\n            token_box_size (str):\n                Default token box size (CSS). Default \"12vmin\".\n            token_font_size (str):\n                Default font size for text tokens (CSS). Default \"10vmin\".\n\n            overlay_pool (list[str] | None):\n                Optional pool of overlay symbols/colors; sampled per item unless the\n                ItemSpec provides an explicit `color`. Omit/None to use plugin defaults.\n            rotation_pool (list[int] | None):\n                Optional pool of rotations in degrees; sampled per item unless the\n                ItemSpec provides `rotationDeg`. Omit/None to use plugin defaults.\n\n            trial_duration (int | None):\n                Hard timeout in ms. If None and `end_when_found=True`, the trial ends\n                when all targets are collected. Default None.\n            end_when_found (bool):\n                If True, automatically end the trial once all targets are found.\n                Default True.\n            response_ends_trial (bool):\n                If True, any user interaction that counts as a response ends the trial,\n                even if not all targets are collected. Default False.\n\n            seed (int | None):\n                Seed for deterministic placement/sampling. Default None.\n\n            show_star_feedback (bool):\n                If True, briefly show a star animation on successful target clicks.\n                Default False.\n            star_color (str):\n                Star feedback color. Default \"#f6b500\".\n\n            triggers (dict | None):\n                Optional event\u2192action mapping, e.g.,\n                {\"on_all_targets_collected\": \"end_trial\"}.\n                Default: {\"on_all_targets_collected\": \"end_trial\"}.\n\n            duration (int | None):\n                SweetBean convenience alias mirrored to `trial_duration` during build\n                (consistent with RSVP). If provided, `trial_duration` is set to this\n                value. Default None.\n            side_effects: Optional side-effect configuration passed to the runtime. This expects\n                a list of SideEffect definitions (see SweetBean docs) which can be\n                used to update global data like overall score or trial counter.\n\n        Emits (added to jsPsych data):\n            - clicks (list[dict]): Raw click events ({kind, index, id?, t}).\n            - n_targets (int): Number of target items in the trial.\n            - n_collected (int): Number of targets collected.\n            - tps (list[number]): Timestamps for target pickups.\n            - bean_clicks (list[dict]): Mirror of `clicks`.\n            - bean_n_targets (int): Mirror of `n_targets`.\n            - bean_n_found (int): Mirror of `n_collected`.\n            - bean_tps (list[number]): Mirror of `tps`.\n            - bean_all_found (bool): Convenience flag (n_collected &gt;= n_targets).\n\n        Notes:\n            - Provide item-level `pos` to bypass global placement for specific items.\n            - If both `duration` and `trial_duration` are given, `duration` takes\n              precedence by being copied into `trial_duration`.\n            - Null/None optionals are dropped so the plugin falls back to its defaults.\n\n        Example:\n            from sweetbean import Block, Experiment\n            from sweetbean.variable import TimelineVariable\n\n            timeline = [\n                {\n                    \"targets\": [\n                        {\"text\": \"T\", \"color\": \"#66ff66\"},\n                        {\"shape\": \"circle\", \"color\": \"#66ff66\"},\n                    ],\n                    \"distractors\": [\n                        {\"text\": \"L\", \"color\": \"#ff6666\"},\n                        {\"shape\": \"square\", \"color\": \"#ff6666\"},\n                        {\"shape\": \"triangle\", \"color\": \"#ff6666\"},\n                    ],\n                }\n            ]\n\n            stim = Foraging(\n                targets=TimelineVariable(\"targets\"),\n                distractors=TimelineVariable(\"distractors\"),\n                position_mode=\"grid\",\n                grid_cols=6, grid_rows=4,\n                arena_size_vmin=90, min_gap_vmin=2.5,\n                background=\"#000000\", color=\"#ffffff\",\n                token_box_size=\"10vmin\", token_font_size=\"8vmin\",\n                end_when_found=True, response_ends_trial=False,\n                show_star_feedback=True, star_color=\"#f6b500\",\n            )\n\n            block = Block([stim], timeline=timeline)\n            Experiment([block]).to_html(\"foraging.html\")\n        \"\"\"\n\n        if targets is None:\n            targets = []\n        if distractors is None:\n            distractors = []\n        if triggers is None:\n            triggers = {\"on_all_targets_collected\": \"end_trial\"}\n\n        super().__init__(locals(), side_effects)\n\n    # ---- SweetBean hooks ----\n\n    def _add_special_param(self):\n        # Use SweetBean `duration` as jsPsych `trial_duration` (consistent with RSVP).\n        if self.arg_js.get(\"duration\") not in (None, \"null\"):\n            self.arg_js[\"trial_duration\"] = self.arg_js[\"duration\"]\n\n        # If user didn\u2019t specify pools, omit them; plugin will fall back to its defaults.\n        if not self.arg_js.get(\"overlay_pool\"):\n            self.arg_js.pop(\"overlay_pool\", None)\n        if not self.arg_js.get(\"rotation_pool\"):\n            self.arg_js.pop(\"rotation_pool\", None)\n\n        # Keep `type` as string so SweetBean emits declarative config\n        self.arg_js[\"type\"] = self.type\n\n    def _process_response(self):\n        # Convenience mirrors (prefixed with bean_)\n        # clicks is already an array of {kind,index,id?,t}\n        self.js_data += 'data[\"bean_clicks\"] = data[\"clicks\"];'\n        self.js_data += 'data[\"bean_n_targets\"] = data[\"n_targets\"];'\n        self.js_data += 'data[\"bean_n_found\"] = data[\"n_collected\"];'\n        self.js_data += 'data[\"bean_tps\"] = data[\"tps\"];'\n        # quick all-found boolean\n        self.js_data += (\n            'data[\"bean_all_found\"] = (data[\"n_collected\"] &gt;= data[\"n_targets\"]);'\n        )\n\n    def _set_before(self):\n        # No extra on_load code required; SweetBean preamble already sets document bg.\n        pass\n\n    # Language mode not supported (same as RSVP)\n    def process_l(self, prompts, get_input, multi_turn, datum=None):\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/sweetbean/stimulus/Foraging/#sweetbean.stimulus.Foraging.Foraging.__init__","title":"<code>__init__(targets=None, distractors=None, position_mode='random', grid_cols=None, grid_rows=None, ring_radius_vmin=30, randomize_positions=True, arena_size_vmin=92, placement_inset_vmin=6, min_gap_vmin=2.5, background='#000000', color='#ffffff', token_box_size='12vmin', token_font_size='10vmin', overlay_pool=None, rotation_pool=None, trial_duration=None, end_when_found=True, response_ends_trial=False, seed=None, show_star_feedback=False, star_color='#f6b500', triggers=None, duration=None, side_effects=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>targets</code> <code>list[dict] | TimelineVariable | None</code> <p>Trial\u2019s target items. Accepts a concrete list or a TimelineVariable that evaluates per trial to a list. Each item is an ItemSpec dict that defines exactly ONE of {html | text | shape | src} plus optional styling/placement fields:</p> <p>Content (choose exactly one)   - html (str): Raw HTML.   - text (str): Plain text (rendered in a token box).   - shape (str): One of \"circle\", \"square\", \"triangle\".   - src (str): Image URL/path.</p> <p>Optional appearance/identity   - color (str): CSS color; overrides overlay_pool sampling.   - rotationDeg (int): Rotation in degrees; overrides rotation_pool.   - size (str): CSS size of the token box (e.g., \"12vmin\").   - fontSize (str): For text content (e.g., \"10vmin\").   - id (str): Opaque label copied to data.   - attrs (dict[str,str]): Arbitrary HTML attributes.</p> <p>Placement override (optional; else global placement rules apply)   - pos (dict): One of the following shapes:         {\"mode\": \"abs\", \"x_vmin\": , \"y_vmin\": }         {\"mode\": \"grid\", \"row\": , \"col\": } <code>None</code> <code>distractors</code> <code>list[dict] | TimelineVariable | None</code> <p>Same ItemSpec structure as <code>targets</code>. May be empty.</p> <code>None</code> <code>position_mode</code> <code>str</code> <p>Global placement policy when items don\u2019t provide an explicit <code>pos</code>. One of \"random\" | \"grid\" | \"circle\". Default \"random\".</p> <code>'random'</code> <code>grid_cols</code> <code>int | None</code> <p>Number of columns for \"grid\" placement. If None, inferred from count.</p> <code>None</code> <code>grid_rows</code> <code>int | None</code> <p>Number of rows for \"grid\" placement. If None, inferred from count.</p> <code>None</code> <code>ring_radius_vmin</code> <code>float</code> <p>Ring radius for \"circle\" placement, in vmin units. Default 30.</p> <code>30</code> <code>randomize_positions</code> <code>bool</code> <p>If True, jitter positions within the grid cell / along the ring for \"grid\"/\"circle\" modes. Default True.</p> <code>True</code> <code>arena_size_vmin</code> <code>float</code> <p>Side length (vmin) of the centered square arena. Default 92.</p> <code>92</code> <code>placement_inset_vmin</code> <code>float</code> <p>Inner safety margin from arena edges. Default 6.</p> <code>6</code> <code>min_gap_vmin</code> <code>float</code> <p>Extra minimum pairwise spacing between item centers. Default 2.5.</p> <code>2.5</code> <code>background</code> <code>str</code> <p>Arena background color. Default \"#000000\".</p> <code>'#000000'</code> <code>color</code> <code>str</code> <p>Default foreground color (text/borders). Default \"#ffffff\".</p> <code>'#ffffff'</code> <code>token_box_size</code> <code>str</code> <p>Default token box size (CSS). Default \"12vmin\".</p> <code>'12vmin'</code> <code>token_font_size</code> <code>str</code> <p>Default font size for text tokens (CSS). Default \"10vmin\".</p> <code>'10vmin'</code> <code>overlay_pool</code> <code>list[str] | None</code> <p>Optional pool of overlay symbols/colors; sampled per item unless the ItemSpec provides an explicit <code>color</code>. Omit/None to use plugin defaults.</p> <code>None</code> <code>rotation_pool</code> <code>list[int] | None</code> <p>Optional pool of rotations in degrees; sampled per item unless the ItemSpec provides <code>rotationDeg</code>. Omit/None to use plugin defaults.</p> <code>None</code> <code>trial_duration</code> <code>int | None</code> <p>Hard timeout in ms. If None and <code>end_when_found=True</code>, the trial ends when all targets are collected. Default None.</p> <code>None</code> <code>end_when_found</code> <code>bool</code> <p>If True, automatically end the trial once all targets are found. Default True.</p> <code>True</code> <code>response_ends_trial</code> <code>bool</code> <p>If True, any user interaction that counts as a response ends the trial, even if not all targets are collected. Default False.</p> <code>False</code> <code>seed</code> <code>int | None</code> <p>Seed for deterministic placement/sampling. Default None.</p> <code>None</code> <code>show_star_feedback</code> <code>bool</code> <p>If True, briefly show a star animation on successful target clicks. Default False.</p> <code>False</code> <code>star_color</code> <code>str</code> <p>Star feedback color. Default \"#f6b500\".</p> <code>'#f6b500'</code> <code>triggers</code> <code>dict | None</code> <p>Optional event\u2192action mapping, e.g., {\"on_all_targets_collected\": \"end_trial\"}. Default: {\"on_all_targets_collected\": \"end_trial\"}.</p> <code>None</code> <code>duration</code> <code>int | None</code> <p>SweetBean convenience alias mirrored to <code>trial_duration</code> during build (consistent with RSVP). If provided, <code>trial_duration</code> is set to this value. Default None.</p> <code>None</code> <code>side_effects</code> <code>Optional[Dict[str, Any]]</code> <p>Optional side-effect configuration passed to the runtime. This expects a list of SideEffect definitions (see SweetBean docs) which can be used to update global data like overall score or trial counter.</p> <code>None</code> <p>Emits (added to jsPsych data):     - clicks (list[dict]): Raw click events ({kind, index, id?, t}).     - n_targets (int): Number of target items in the trial.     - n_collected (int): Number of targets collected.     - tps (list[number]): Timestamps for target pickups.     - bean_clicks (list[dict]): Mirror of <code>clicks</code>.     - bean_n_targets (int): Mirror of <code>n_targets</code>.     - bean_n_found (int): Mirror of <code>n_collected</code>.     - bean_tps (list[number]): Mirror of <code>tps</code>.     - bean_all_found (bool): Convenience flag (n_collected &gt;= n_targets).</p> Notes <ul> <li>Provide item-level <code>pos</code> to bypass global placement for specific items.</li> <li>If both <code>duration</code> and <code>trial_duration</code> are given, <code>duration</code> takes   precedence by being copied into <code>trial_duration</code>.</li> <li>Null/None optionals are dropped so the plugin falls back to its defaults.</li> </ul> Example <p>from sweetbean import Block, Experiment from sweetbean.variable import TimelineVariable</p> <p>timeline = [     {         \"targets\": [             {\"text\": \"T\", \"color\": \"#66ff66\"},             {\"shape\": \"circle\", \"color\": \"#66ff66\"},         ],         \"distractors\": [             {\"text\": \"L\", \"color\": \"#ff6666\"},             {\"shape\": \"square\", \"color\": \"#ff6666\"},             {\"shape\": \"triangle\", \"color\": \"#ff6666\"},         ],     } ]</p> <p>stim = Foraging(     targets=TimelineVariable(\"targets\"),     distractors=TimelineVariable(\"distractors\"),     position_mode=\"grid\",     grid_cols=6, grid_rows=4,     arena_size_vmin=90, min_gap_vmin=2.5,     background=\"#000000\", color=\"#ffffff\",     token_box_size=\"10vmin\", token_font_size=\"8vmin\",     end_when_found=True, response_ends_trial=False,     show_star_feedback=True, star_color=\"#f6b500\", )</p> <p>block = Block([stim], timeline=timeline) Experiment([block]).to_html(\"foraging.html\")</p> Source code in <code>sweetbean/stimulus/Foraging.py</code> <pre><code>def __init__(\n    self,\n    # Required-ish (can be empty)\n    targets: Optional[Union[List[Dict[str, Any]], TimelineVariable]] = None,\n    distractors: Optional[Union[List[Dict[str, Any]], TimelineVariable]] = None,\n    # Layout &amp; placement\n    position_mode: str = \"random\",  # \"random\" | \"grid\" | \"circle\"\n    grid_cols: Optional[int] = None,\n    grid_rows: Optional[int] = None,\n    ring_radius_vmin: float = 30,\n    randomize_positions: bool = True,  # grid/circle only\n    # Arena &amp; spacing\n    arena_size_vmin: float = 92,  # centered square side (vmin)\n    placement_inset_vmin: float = 6,  # inner margin\n    min_gap_vmin: float = 2.5,  # extra pairwise gap\n    # Visuals\n    background: str = \"#000000\",  # default black\n    color: str = \"#ffffff\",  # default foreground (text/border)\n    token_box_size: str = \"12vmin\",\n    token_font_size: str = \"10vmin\",\n    # Pools (defaults are in the plugin too; pass to control sampling)\n    overlay_pool: Optional[List[str]] = None,\n    rotation_pool: Optional[List[int]] = None,\n    # Timing &amp; control\n    trial_duration: Optional[\n        int\n    ] = None,  # None =&gt; ends when all targets found (if end_when_found=True)\n    end_when_found: bool = True,\n    response_ends_trial: bool = False,\n    # Determinism\n    seed: Optional[int] = None,\n    # Feedback\n    show_star_feedback: bool = False,  # OFF by default\n    star_color: str = \"#f6b500\",\n    # Hooks / triggers\n    # Example: {\"on_all_targets_collected\": \"end_trial\"}\n    triggers: Optional[Dict[str, Any]] = None,\n    # SweetBean convenience\n    duration: Optional[int] = None,  # mirrors RSVP: alias for trial_duration\n    side_effects: Optional[Dict[str, Any]] = None,\n):\n    \"\"\"\n    Arguments:\n        targets (list[dict] | TimelineVariable | None):\n            Trial\u2019s target items. Accepts a concrete list or a TimelineVariable\n            that evaluates per trial to a list. Each item is an ItemSpec dict\n            that defines exactly ONE of {html | text | shape | src} plus\n            optional styling/placement fields:\n\n              Content (choose exactly one)\n              - html (str): Raw HTML.\n              - text (str): Plain text (rendered in a token box).\n              - shape (str): One of \"circle\", \"square\", \"triangle\".\n              - src (str): Image URL/path.\n\n              Optional appearance/identity\n              - color (str): CSS color; overrides overlay_pool sampling.\n              - rotationDeg (int): Rotation in degrees; overrides rotation_pool.\n              - size (str): CSS size of the token box (e.g., \"12vmin\").\n              - fontSize (str): For text content (e.g., \"10vmin\").\n              - id (str): Opaque label copied to data.\n              - attrs (dict[str,str]): Arbitrary HTML attributes.\n\n              Placement override (optional; else global placement rules apply)\n              - pos (dict): One of the following shapes:\n                    {\"mode\": \"abs\", \"x_vmin\": &lt;float&gt;, \"y_vmin\": &lt;float&gt;}\n                    {\"mode\": \"grid\", \"row\": &lt;int&gt;, \"col\": &lt;int&gt;}\n                    {\"mode\": \"circle\", \"angle_deg\": &lt;float&gt;, \"radius_vmin\": &lt;float&gt;}\n\n        distractors (list[dict] | TimelineVariable | None):\n            Same ItemSpec structure as `targets`. May be empty.\n\n        position_mode (str):\n            Global placement policy when items don\u2019t provide an explicit `pos`.\n            One of \"random\" | \"grid\" | \"circle\". Default \"random\".\n        grid_cols (int | None):\n            Number of columns for \"grid\" placement. If None, inferred from count.\n        grid_rows (int | None):\n            Number of rows for \"grid\" placement. If None, inferred from count.\n        ring_radius_vmin (float):\n            Ring radius for \"circle\" placement, in vmin units. Default 30.\n        randomize_positions (bool):\n            If True, jitter positions within the grid cell / along the ring for\n            \"grid\"/\"circle\" modes. Default True.\n\n        arena_size_vmin (float):\n            Side length (vmin) of the centered square arena. Default 92.\n        placement_inset_vmin (float):\n            Inner safety margin from arena edges. Default 6.\n        min_gap_vmin (float):\n            Extra minimum pairwise spacing between item centers. Default 2.5.\n\n        background (str):\n            Arena background color. Default \"#000000\".\n        color (str):\n            Default foreground color (text/borders). Default \"#ffffff\".\n        token_box_size (str):\n            Default token box size (CSS). Default \"12vmin\".\n        token_font_size (str):\n            Default font size for text tokens (CSS). Default \"10vmin\".\n\n        overlay_pool (list[str] | None):\n            Optional pool of overlay symbols/colors; sampled per item unless the\n            ItemSpec provides an explicit `color`. Omit/None to use plugin defaults.\n        rotation_pool (list[int] | None):\n            Optional pool of rotations in degrees; sampled per item unless the\n            ItemSpec provides `rotationDeg`. Omit/None to use plugin defaults.\n\n        trial_duration (int | None):\n            Hard timeout in ms. If None and `end_when_found=True`, the trial ends\n            when all targets are collected. Default None.\n        end_when_found (bool):\n            If True, automatically end the trial once all targets are found.\n            Default True.\n        response_ends_trial (bool):\n            If True, any user interaction that counts as a response ends the trial,\n            even if not all targets are collected. Default False.\n\n        seed (int | None):\n            Seed for deterministic placement/sampling. Default None.\n\n        show_star_feedback (bool):\n            If True, briefly show a star animation on successful target clicks.\n            Default False.\n        star_color (str):\n            Star feedback color. Default \"#f6b500\".\n\n        triggers (dict | None):\n            Optional event\u2192action mapping, e.g.,\n            {\"on_all_targets_collected\": \"end_trial\"}.\n            Default: {\"on_all_targets_collected\": \"end_trial\"}.\n\n        duration (int | None):\n            SweetBean convenience alias mirrored to `trial_duration` during build\n            (consistent with RSVP). If provided, `trial_duration` is set to this\n            value. Default None.\n        side_effects: Optional side-effect configuration passed to the runtime. This expects\n            a list of SideEffect definitions (see SweetBean docs) which can be\n            used to update global data like overall score or trial counter.\n\n    Emits (added to jsPsych data):\n        - clicks (list[dict]): Raw click events ({kind, index, id?, t}).\n        - n_targets (int): Number of target items in the trial.\n        - n_collected (int): Number of targets collected.\n        - tps (list[number]): Timestamps for target pickups.\n        - bean_clicks (list[dict]): Mirror of `clicks`.\n        - bean_n_targets (int): Mirror of `n_targets`.\n        - bean_n_found (int): Mirror of `n_collected`.\n        - bean_tps (list[number]): Mirror of `tps`.\n        - bean_all_found (bool): Convenience flag (n_collected &gt;= n_targets).\n\n    Notes:\n        - Provide item-level `pos` to bypass global placement for specific items.\n        - If both `duration` and `trial_duration` are given, `duration` takes\n          precedence by being copied into `trial_duration`.\n        - Null/None optionals are dropped so the plugin falls back to its defaults.\n\n    Example:\n        from sweetbean import Block, Experiment\n        from sweetbean.variable import TimelineVariable\n\n        timeline = [\n            {\n                \"targets\": [\n                    {\"text\": \"T\", \"color\": \"#66ff66\"},\n                    {\"shape\": \"circle\", \"color\": \"#66ff66\"},\n                ],\n                \"distractors\": [\n                    {\"text\": \"L\", \"color\": \"#ff6666\"},\n                    {\"shape\": \"square\", \"color\": \"#ff6666\"},\n                    {\"shape\": \"triangle\", \"color\": \"#ff6666\"},\n                ],\n            }\n        ]\n\n        stim = Foraging(\n            targets=TimelineVariable(\"targets\"),\n            distractors=TimelineVariable(\"distractors\"),\n            position_mode=\"grid\",\n            grid_cols=6, grid_rows=4,\n            arena_size_vmin=90, min_gap_vmin=2.5,\n            background=\"#000000\", color=\"#ffffff\",\n            token_box_size=\"10vmin\", token_font_size=\"8vmin\",\n            end_when_found=True, response_ends_trial=False,\n            show_star_feedback=True, star_color=\"#f6b500\",\n        )\n\n        block = Block([stim], timeline=timeline)\n        Experiment([block]).to_html(\"foraging.html\")\n    \"\"\"\n\n    if targets is None:\n        targets = []\n    if distractors is None:\n        distractors = []\n    if triggers is None:\n        triggers = {\"on_all_targets_collected\": \"end_trial\"}\n\n    super().__init__(locals(), side_effects)\n</code></pre>"},{"location":"reference/sweetbean/stimulus/Gabor/","title":"sweetbean.stimulus.Gabor","text":""},{"location":"reference/sweetbean/stimulus/Gabor/#sweetbean.stimulus.Gabor.Gabor","title":"<code>Gabor</code>","text":"<p>               Bases: <code>_BaseStimulus</code></p> <p>Procedural Gabor patch renderer (wraps @sweet-jspsych/plugin-gabor-array).</p> Core idea <ul> <li>Draw one or more Gabor patches on a canvas and collect keyboard/mouse   responses. Geometry is pixel-based by default; pass px_per_deg to use   degree-based parameters.</li> </ul> <p>Patch spec (each element of <code>patches</code>):   - x_px, y_px            : float  (center position relative to canvas center, px)   - sigma_px              : float  (Gaussian sigma in px)     OR sigma_deg          : float  (sigma in degrees; requires px_per_deg)   - orientation_deg       : float  [0..180)   - contrast              : float  [0..1]   - sf_cpp                : float  cycles per pixel     OR sf_cpd             : float  cycles per degree; requires px_per_deg   - phase_deg             : float  [0..360)   - size_px               : int    (square draw size; default \u2248 6\u00b7sigma)   - label                 : str    (optional tag included in data)</p> Responses <ul> <li>Keyboard: map keys either implicitly (ArrowLeft/Right \u2192 leftmost/rightmost patch)   or explicitly via keymap_to_patch_index (e.g., {\"f\":0, \"j\":1}).</li> <li>Mouse: click selects the nearest patch center (if allow_mouse=True).</li> </ul> Notes <ul> <li>In the browser bundle, the plugin exposes a global constructor:   <code>window.jsPsychGaborArray</code>. This class keeps <code>type</code> as that string so   SweetBean emits a declarative config and lets the shim swap in the constructor.</li> </ul> Source code in <code>sweetbean/stimulus/Gabor.py</code> <pre><code>class Gabor(_BaseStimulus):\n    \"\"\"\n    Procedural Gabor patch renderer (wraps @sweet-jspsych/plugin-gabor-array).\n\n    Core idea:\n      - Draw one or more Gabor patches on a canvas and collect keyboard/mouse\n        responses. Geometry is pixel-based by default; pass px_per_deg to use\n        degree-based parameters.\n\n    Patch spec (each element of `patches`):\n      - x_px, y_px            : float  (center position relative to canvas center, px)\n      - sigma_px              : float  (Gaussian sigma in px)\n        OR sigma_deg          : float  (sigma in degrees; requires px_per_deg)\n      - orientation_deg       : float  [0..180)\n      - contrast              : float  [0..1]\n      - sf_cpp                : float  cycles per pixel\n        OR sf_cpd             : float  cycles per degree; requires px_per_deg\n      - phase_deg             : float  [0..360)\n      - size_px               : int    (square draw size; default \u2248 6\u00b7sigma)\n      - label                 : str    (optional tag included in data)\n\n    Responses:\n      - Keyboard: map keys either implicitly (ArrowLeft/Right \u2192 leftmost/rightmost patch)\n        or explicitly via keymap_to_patch_index (e.g., {\"f\":0, \"j\":1}).\n      - Mouse: click selects the nearest patch center (if allow_mouse=True).\n\n    Notes:\n      - In the browser bundle, the plugin exposes a global constructor:\n        `window.jsPsychGaborArray`. This class keeps `type` as that string so\n        SweetBean emits a declarative config and lets the shim swap in the constructor.\n    \"\"\"\n\n    # Keep a string so the emitted JS config stays declarative.\n    # The browser bundle (IIFE) must set window.jsPsychGaborArray = PluginClass\n    type = \"jsPsychGaborArray\"\n\n    def __init__(\n        self,\n        # Stimulus content\n        patches: Optional[Union[List[Dict[str, Any]], TimelineVariable]] = None,\n        # Canvas &amp; photometry\n        canvas_width: int = 800,\n        canvas_height: int = 600,\n        bg_gray: float = 0.5,  # mean luminance in [0..1]\n        px_per_deg: Optional[float] = None,  # enables deg-based params\n        gamma: float = 1.0,  # 1.0 = no gamma correction\n        # Timing\n        trial_duration: Optional[int] = None,  # ms; None = no forced timeout\n        timeout_ms: Optional[int] = None,  # alias; wins over trial_duration if set\n        end_on_response: bool = True,\n        # Responses\n        response_keys: Optional[List[str]] = None,  # default handled in plugin\n        allow_mouse: bool = True,\n        keymap_to_patch_index: Optional[Dict[str, int]] = None,\n        # SweetBean conveniences\n        duration: Optional[\n            int\n        ] = None,  # alias for trial_duration (consistent with RSVP)\n        side_effects: Optional[Dict[str, Any]] = None,\n    ):\n        \"\"\"\n        Arguments:\n            patches (list[dict] | TimelineVariable | None):\n                The Gabor patch specification for this trial. Accepts either a\n                concrete list or a TimelineVariable that evaluates per trial to a\n                list. Each patch dict supports:\n\n                  Required geometry/appearance\n                  - x_px (float): X center in pixels, relative to canvas center.\n                  - y_px (float): Y center in pixels, relative to canvas center.\n                  - orientation_deg (float): Orientation in degrees [0..180).\n                  - contrast (float): Michelson contrast in [0..1].\n                  - phase_deg (float): Phase in degrees [0..360).\n\n                  Spatial frequency (choose one)\n                  - sf_cpp (float): Cycles per pixel, OR\n                  - sf_cpd (float): Cycles per degree (requires px_per_deg).\n\n                  Gaussian size (choose one)\n                  - sigma_px (float): Sigma in pixels, OR\n                  - sigma_deg (float): Sigma in degrees (requires px_per_deg).\n\n                  Optional\n                  - size_px (int): Square draw size in px (defaults to ~6*sigma_px).\n                  - label (str): Arbitrary tag copied to data.\n\n                Example single patch:\n                {\n                    \"x_px\": 0.0, \"y_px\": 0.0,\n                    \"orientation_deg\": 45, \"contrast\": 0.5, \"phase_deg\": 0,\n                    \"sf_cpd\": 3.0,   # uses px_per_deg if provided\n                    \"sigma_deg\": 0.4 # uses px_per_deg if provided\n                }\n\n            canvas_width (int):\n                Canvas width in pixels. Default 800.\n            canvas_height (int):\n                Canvas height in pixels. Default 600.\n            bg_gray (float):\n                Mean background luminance in [0..1]. Default 0.5.\n            px_per_deg (float | None):\n                Pixels per degree for converting *deg* fields (sigma_deg, sf_cpd)\n                to pixels. If None, deg-based fields are not allowed. Default None.\n            gamma (float):\n                Gamma correction factor for display (1.0 = no correction). Default 1.0.\n\n            trial_duration (int | None):\n                Hard timeout (ms) for the trial. None = no forced timeout. Default None.\n            timeout_ms (int | None):\n                Alias for trial_duration; if set, this takes precedence. Default None.\n            end_on_response (bool):\n                If True, end the trial immediately after a valid response. Default True.\n\n            response_keys (list[str] | None):\n                Allowed keys. If None, defaults to [\"ArrowLeft\", \"ArrowRight\"] to\n                match the plugin\u2019s default. Keys can be remapped with\n                keymap_to_patch_index.\n            allow_mouse (bool):\n                If True, clicking selects the nearest patch center. Default True.\n            keymap_to_patch_index (dict[str, int] | None):\n                Optional explicit key\u2192patch index map (e.g., {\"f\":0, \"j\":1}).\n                If omitted, the plugin can infer a side-based mapping for arrow keys.\n\n            duration (int | None):\n                SweetBean convenience alias mirrored to `trial_duration` during build.\n                If provided, `trial_duration` is set to this value. Default None.\n            side_effects:\n                Optional side-effect configuration passed to the runtime. This expects\n                a list of SideEffect definitions (see SweetBean docs) which can be\n                used to update global data like overall score or trial counter.\n\n        Emits (added to jsPsych data):\n            - bean_rt (number | None): Reaction time in ms.\n            - bean_resp_key (str | None): Key pressed, if any.\n            - bean_resp_side (str | None): Side label derived by the plugin, if any.\n            - bean_chosen_patch (int | None): Selected patch index (0-based).\n            - bean_n_patches (int): Number of patches rendered.\n            - bean_patches (list[dict]): Patch descriptors used on this trial.\n            - bean_onset_ms / bean_offset_ms (number | None): Timing markers.\n\n        Notes:\n            - Provide either pixel- or degree-based size/frequency per patch\n              (sigma_px vs sigma_deg, sf_cpp vs sf_cpd). Degree-based fields require\n              `px_per_deg` to be set.\n            - Use TimelineVariable(\"patches\") if patches vary per trial.\n            - If both `duration` and `trial_duration` are given, `duration` is copied\n              into `trial_duration` (matching other SweetBean stimuli).\n            - Null/None optionals are dropped to let the plugin use its internal defaults.\n\n        Example:\n            from sweetbean import Block, Experiment\n            from sweetbean.variable import TimelineVariable\n            timeline = [\n                {\n                    \"patches\": [\n                        {\n                            \"x_px\": -150, \"y_px\": 0,\n                            \"orientation_deg\": 30, \"contrast\": 0.6, \"phase_deg\": 0,\n                            \"sf_cpd\": 2.5, \"sigma_deg\": 0.3,  # requires px_per_deg\n                            \"label\": \"left\"\n                        },\n                        {\n                            \"x_px\": 150, \"y_px\": 0,\n                            \"orientation_deg\": 120, \"contrast\": 0.6, \"phase_deg\": 90,\n                            \"sf_cpd\": 2.5, \"sigma_deg\": 0.3,\n                            \"label\": \"right\"\n                        },\n                    ]\n                }\n            ]\n            stim = Gabor(\n                patches=TimelineVariable(\"patches\"),\n                canvas_width=800, canvas_height=600,\n                bg_gray=0.5, px_per_deg=40.0, gamma=1.0,\n                trial_duration=None, end_on_response=True,\n                response_keys=[\"f\",\"j\"],\n                keymap_to_patch_index={\"f\":0, \"j\":1},\n            )\n            block = Block([stim], timeline=timeline)\n            Experiment([block]).to_html(\"gabor.html\")\n        \"\"\"\n\n        if patches is None:\n            patches = []\n\n        # Default keys if user didn't provide any; match plugin default\n        if response_keys is None:\n            response_keys = [\"ArrowLeft\", \"ArrowRight\"]\n\n        super().__init__(locals(), side_effects)\n\n    # ---- SweetBean hooks ----\n\n    def _add_special_param(self):\n        \"\"\"\n        - Map SweetBean `duration` to jsPsych `trial_duration`.\n        - Drop null-ish optionals so the plugin falls back to its defaults cleanly.\n        - Keep a string `type` so the browser can resolve it to the actual constructor.\n        \"\"\"\n        arg = self.arg_js\n\n        # Alias duration \u2192 trial_duration\n        if arg.get(\"duration\") not in (None, \"null\"):\n            arg[\"trial_duration\"] = arg[\"duration\"]\n\n        # Remove None/null fields (plugin has its own defaults)\n        for k in (\n            \"px_per_deg\",\n            \"trial_duration\",\n            \"timeout_ms\",\n            \"keymap_to_patch_index\",\n            \"response_keys\",\n        ):\n            if arg.get(k) in (None, \"null\"):\n                arg.pop(k, None)\n\n        # Ensure patches exists (empty list is fine)\n        if arg.get(\"patches\") is None:\n            arg[\"patches\"] = []\n\n        # Keep declarative type so the IIFE shim can replace it at runtime\n        arg[\"type\"] = self.type\n\n    def _process_response(self):\n        \"\"\"\n        Mirror common fields into bean_* for convenience:\n          - bean_rt\n          - bean_resp_key\n          - bean_resp_side\n          - bean_chosen_patch\n          - bean_n_patches\n          - bean_patches (array of patch descriptors: x_px, y_px, sigma_px, sf_cpp, etc.)\n          - bean_onset_ms / bean_offset_ms\n        \"\"\"\n        self.js_data += 'data[\"bean_rt\"] = data[\"rt\"];'\n        self.js_data += 'data[\"bean_resp_key\"] = data[\"resp_key\"];'\n        self.js_data += 'data[\"bean_resp_side\"] = data[\"resp_side\"];'\n        self.js_data += 'data[\"bean_chosen_patch\"] = data[\"chosen_patch_index\"];'\n        self.js_data += 'data[\"bean_n_patches\"] = data[\"n_patches\"];'\n        self.js_data += 'data[\"bean_patches\"] = data[\"patches\"];'\n        self.js_data += 'data[\"bean_onset_ms\"] = data[\"onset_ms\"];'\n        self.js_data += 'data[\"bean_offset_ms\"] = data[\"offset_ms\"];'\n\n    def _set_before(self):\n        # No extra on_load code required.\n        pass\n\n    # Language mode not supported\n    def process_l(self, prompts, get_input, multi_turn, datum=None):\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/sweetbean/stimulus/Gabor/#sweetbean.stimulus.Gabor.Gabor.__init__","title":"<code>__init__(patches=None, canvas_width=800, canvas_height=600, bg_gray=0.5, px_per_deg=None, gamma=1.0, trial_duration=None, timeout_ms=None, end_on_response=True, response_keys=None, allow_mouse=True, keymap_to_patch_index=None, duration=None, side_effects=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>patches</code> <code>list[dict] | TimelineVariable | None</code> <p>The Gabor patch specification for this trial. Accepts either a concrete list or a TimelineVariable that evaluates per trial to a list. Each patch dict supports:</p> <p>Required geometry/appearance   - x_px (float): X center in pixels, relative to canvas center.   - y_px (float): Y center in pixels, relative to canvas center.   - orientation_deg (float): Orientation in degrees [0..180).   - contrast (float): Michelson contrast in [0..1].   - phase_deg (float): Phase in degrees [0..360).</p> <p>Spatial frequency (choose one)   - sf_cpp (float): Cycles per pixel, OR   - sf_cpd (float): Cycles per degree (requires px_per_deg).</p> <p>Gaussian size (choose one)   - sigma_px (float): Sigma in pixels, OR   - sigma_deg (float): Sigma in degrees (requires px_per_deg).</p> <p>Optional   - size_px (int): Square draw size in px (defaults to ~6*sigma_px).   - label (str): Arbitrary tag copied to data.</p> <p>Example single patch: {     \"x_px\": 0.0, \"y_px\": 0.0,     \"orientation_deg\": 45, \"contrast\": 0.5, \"phase_deg\": 0,     \"sf_cpd\": 3.0,   # uses px_per_deg if provided     \"sigma_deg\": 0.4 # uses px_per_deg if provided }</p> <code>None</code> <code>canvas_width</code> <code>int</code> <p>Canvas width in pixels. Default 800.</p> <code>800</code> <code>canvas_height</code> <code>int</code> <p>Canvas height in pixels. Default 600.</p> <code>600</code> <code>bg_gray</code> <code>float</code> <p>Mean background luminance in [0..1]. Default 0.5.</p> <code>0.5</code> <code>px_per_deg</code> <code>float | None</code> <p>Pixels per degree for converting deg fields (sigma_deg, sf_cpd) to pixels. If None, deg-based fields are not allowed. Default None.</p> <code>None</code> <code>gamma</code> <code>float</code> <p>Gamma correction factor for display (1.0 = no correction). Default 1.0.</p> <code>1.0</code> <code>trial_duration</code> <code>int | None</code> <p>Hard timeout (ms) for the trial. None = no forced timeout. Default None.</p> <code>None</code> <code>timeout_ms</code> <code>int | None</code> <p>Alias for trial_duration; if set, this takes precedence. Default None.</p> <code>None</code> <code>end_on_response</code> <code>bool</code> <p>If True, end the trial immediately after a valid response. Default True.</p> <code>True</code> <code>response_keys</code> <code>list[str] | None</code> <p>Allowed keys. If None, defaults to [\"ArrowLeft\", \"ArrowRight\"] to match the plugin\u2019s default. Keys can be remapped with keymap_to_patch_index.</p> <code>None</code> <code>allow_mouse</code> <code>bool</code> <p>If True, clicking selects the nearest patch center. Default True.</p> <code>True</code> <code>keymap_to_patch_index</code> <code>dict[str, int] | None</code> <p>Optional explicit key\u2192patch index map (e.g., {\"f\":0, \"j\":1}). If omitted, the plugin can infer a side-based mapping for arrow keys.</p> <code>None</code> <code>duration</code> <code>int | None</code> <p>SweetBean convenience alias mirrored to <code>trial_duration</code> during build. If provided, <code>trial_duration</code> is set to this value. Default None.</p> <code>None</code> <code>side_effects</code> <code>Optional[Dict[str, Any]]</code> <p>Optional side-effect configuration passed to the runtime. This expects a list of SideEffect definitions (see SweetBean docs) which can be used to update global data like overall score or trial counter.</p> <code>None</code> <p>Emits (added to jsPsych data):     - bean_rt (number | None): Reaction time in ms.     - bean_resp_key (str | None): Key pressed, if any.     - bean_resp_side (str | None): Side label derived by the plugin, if any.     - bean_chosen_patch (int | None): Selected patch index (0-based).     - bean_n_patches (int): Number of patches rendered.     - bean_patches (list[dict]): Patch descriptors used on this trial.     - bean_onset_ms / bean_offset_ms (number | None): Timing markers.</p> Notes <ul> <li>Provide either pixel- or degree-based size/frequency per patch   (sigma_px vs sigma_deg, sf_cpp vs sf_cpd). Degree-based fields require   <code>px_per_deg</code> to be set.</li> <li>Use TimelineVariable(\"patches\") if patches vary per trial.</li> <li>If both <code>duration</code> and <code>trial_duration</code> are given, <code>duration</code> is copied   into <code>trial_duration</code> (matching other SweetBean stimuli).</li> <li>Null/None optionals are dropped to let the plugin use its internal defaults.</li> </ul> Example <p>from sweetbean import Block, Experiment from sweetbean.variable import TimelineVariable timeline = [     {         \"patches\": [             {                 \"x_px\": -150, \"y_px\": 0,                 \"orientation_deg\": 30, \"contrast\": 0.6, \"phase_deg\": 0,                 \"sf_cpd\": 2.5, \"sigma_deg\": 0.3,  # requires px_per_deg                 \"label\": \"left\"             },             {                 \"x_px\": 150, \"y_px\": 0,                 \"orientation_deg\": 120, \"contrast\": 0.6, \"phase_deg\": 90,                 \"sf_cpd\": 2.5, \"sigma_deg\": 0.3,                 \"label\": \"right\"             },         ]     } ] stim = Gabor(     patches=TimelineVariable(\"patches\"),     canvas_width=800, canvas_height=600,     bg_gray=0.5, px_per_deg=40.0, gamma=1.0,     trial_duration=None, end_on_response=True,     response_keys=[\"f\",\"j\"],     keymap_to_patch_index={\"f\":0, \"j\":1}, ) block = Block([stim], timeline=timeline) Experiment([block]).to_html(\"gabor.html\")</p> Source code in <code>sweetbean/stimulus/Gabor.py</code> <pre><code>def __init__(\n    self,\n    # Stimulus content\n    patches: Optional[Union[List[Dict[str, Any]], TimelineVariable]] = None,\n    # Canvas &amp; photometry\n    canvas_width: int = 800,\n    canvas_height: int = 600,\n    bg_gray: float = 0.5,  # mean luminance in [0..1]\n    px_per_deg: Optional[float] = None,  # enables deg-based params\n    gamma: float = 1.0,  # 1.0 = no gamma correction\n    # Timing\n    trial_duration: Optional[int] = None,  # ms; None = no forced timeout\n    timeout_ms: Optional[int] = None,  # alias; wins over trial_duration if set\n    end_on_response: bool = True,\n    # Responses\n    response_keys: Optional[List[str]] = None,  # default handled in plugin\n    allow_mouse: bool = True,\n    keymap_to_patch_index: Optional[Dict[str, int]] = None,\n    # SweetBean conveniences\n    duration: Optional[\n        int\n    ] = None,  # alias for trial_duration (consistent with RSVP)\n    side_effects: Optional[Dict[str, Any]] = None,\n):\n    \"\"\"\n    Arguments:\n        patches (list[dict] | TimelineVariable | None):\n            The Gabor patch specification for this trial. Accepts either a\n            concrete list or a TimelineVariable that evaluates per trial to a\n            list. Each patch dict supports:\n\n              Required geometry/appearance\n              - x_px (float): X center in pixels, relative to canvas center.\n              - y_px (float): Y center in pixels, relative to canvas center.\n              - orientation_deg (float): Orientation in degrees [0..180).\n              - contrast (float): Michelson contrast in [0..1].\n              - phase_deg (float): Phase in degrees [0..360).\n\n              Spatial frequency (choose one)\n              - sf_cpp (float): Cycles per pixel, OR\n              - sf_cpd (float): Cycles per degree (requires px_per_deg).\n\n              Gaussian size (choose one)\n              - sigma_px (float): Sigma in pixels, OR\n              - sigma_deg (float): Sigma in degrees (requires px_per_deg).\n\n              Optional\n              - size_px (int): Square draw size in px (defaults to ~6*sigma_px).\n              - label (str): Arbitrary tag copied to data.\n\n            Example single patch:\n            {\n                \"x_px\": 0.0, \"y_px\": 0.0,\n                \"orientation_deg\": 45, \"contrast\": 0.5, \"phase_deg\": 0,\n                \"sf_cpd\": 3.0,   # uses px_per_deg if provided\n                \"sigma_deg\": 0.4 # uses px_per_deg if provided\n            }\n\n        canvas_width (int):\n            Canvas width in pixels. Default 800.\n        canvas_height (int):\n            Canvas height in pixels. Default 600.\n        bg_gray (float):\n            Mean background luminance in [0..1]. Default 0.5.\n        px_per_deg (float | None):\n            Pixels per degree for converting *deg* fields (sigma_deg, sf_cpd)\n            to pixels. If None, deg-based fields are not allowed. Default None.\n        gamma (float):\n            Gamma correction factor for display (1.0 = no correction). Default 1.0.\n\n        trial_duration (int | None):\n            Hard timeout (ms) for the trial. None = no forced timeout. Default None.\n        timeout_ms (int | None):\n            Alias for trial_duration; if set, this takes precedence. Default None.\n        end_on_response (bool):\n            If True, end the trial immediately after a valid response. Default True.\n\n        response_keys (list[str] | None):\n            Allowed keys. If None, defaults to [\"ArrowLeft\", \"ArrowRight\"] to\n            match the plugin\u2019s default. Keys can be remapped with\n            keymap_to_patch_index.\n        allow_mouse (bool):\n            If True, clicking selects the nearest patch center. Default True.\n        keymap_to_patch_index (dict[str, int] | None):\n            Optional explicit key\u2192patch index map (e.g., {\"f\":0, \"j\":1}).\n            If omitted, the plugin can infer a side-based mapping for arrow keys.\n\n        duration (int | None):\n            SweetBean convenience alias mirrored to `trial_duration` during build.\n            If provided, `trial_duration` is set to this value. Default None.\n        side_effects:\n            Optional side-effect configuration passed to the runtime. This expects\n            a list of SideEffect definitions (see SweetBean docs) which can be\n            used to update global data like overall score or trial counter.\n\n    Emits (added to jsPsych data):\n        - bean_rt (number | None): Reaction time in ms.\n        - bean_resp_key (str | None): Key pressed, if any.\n        - bean_resp_side (str | None): Side label derived by the plugin, if any.\n        - bean_chosen_patch (int | None): Selected patch index (0-based).\n        - bean_n_patches (int): Number of patches rendered.\n        - bean_patches (list[dict]): Patch descriptors used on this trial.\n        - bean_onset_ms / bean_offset_ms (number | None): Timing markers.\n\n    Notes:\n        - Provide either pixel- or degree-based size/frequency per patch\n          (sigma_px vs sigma_deg, sf_cpp vs sf_cpd). Degree-based fields require\n          `px_per_deg` to be set.\n        - Use TimelineVariable(\"patches\") if patches vary per trial.\n        - If both `duration` and `trial_duration` are given, `duration` is copied\n          into `trial_duration` (matching other SweetBean stimuli).\n        - Null/None optionals are dropped to let the plugin use its internal defaults.\n\n    Example:\n        from sweetbean import Block, Experiment\n        from sweetbean.variable import TimelineVariable\n        timeline = [\n            {\n                \"patches\": [\n                    {\n                        \"x_px\": -150, \"y_px\": 0,\n                        \"orientation_deg\": 30, \"contrast\": 0.6, \"phase_deg\": 0,\n                        \"sf_cpd\": 2.5, \"sigma_deg\": 0.3,  # requires px_per_deg\n                        \"label\": \"left\"\n                    },\n                    {\n                        \"x_px\": 150, \"y_px\": 0,\n                        \"orientation_deg\": 120, \"contrast\": 0.6, \"phase_deg\": 90,\n                        \"sf_cpd\": 2.5, \"sigma_deg\": 0.3,\n                        \"label\": \"right\"\n                    },\n                ]\n            }\n        ]\n        stim = Gabor(\n            patches=TimelineVariable(\"patches\"),\n            canvas_width=800, canvas_height=600,\n            bg_gray=0.5, px_per_deg=40.0, gamma=1.0,\n            trial_duration=None, end_on_response=True,\n            response_keys=[\"f\",\"j\"],\n            keymap_to_patch_index={\"f\":0, \"j\":1},\n        )\n        block = Block([stim], timeline=timeline)\n        Experiment([block]).to_html(\"gabor.html\")\n    \"\"\"\n\n    if patches is None:\n        patches = []\n\n    # Default keys if user didn't provide any; match plugin default\n    if response_keys is None:\n        response_keys = [\"ArrowLeft\", \"ArrowRight\"]\n\n    super().__init__(locals(), side_effects)\n</code></pre>"},{"location":"reference/sweetbean/stimulus/Generic/","title":"sweetbean.stimulus.Generic","text":""},{"location":"reference/sweetbean/stimulus/Generic/#sweetbean.stimulus.Generic.Generic","title":"<code>Generic</code>","text":"<p>               Bases: <code>_BaseStimulus</code></p> <p>A generic stimulus.</p> This stimulus implements jsPsych stimuli but can not be <p>used to run experiments on language</p> Source code in <code>sweetbean/stimulus/Generic.py</code> <pre><code>class Generic(_BaseStimulus):\n    \"\"\"\n    A generic stimulus.\n\n    Attention: This stimulus implements jsPsych stimuli but can not be\n        used to run experiments on language\n    \"\"\"\n\n    _not_tested: bool = False\n    _js_plugins: list = []\n\n    def __init__(\n        self,\n        side_effects=None,\n        **kwargs,\n    ):\n        if \"type\" not in kwargs:\n            raise ValueError(\"`type` argument must be defined in Generic stimulus.\")\n        if not Generic._not_tested:\n            warnings.warn(\n                \"You are using a Generic Stimulus. This feature has not been fully tested.\\n\"\n                \"It might work for creating html files or javascript functions but probably\\n\"\n                \"will not work with running experiments on language.\"\n            )\n            Generic._not_tested = True\n        if not kwargs[\"type\"] in Generic._js_plugins:\n            warnings.warn(\n                f\"You are using a jsPsych plugin {kwargs['type']} with a generic class.\\n\"\n                f\"Make sure to add the script plugin to the generated HTML file\\n\"\n                f\"or javascript function. You can find a list here:\\n\"\n                f\"https://www.jspsych.org/v7/plugins/list-of-plugins/\\n\"\n            )\n            Generic._js_plugins.append(kwargs[\"type\"])\n\n        self.side_effects = side_effects\n        if \"self\" in kwargs:\n            del kwargs[\"self\"]\n        if \"__class__\" in kwargs:\n            del kwargs[\"__class__\"]\n        if \"side_effects\" in kwargs:\n            del kwargs[\"side_effects\"]\n\n        self.arg = kwargs\n        self.arg_js = {}\n        if \"duration\" in self.arg:\n            self.arg_js[\"trial_duration\"] = self.arg[\"duration\"]\n        for key in self.arg:\n            self.arg_js[key] = kwargs[key]\n\n    def _add_special_param(self):\n        pass\n\n    def _process_response(self):\n        pass\n\n    def _set_before(self):\n        pass\n</code></pre>"},{"location":"reference/sweetbean/stimulus/HtmlKeyboardResponse/","title":"sweetbean.stimulus.HtmlKeyboardResponse","text":""},{"location":"reference/sweetbean/stimulus/HtmlKeyboardResponse/#sweetbean.stimulus.HtmlKeyboardResponse.Blank","title":"<code>Blank</code>","text":"<p>               Bases: <code>HtmlKeyboardResponse</code></p> <p>shows a blank screen</p> Source code in <code>sweetbean/stimulus/HtmlKeyboardResponse.py</code> <pre><code>class Blank(HtmlKeyboardResponse):\n    \"\"\"\n    shows a blank screen\n    \"\"\"\n\n    def __init__(\n        self,\n        duration=None,\n        choices=None,\n        correct_key=\"\",\n        side_effects=None,\n    ):\n        \"\"\"\n        Arguments:\n            duration: time in ms the stimulus is presented\n            choices: the keys that will be recorded if pressed\n            correct_key: the correct key to press\n            side_effects: Optional side-effect configuration passed to the runtime. This expects\n                a list of SideEffect definitions (see SweetBean docs) which can be\n                used to update global data like overall score or trial counter.\n        \"\"\"\n        super().__init__(\n            duration=duration,\n            stimulus=\"\",\n            choices=choices,\n            correct_key=correct_key,\n            side_effects=side_effects,\n        )\n</code></pre>"},{"location":"reference/sweetbean/stimulus/HtmlKeyboardResponse/#sweetbean.stimulus.HtmlKeyboardResponse.Blank.__init__","title":"<code>__init__(duration=None, choices=None, correct_key='', side_effects=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>duration</code> <p>time in ms the stimulus is presented</p> <code>None</code> <code>choices</code> <p>the keys that will be recorded if pressed</p> <code>None</code> <code>correct_key</code> <p>the correct key to press</p> <code>''</code> <code>side_effects</code> <p>Optional side-effect configuration passed to the runtime. This expects a list of SideEffect definitions (see SweetBean docs) which can be used to update global data like overall score or trial counter.</p> <code>None</code> Source code in <code>sweetbean/stimulus/HtmlKeyboardResponse.py</code> <pre><code>def __init__(\n    self,\n    duration=None,\n    choices=None,\n    correct_key=\"\",\n    side_effects=None,\n):\n    \"\"\"\n    Arguments:\n        duration: time in ms the stimulus is presented\n        choices: the keys that will be recorded if pressed\n        correct_key: the correct key to press\n        side_effects: Optional side-effect configuration passed to the runtime. This expects\n            a list of SideEffect definitions (see SweetBean docs) which can be\n            used to update global data like overall score or trial counter.\n    \"\"\"\n    super().__init__(\n        duration=duration,\n        stimulus=\"\",\n        choices=choices,\n        correct_key=correct_key,\n        side_effects=side_effects,\n    )\n</code></pre>"},{"location":"reference/sweetbean/stimulus/HtmlKeyboardResponse/#sweetbean.stimulus.HtmlKeyboardResponse.Feedback","title":"<code>Feedback</code>","text":"<p>               Bases: <code>Text</code></p> <p>show the word correct or incorrect dependent on a correct response to a stimulus before</p> Source code in <code>sweetbean/stimulus/HtmlKeyboardResponse.py</code> <pre><code>class Feedback(Text):\n    \"\"\"\n    show the word correct or incorrect dependent on a correct response to a stimulus before\n    \"\"\"\n\n    def __init__(\n        self,\n        duration=None,\n        correct_message=\"Correct!\",\n        false_message=\"False!\",\n        correct_color=\"green\",\n        false_color=\"red\",\n        window=1,\n        side_effects=None,\n    ):\n        \"\"\"\n        Arguments:\n            duration: time in ms the stimulus is presented\n            correct_message: the message to show if the response was correct\n            false_message: the message to show if the response was false\n            correct_color: the color of the message if the response was correct\n            false_color: the color of the message if the response was false\n            window: how far back is the stimulus to check\n                    (that stimulus needs to have a choice and a correct_key parameter)\n            side_effects: Optional side-effect configuration passed to the runtime. This expects\n                a list of SideEffect definitions (see SweetBean docs) which can be\n                used to update global data like overall score or trial counter.\n        \"\"\"\n        correct = DataVariable(\"correct\", window)\n\n        feedback_txt = FunctionVariable(\n            \"feedback_txt\",\n            lambda c_msg, f_msg, cor: c_msg if cor else f_msg,\n            [correct_message, false_message, correct],\n        )\n\n        feedback_color = FunctionVariable(\n            \"feedback_color\",\n            lambda c_color, f_color, cor: c_color if cor else f_color,\n            [correct_color, false_color, correct],\n        )\n\n        super().__init__(\n            duration,\n            feedback_txt,\n            feedback_color,\n            choices=[],\n            correct_key=\"\",\n            side_effects=side_effects,\n        )\n</code></pre>"},{"location":"reference/sweetbean/stimulus/HtmlKeyboardResponse/#sweetbean.stimulus.HtmlKeyboardResponse.Feedback.__init__","title":"<code>__init__(duration=None, correct_message='Correct!', false_message='False!', correct_color='green', false_color='red', window=1, side_effects=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>duration</code> <p>time in ms the stimulus is presented</p> <code>None</code> <code>correct_message</code> <p>the message to show if the response was correct</p> <code>'Correct!'</code> <code>false_message</code> <p>the message to show if the response was false</p> <code>'False!'</code> <code>correct_color</code> <p>the color of the message if the response was correct</p> <code>'green'</code> <code>false_color</code> <p>the color of the message if the response was false</p> <code>'red'</code> <code>window</code> <p>how far back is the stimulus to check     (that stimulus needs to have a choice and a correct_key parameter)</p> <code>1</code> <code>side_effects</code> <p>Optional side-effect configuration passed to the runtime. This expects a list of SideEffect definitions (see SweetBean docs) which can be used to update global data like overall score or trial counter.</p> <code>None</code> Source code in <code>sweetbean/stimulus/HtmlKeyboardResponse.py</code> <pre><code>def __init__(\n    self,\n    duration=None,\n    correct_message=\"Correct!\",\n    false_message=\"False!\",\n    correct_color=\"green\",\n    false_color=\"red\",\n    window=1,\n    side_effects=None,\n):\n    \"\"\"\n    Arguments:\n        duration: time in ms the stimulus is presented\n        correct_message: the message to show if the response was correct\n        false_message: the message to show if the response was false\n        correct_color: the color of the message if the response was correct\n        false_color: the color of the message if the response was false\n        window: how far back is the stimulus to check\n                (that stimulus needs to have a choice and a correct_key parameter)\n        side_effects: Optional side-effect configuration passed to the runtime. This expects\n            a list of SideEffect definitions (see SweetBean docs) which can be\n            used to update global data like overall score or trial counter.\n    \"\"\"\n    correct = DataVariable(\"correct\", window)\n\n    feedback_txt = FunctionVariable(\n        \"feedback_txt\",\n        lambda c_msg, f_msg, cor: c_msg if cor else f_msg,\n        [correct_message, false_message, correct],\n    )\n\n    feedback_color = FunctionVariable(\n        \"feedback_color\",\n        lambda c_color, f_color, cor: c_color if cor else f_color,\n        [correct_color, false_color, correct],\n    )\n\n    super().__init__(\n        duration,\n        feedback_txt,\n        feedback_color,\n        choices=[],\n        correct_key=\"\",\n        side_effects=side_effects,\n    )\n</code></pre>"},{"location":"reference/sweetbean/stimulus/HtmlKeyboardResponse/#sweetbean.stimulus.HtmlKeyboardResponse.Fixation","title":"<code>Fixation</code>","text":"<p>               Bases: <code>Text</code></p> <p>show a white cross in the middle of the screen</p> Source code in <code>sweetbean/stimulus/HtmlKeyboardResponse.py</code> <pre><code>class Fixation(Text):\n    \"\"\"\n    show a white cross in the middle of the screen\n    \"\"\"\n\n    def __init__(self, duration=None, side_effects=None):\n        \"\"\"\n        Arguments:\n            duration: time in ms the stimulus is presented\n            side_effects: Optional side-effect configuration passed to the runtime. This expects\n                a list of SideEffect definitions (see SweetBean docs) which can be\n                used to update global data like overall score or trial counter.\n        \"\"\"\n        super().__init__(\n            duration=duration,\n            text=\"+\",\n            color=\"white\",\n            choices=[],\n            correct_key=\"\",\n            side_effects=side_effects,\n        )\n</code></pre>"},{"location":"reference/sweetbean/stimulus/HtmlKeyboardResponse/#sweetbean.stimulus.HtmlKeyboardResponse.Fixation.__init__","title":"<code>__init__(duration=None, side_effects=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>duration</code> <p>time in ms the stimulus is presented</p> <code>None</code> <code>side_effects</code> <p>Optional side-effect configuration passed to the runtime. This expects a list of SideEffect definitions (see SweetBean docs) which can be used to update global data like overall score or trial counter.</p> <code>None</code> Source code in <code>sweetbean/stimulus/HtmlKeyboardResponse.py</code> <pre><code>def __init__(self, duration=None, side_effects=None):\n    \"\"\"\n    Arguments:\n        duration: time in ms the stimulus is presented\n        side_effects: Optional side-effect configuration passed to the runtime. This expects\n            a list of SideEffect definitions (see SweetBean docs) which can be\n            used to update global data like overall score or trial counter.\n    \"\"\"\n    super().__init__(\n        duration=duration,\n        text=\"+\",\n        color=\"white\",\n        choices=[],\n        correct_key=\"\",\n        side_effects=side_effects,\n    )\n</code></pre>"},{"location":"reference/sweetbean/stimulus/HtmlKeyboardResponse/#sweetbean.stimulus.HtmlKeyboardResponse.Flanker","title":"<code>Flanker</code>","text":"<p>               Bases: <code>Text</code></p> <p>show a flanker stimulus (&lt;&lt; &lt; &lt;&lt;; &lt;&lt; &gt; &lt;&lt;, &gt;&gt; &lt; &gt;&gt;, ...)</p> Source code in <code>sweetbean/stimulus/HtmlKeyboardResponse.py</code> <pre><code>class Flanker(Text):\n    \"\"\"\n    show a flanker stimulus (&lt;&lt; &lt; &lt;&lt;; &lt;&lt; &gt; &lt;&lt;, &gt;&gt; &lt; &gt;&gt;, ...)\n    \"\"\"\n\n    def __init__(\n        self,\n        duration=None,\n        direction=\"left\",\n        distractor=\"left\",\n        choices=None,\n        correct_key=\"\",\n        color=\"white\",\n        n_flankers=2,\n        side_effects=None,\n    ):\n        \"\"\"\n        Arguments:\n            duration: time in ms the stimulus is presented\n            direction: the direction of the target (allowed: left, right, l, r, L, R)\n            distractor: the direction of the distractor (allowed: left, right, l, r, L, R)\n            choices: the keys that will be recorded if pressed\n            correct_key: the correct key to press\n            color: the color of the text\n            n_flankers: the number of distractors\n            side_effects: Optional side-effect configuration passed to the runtime. This expects\n                a list of SideEffect definitions (see SweetBean docs) which can be\n                used to update global data like overall score or trial counter.\n        \"\"\"\n\n        def _txt(dr, dst, n):\n            normalized_dir = dr.lower()\n            normalized_dist = dst.lower()\n            t = \"\"\n            d = \"\"\n            if normalized_dir == \"right\" or normalized_dir == \"r\":\n                t = \"&gt;\"\n            if normalized_dir == \"left\" or normalized_dir == \"l\":\n                t = \"&lt;\"\n            if normalized_dist == \"right\" or normalized_dist == \"r\":\n                d = \"&gt;\"\n            if normalized_dist == \"left\" or normalized_dist == \"l\":\n                d = \"&lt;\"\n            d = d * n\n            return f\"{d}{t}{d}\"\n\n        txt = FunctionVariable(\"target\", _txt, [direction, distractor, n_flankers])\n\n        super().__init__(\n            duration=duration,\n            text=txt,\n            color=color,\n            choices=choices,\n            correct_key=correct_key,\n            side_effects=side_effects,\n        )\n</code></pre>"},{"location":"reference/sweetbean/stimulus/HtmlKeyboardResponse/#sweetbean.stimulus.HtmlKeyboardResponse.Flanker.__init__","title":"<code>__init__(duration=None, direction='left', distractor='left', choices=None, correct_key='', color='white', n_flankers=2, side_effects=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>duration</code> <p>time in ms the stimulus is presented</p> <code>None</code> <code>direction</code> <p>the direction of the target (allowed: left, right, l, r, L, R)</p> <code>'left'</code> <code>distractor</code> <p>the direction of the distractor (allowed: left, right, l, r, L, R)</p> <code>'left'</code> <code>choices</code> <p>the keys that will be recorded if pressed</p> <code>None</code> <code>correct_key</code> <p>the correct key to press</p> <code>''</code> <code>color</code> <p>the color of the text</p> <code>'white'</code> <code>n_flankers</code> <p>the number of distractors</p> <code>2</code> <code>side_effects</code> <p>Optional side-effect configuration passed to the runtime. This expects a list of SideEffect definitions (see SweetBean docs) which can be used to update global data like overall score or trial counter.</p> <code>None</code> Source code in <code>sweetbean/stimulus/HtmlKeyboardResponse.py</code> <pre><code>def __init__(\n    self,\n    duration=None,\n    direction=\"left\",\n    distractor=\"left\",\n    choices=None,\n    correct_key=\"\",\n    color=\"white\",\n    n_flankers=2,\n    side_effects=None,\n):\n    \"\"\"\n    Arguments:\n        duration: time in ms the stimulus is presented\n        direction: the direction of the target (allowed: left, right, l, r, L, R)\n        distractor: the direction of the distractor (allowed: left, right, l, r, L, R)\n        choices: the keys that will be recorded if pressed\n        correct_key: the correct key to press\n        color: the color of the text\n        n_flankers: the number of distractors\n        side_effects: Optional side-effect configuration passed to the runtime. This expects\n            a list of SideEffect definitions (see SweetBean docs) which can be\n            used to update global data like overall score or trial counter.\n    \"\"\"\n\n    def _txt(dr, dst, n):\n        normalized_dir = dr.lower()\n        normalized_dist = dst.lower()\n        t = \"\"\n        d = \"\"\n        if normalized_dir == \"right\" or normalized_dir == \"r\":\n            t = \"&gt;\"\n        if normalized_dir == \"left\" or normalized_dir == \"l\":\n            t = \"&lt;\"\n        if normalized_dist == \"right\" or normalized_dist == \"r\":\n            d = \"&gt;\"\n        if normalized_dist == \"left\" or normalized_dist == \"l\":\n            d = \"&lt;\"\n        d = d * n\n        return f\"{d}{t}{d}\"\n\n    txt = FunctionVariable(\"target\", _txt, [direction, distractor, n_flankers])\n\n    super().__init__(\n        duration=duration,\n        text=txt,\n        color=color,\n        choices=choices,\n        correct_key=correct_key,\n        side_effects=side_effects,\n    )\n</code></pre>"},{"location":"reference/sweetbean/stimulus/HtmlKeyboardResponse/#sweetbean.stimulus.HtmlKeyboardResponse.HtmlKeyboardResponse","title":"<code>HtmlKeyboardResponse</code>","text":"<p>               Bases: <code>_KeyboardResponseStimulus</code></p> <p>A base class for html stimuli</p> Source code in <code>sweetbean/stimulus/HtmlKeyboardResponse.py</code> <pre><code>class HtmlKeyboardResponse(_KeyboardResponseStimulus):\n    \"\"\"\n    A base class for html stimuli\n    \"\"\"\n\n    type = \"jsPsychHtmlKeyboardResponse\"\n\n    def __init__(\n        self,\n        duration=None,\n        stimulus=\"\",\n        choices=None,\n        correct_key=\"\",\n        side_effects=None,\n    ):\n        \"\"\"\n        Arguments:\n            duration: time in ms the stimulus is presented\n            stimulus: the html string representing that is rendered\n            choices: the keys that will be recorded if pressed\n            correct_key: the correct key to press\n            side_effects: Optional side-effect configuration passed to the runtime. This expects\n                a list of SideEffect definitions (see SweetBean docs) which can be\n                used to update global data like overall score or trial counter.s\n        \"\"\"\n\n        if choices is None:\n            choices = []\n        super().__init__(locals(), side_effects)\n\n    def _add_special_param(self):\n        pass\n\n    def _set_before(self):\n        pass\n</code></pre>"},{"location":"reference/sweetbean/stimulus/HtmlKeyboardResponse/#sweetbean.stimulus.HtmlKeyboardResponse.HtmlKeyboardResponse.__init__","title":"<code>__init__(duration=None, stimulus='', choices=None, correct_key='', side_effects=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>duration</code> <p>time in ms the stimulus is presented</p> <code>None</code> <code>stimulus</code> <p>the html string representing that is rendered</p> <code>''</code> <code>choices</code> <p>the keys that will be recorded if pressed</p> <code>None</code> <code>correct_key</code> <p>the correct key to press</p> <code>''</code> <code>side_effects</code> <p>Optional side-effect configuration passed to the runtime. This expects a list of SideEffect definitions (see SweetBean docs) which can be used to update global data like overall score or trial counter.s</p> <code>None</code> Source code in <code>sweetbean/stimulus/HtmlKeyboardResponse.py</code> <pre><code>def __init__(\n    self,\n    duration=None,\n    stimulus=\"\",\n    choices=None,\n    correct_key=\"\",\n    side_effects=None,\n):\n    \"\"\"\n    Arguments:\n        duration: time in ms the stimulus is presented\n        stimulus: the html string representing that is rendered\n        choices: the keys that will be recorded if pressed\n        correct_key: the correct key to press\n        side_effects: Optional side-effect configuration passed to the runtime. This expects\n            a list of SideEffect definitions (see SweetBean docs) which can be\n            used to update global data like overall score or trial counter.s\n    \"\"\"\n\n    if choices is None:\n        choices = []\n    super().__init__(locals(), side_effects)\n</code></pre>"},{"location":"reference/sweetbean/stimulus/HtmlKeyboardResponse/#sweetbean.stimulus.HtmlKeyboardResponse.Text","title":"<code>Text</code>","text":"<p>               Bases: <code>HtmlKeyboardResponse</code></p> <p>Show colored text</p> Source code in <code>sweetbean/stimulus/HtmlKeyboardResponse.py</code> <pre><code>class Text(HtmlKeyboardResponse):\n    \"\"\"\n    Show colored text\n    \"\"\"\n\n    l_template: str = (\n        \"You see \"\n        '{% if text %}\"{{text}}\" in \"{{color}}\"'\n        \"{% else %}a blank screen{% endif %}\"\n        \"{% if duration %} for {{duration}}ms{% endif %}.\"\n    )\n\n    def __init__(\n        self,\n        duration=None,\n        text=\"\",\n        color=\"white\",\n        choices=None,\n        correct_key=\"\",\n        side_effects=None,\n    ):\n        \"\"\"\n        Arguments:\n            duration: time in ms the stimulus is presented\n            text: the text should be presented\n            color: the color of the text\n            choices: the keys that will be recorded if pressed\n            correct_key: the correct key to press\n            side_effects: Optional side-effect configuration passed to the runtime. This expects\n                a list of SideEffect definitions (see SweetBean docs) which can be\n                used to update global data like overall score or trial counter.s\n        \"\"\"\n        if choices is None:\n            choices = []\n\n        def stim(cl, txt):\n            return f\"&lt;div style='color:{cl}'&gt;{txt}&lt;/div&gt;\"\n\n        stimulus_ = FunctionVariable(\"stimulus\", stim, [color, text])\n        super().__init__(duration, stimulus_, choices, correct_key, side_effects)\n\n        self.arg.update({\"text\": text, \"color\": color})\n</code></pre>"},{"location":"reference/sweetbean/stimulus/HtmlKeyboardResponse/#sweetbean.stimulus.HtmlKeyboardResponse.Text.__init__","title":"<code>__init__(duration=None, text='', color='white', choices=None, correct_key='', side_effects=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>duration</code> <p>time in ms the stimulus is presented</p> <code>None</code> <code>text</code> <p>the text should be presented</p> <code>''</code> <code>color</code> <p>the color of the text</p> <code>'white'</code> <code>choices</code> <p>the keys that will be recorded if pressed</p> <code>None</code> <code>correct_key</code> <p>the correct key to press</p> <code>''</code> <code>side_effects</code> <p>Optional side-effect configuration passed to the runtime. This expects a list of SideEffect definitions (see SweetBean docs) which can be used to update global data like overall score or trial counter.s</p> <code>None</code> Source code in <code>sweetbean/stimulus/HtmlKeyboardResponse.py</code> <pre><code>def __init__(\n    self,\n    duration=None,\n    text=\"\",\n    color=\"white\",\n    choices=None,\n    correct_key=\"\",\n    side_effects=None,\n):\n    \"\"\"\n    Arguments:\n        duration: time in ms the stimulus is presented\n        text: the text should be presented\n        color: the color of the text\n        choices: the keys that will be recorded if pressed\n        correct_key: the correct key to press\n        side_effects: Optional side-effect configuration passed to the runtime. This expects\n            a list of SideEffect definitions (see SweetBean docs) which can be\n            used to update global data like overall score or trial counter.s\n    \"\"\"\n    if choices is None:\n        choices = []\n\n    def stim(cl, txt):\n        return f\"&lt;div style='color:{cl}'&gt;{txt}&lt;/div&gt;\"\n\n    stimulus_ = FunctionVariable(\"stimulus\", stim, [color, text])\n    super().__init__(duration, stimulus_, choices, correct_key, side_effects)\n\n    self.arg.update({\"text\": text, \"color\": color})\n</code></pre>"},{"location":"reference/sweetbean/stimulus/Image/","title":"sweetbean.stimulus.Image","text":""},{"location":"reference/sweetbean/stimulus/Image/#sweetbean.stimulus.Image.Image","title":"<code>Image</code>","text":"<p>               Bases: <code>_KeyboardResponseStimulus</code></p> <p>shows an image</p> Source code in <code>sweetbean/stimulus/Image.py</code> <pre><code>class Image(_KeyboardResponseStimulus):\n    \"\"\"\n    shows an image\n    \"\"\"\n\n    type = \"jsPsychImageKeyboardResponse\"\n\n    def __init__(\n        self,\n        duration=None,\n        stimulus=\"\",\n        choices=None,\n        correct_key=\"\",\n        side_effects=None,\n    ):\n        \"\"\"\n        Arguments:\n            duration: time in ms the stimulus is presented\n            stimulus: the path to the image\n            choices: the keys that will be recorded if pressed\n            correct_key: the correct key to press\n            side_effects: Optional side-effect configuration passed to the runtime. This expects\n                a list of SideEffect definitions (see SweetBean docs) which can be\n                used to update global data like overall score or trial counter.\n        \"\"\"\n        super().__init__(locals(), side_effects)\n\n    def _add_special_param(self):\n        pass\n\n    def _set_before(self):\n        pass\n\n    def _get_prompt_l(self):\n        try:\n            with open(\"image_prompts.json\") as f:\n                image_prompts = json.load(f)\n        except FileNotFoundError:\n            raise FileNotFoundError(\n                \"The file 'image_prompts.json' was not found. \"\n                \"If you are using the Image stimulus, you need to provide a file \"\n                \"'image_prompts.json' in the same directory as your experiment script. \"\n                \"It should contain a dictionary with image paths as keys and prompts \"\n                \"as values.\"\n            )\n        except json.JSONDecodeError:\n            raise ValueError(\n                \"The file 'image_prompts.json' contains invalid JSON.\"\n                \"If you are using the Image stimulus, you need to provide a file \"\n                \"'image_prompts.json' in the same directory as your experiment script. \"\n                \"It should contain a dictionary with image paths as keys and prompts \"\n                \"as values.\"\n            )\n        if not self.l_args[\"stimulus\"] in image_prompts:\n            raise ValueError(\n                f\"The image {self.l_args['stimulus']} is not in the image_prompts.json file.\"\n                \"If you are using the Image stimulus, you need to provide a file \"\n                \"'image_prompts.json' in the same directory as your experiment script. \"\n                \"It should contain a dictionary with image paths as keys and prompts \"\n                \"as values.\"\n            )\n\n        return image_prompts[self.l_args[\"stimulus\"]]\n</code></pre>"},{"location":"reference/sweetbean/stimulus/Image/#sweetbean.stimulus.Image.Image.__init__","title":"<code>__init__(duration=None, stimulus='', choices=None, correct_key='', side_effects=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>duration</code> <p>time in ms the stimulus is presented</p> <code>None</code> <code>stimulus</code> <p>the path to the image</p> <code>''</code> <code>choices</code> <p>the keys that will be recorded if pressed</p> <code>None</code> <code>correct_key</code> <p>the correct key to press</p> <code>''</code> <code>side_effects</code> <p>Optional side-effect configuration passed to the runtime. This expects a list of SideEffect definitions (see SweetBean docs) which can be used to update global data like overall score or trial counter.</p> <code>None</code> Source code in <code>sweetbean/stimulus/Image.py</code> <pre><code>def __init__(\n    self,\n    duration=None,\n    stimulus=\"\",\n    choices=None,\n    correct_key=\"\",\n    side_effects=None,\n):\n    \"\"\"\n    Arguments:\n        duration: time in ms the stimulus is presented\n        stimulus: the path to the image\n        choices: the keys that will be recorded if pressed\n        correct_key: the correct key to press\n        side_effects: Optional side-effect configuration passed to the runtime. This expects\n            a list of SideEffect definitions (see SweetBean docs) which can be\n            used to update global data like overall score or trial counter.\n    \"\"\"\n    super().__init__(locals(), side_effects)\n</code></pre>"},{"location":"reference/sweetbean/stimulus/RO/","title":"sweetbean.stimulus.RO","text":""},{"location":"reference/sweetbean/stimulus/RO/#sweetbean.stimulus.RO.RandomDotPatterns","title":"<code>RandomDotPatterns</code>","text":"<p>               Bases: <code>ROK</code></p> Source code in <code>sweetbean/stimulus/RO.py</code> <pre><code>class RandomDotPatterns(ROK):\n    def __init__(\n        self,\n        duration=None,\n        number_of_oobs=300,\n        number_of_apertures=2,\n        coherent_orientation=0,\n        coherence_orientation=0,\n        aperture_position_left=50,\n        aperture_position_top=50,\n        oob_color=\"white\",\n        background_color=\"grey\",\n        stimulus_type=1,\n        choices=None,\n        correct_key=\"\",\n        side_effects=None,\n    ):\n        \"\"\"\n        Arguments:\n            duration: time in ms the stimulus is presented // trial_duration\n            number_of_oobs: the number of oriented objects per set in the stimulus\n            number_of_apertures: the number of kinematograms\n            coherent_orientation: the orientation of the objects in degree\n                (0 degree meaning right)\n            coherence_orientation: the percentage of oriented objects moving in the coherent\n                direction.\n            aperture_position_left: position of midpoint of aperture in x direction in percentage\n                of window width\n            aperture_position_top: position of midpoint of aperture in y direction in percentage\n                of window height\n            oob_color: the color of the orientated objects\n            background_color: the background color\n            choices: the valid keys that the subject can press to indicate a response\n            correct_key: the correct key to press\n            side_effects: Optional side-effect configuration passed to the runtime. This expects\n                a list of SideEffect definitions (see SweetBean docs) which can be\n                used to update global data like overall score or trial counter.\n        \"\"\"\n        if choices is None:\n            choices = []\n\n        super().__init__(\n            duration=duration,\n            number_of_oobs=number_of_oobs,\n            number_of_apertures=number_of_apertures,\n            coherent_movement_direction=0,\n            coherent_orientation=coherent_orientation,\n            coherence_movement=0,\n            coherence_orientation=coherence_orientation,\n            movement_speed=0,\n            aperture_position_left=aperture_position_left,\n            aperture_position_top=aperture_position_top,\n            oob_color=oob_color,\n            background_color=background_color,\n            stimulus_type=stimulus_type,\n            choices=choices,\n            correct_key=correct_key,\n            side_effects=side_effects,\n        )\n</code></pre>"},{"location":"reference/sweetbean/stimulus/RO/#sweetbean.stimulus.RO.RandomDotPatterns.__init__","title":"<code>__init__(duration=None, number_of_oobs=300, number_of_apertures=2, coherent_orientation=0, coherence_orientation=0, aperture_position_left=50, aperture_position_top=50, oob_color='white', background_color='grey', stimulus_type=1, choices=None, correct_key='', side_effects=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>duration</code> <p>time in ms the stimulus is presented // trial_duration</p> <code>None</code> <code>number_of_oobs</code> <p>the number of oriented objects per set in the stimulus</p> <code>300</code> <code>number_of_apertures</code> <p>the number of kinematograms</p> <code>2</code> <code>coherent_orientation</code> <p>the orientation of the objects in degree (0 degree meaning right)</p> <code>0</code> <code>coherence_orientation</code> <p>the percentage of oriented objects moving in the coherent direction.</p> <code>0</code> <code>aperture_position_left</code> <p>position of midpoint of aperture in x direction in percentage of window width</p> <code>50</code> <code>aperture_position_top</code> <p>position of midpoint of aperture in y direction in percentage of window height</p> <code>50</code> <code>oob_color</code> <p>the color of the orientated objects</p> <code>'white'</code> <code>background_color</code> <p>the background color</p> <code>'grey'</code> <code>choices</code> <p>the valid keys that the subject can press to indicate a response</p> <code>None</code> <code>correct_key</code> <p>the correct key to press</p> <code>''</code> <code>side_effects</code> <p>Optional side-effect configuration passed to the runtime. This expects a list of SideEffect definitions (see SweetBean docs) which can be used to update global data like overall score or trial counter.</p> <code>None</code> Source code in <code>sweetbean/stimulus/RO.py</code> <pre><code>def __init__(\n    self,\n    duration=None,\n    number_of_oobs=300,\n    number_of_apertures=2,\n    coherent_orientation=0,\n    coherence_orientation=0,\n    aperture_position_left=50,\n    aperture_position_top=50,\n    oob_color=\"white\",\n    background_color=\"grey\",\n    stimulus_type=1,\n    choices=None,\n    correct_key=\"\",\n    side_effects=None,\n):\n    \"\"\"\n    Arguments:\n        duration: time in ms the stimulus is presented // trial_duration\n        number_of_oobs: the number of oriented objects per set in the stimulus\n        number_of_apertures: the number of kinematograms\n        coherent_orientation: the orientation of the objects in degree\n            (0 degree meaning right)\n        coherence_orientation: the percentage of oriented objects moving in the coherent\n            direction.\n        aperture_position_left: position of midpoint of aperture in x direction in percentage\n            of window width\n        aperture_position_top: position of midpoint of aperture in y direction in percentage\n            of window height\n        oob_color: the color of the orientated objects\n        background_color: the background color\n        choices: the valid keys that the subject can press to indicate a response\n        correct_key: the correct key to press\n        side_effects: Optional side-effect configuration passed to the runtime. This expects\n            a list of SideEffect definitions (see SweetBean docs) which can be\n            used to update global data like overall score or trial counter.\n    \"\"\"\n    if choices is None:\n        choices = []\n\n    super().__init__(\n        duration=duration,\n        number_of_oobs=number_of_oobs,\n        number_of_apertures=number_of_apertures,\n        coherent_movement_direction=0,\n        coherent_orientation=coherent_orientation,\n        coherence_movement=0,\n        coherence_orientation=coherence_orientation,\n        movement_speed=0,\n        aperture_position_left=aperture_position_left,\n        aperture_position_top=aperture_position_top,\n        oob_color=oob_color,\n        background_color=background_color,\n        stimulus_type=stimulus_type,\n        choices=choices,\n        correct_key=correct_key,\n        side_effects=side_effects,\n    )\n</code></pre>"},{"location":"reference/sweetbean/stimulus/RO/#sweetbean.stimulus.RO.RandomObjectKinematogram","title":"<code>RandomObjectKinematogram</code>","text":"<p>               Bases: <code>_BaseStimulus</code></p> <p>Show a random-object-kinematogram</p> Source code in <code>sweetbean/stimulus/RO.py</code> <pre><code>class RandomObjectKinematogram(_BaseStimulus):\n    \"\"\"\n    Show a random-object-kinematogram\n    \"\"\"\n\n    type = \"jsPsychRok\"\n\n    def __init__(\n        self,\n        duration=None,\n        number_of_oobs=300,\n        number_of_apertures=1,\n        coherent_movement_direction=180,\n        coherent_orientation=180,\n        coherence_movement=100,\n        coherence_orientation=100,\n        movement_speed=10,\n        aperture_position_left=50,\n        aperture_position_top=50,\n        oob_color=\"white\",\n        background_color=\"black\",\n        stimulus_type=0,\n        choices=None,\n        correct_key=\"\",\n        side_effects=None,\n    ):\n        \"\"\"\n        Arguments:\n            duration: time in ms the stimulus is presented // trial_duration\n            number_of_oobs: the number of oriented objects per set in the stimulus\n            number_of_apertures: the number of kinematograms\n            coherent_movement_direction: the direction of coherent motion in degrees\n                (0 degre meaning right)\n            coherent_orientation: the orientation of the objects in degree\n                (0 degree meaning right)\n            coherence_movement: the percentage of oriented objects moving in the coherent direction.\n            coherence_orientation: the percentage of oriented objects moving in the coherent\n                direction.\n            movement_speed: the movement speed of the oobs in (percentage of aperture_width)/second\n            aperture_position_left: position of midpoint of aperture in x direction in percentage\n                of window width\n            aperture_position_top: position of midpoint of aperture in y direction in percentage\n                of window height\n            oob_color: the color of the orientated objects\n            background_color: the background color\n            choices: the valid keys that the subject can press to indicate a response\n            correct_key: the correct key to press\n            side_effects: a dictionary of side effects\n        \"\"\"\n        if choices is None:\n            choices = []\n        correct_choice = [correct_key]\n        super().__init__(locals(), side_effects)\n\n    def _add_special_param(self):\n        pass\n\n    def _process_response(self):\n        self.js_data += 'data[\"bean_correct\"]=data[\"correct\"];'\n\n    def _set_before(self):\n        pass\n\n    def process_l(self, prompts, get_input, multi_turn, datum=None):\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/sweetbean/stimulus/RO/#sweetbean.stimulus.RO.RandomObjectKinematogram.__init__","title":"<code>__init__(duration=None, number_of_oobs=300, number_of_apertures=1, coherent_movement_direction=180, coherent_orientation=180, coherence_movement=100, coherence_orientation=100, movement_speed=10, aperture_position_left=50, aperture_position_top=50, oob_color='white', background_color='black', stimulus_type=0, choices=None, correct_key='', side_effects=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>duration</code> <p>time in ms the stimulus is presented // trial_duration</p> <code>None</code> <code>number_of_oobs</code> <p>the number of oriented objects per set in the stimulus</p> <code>300</code> <code>number_of_apertures</code> <p>the number of kinematograms</p> <code>1</code> <code>coherent_movement_direction</code> <p>the direction of coherent motion in degrees (0 degre meaning right)</p> <code>180</code> <code>coherent_orientation</code> <p>the orientation of the objects in degree (0 degree meaning right)</p> <code>180</code> <code>coherence_movement</code> <p>the percentage of oriented objects moving in the coherent direction.</p> <code>100</code> <code>coherence_orientation</code> <p>the percentage of oriented objects moving in the coherent direction.</p> <code>100</code> <code>movement_speed</code> <p>the movement speed of the oobs in (percentage of aperture_width)/second</p> <code>10</code> <code>aperture_position_left</code> <p>position of midpoint of aperture in x direction in percentage of window width</p> <code>50</code> <code>aperture_position_top</code> <p>position of midpoint of aperture in y direction in percentage of window height</p> <code>50</code> <code>oob_color</code> <p>the color of the orientated objects</p> <code>'white'</code> <code>background_color</code> <p>the background color</p> <code>'black'</code> <code>choices</code> <p>the valid keys that the subject can press to indicate a response</p> <code>None</code> <code>correct_key</code> <p>the correct key to press</p> <code>''</code> <code>side_effects</code> <p>a dictionary of side effects</p> <code>None</code> Source code in <code>sweetbean/stimulus/RO.py</code> <pre><code>def __init__(\n    self,\n    duration=None,\n    number_of_oobs=300,\n    number_of_apertures=1,\n    coherent_movement_direction=180,\n    coherent_orientation=180,\n    coherence_movement=100,\n    coherence_orientation=100,\n    movement_speed=10,\n    aperture_position_left=50,\n    aperture_position_top=50,\n    oob_color=\"white\",\n    background_color=\"black\",\n    stimulus_type=0,\n    choices=None,\n    correct_key=\"\",\n    side_effects=None,\n):\n    \"\"\"\n    Arguments:\n        duration: time in ms the stimulus is presented // trial_duration\n        number_of_oobs: the number of oriented objects per set in the stimulus\n        number_of_apertures: the number of kinematograms\n        coherent_movement_direction: the direction of coherent motion in degrees\n            (0 degre meaning right)\n        coherent_orientation: the orientation of the objects in degree\n            (0 degree meaning right)\n        coherence_movement: the percentage of oriented objects moving in the coherent direction.\n        coherence_orientation: the percentage of oriented objects moving in the coherent\n            direction.\n        movement_speed: the movement speed of the oobs in (percentage of aperture_width)/second\n        aperture_position_left: position of midpoint of aperture in x direction in percentage\n            of window width\n        aperture_position_top: position of midpoint of aperture in y direction in percentage\n            of window height\n        oob_color: the color of the orientated objects\n        background_color: the background color\n        choices: the valid keys that the subject can press to indicate a response\n        correct_key: the correct key to press\n        side_effects: a dictionary of side effects\n    \"\"\"\n    if choices is None:\n        choices = []\n    correct_choice = [correct_key]\n    super().__init__(locals(), side_effects)\n</code></pre>"},{"location":"reference/sweetbean/stimulus/RSVP/","title":"sweetbean.stimulus.RSVP","text":""},{"location":"reference/sweetbean/stimulus/RSVP/#sweetbean.stimulus.RSVP.BilateralRSVP","title":"<code>BilateralRSVP</code>","text":"<p>               Bases: <code>_BaseStimulus</code></p> <p>Two-stream (left/right) wrapper around window.jsPsychBilateralRsvp. You provide left/right item lists (or Variables). The wrapper composes targets/distractors using convenience arrays (scalars/lists/Variables) and delegates to the base RSVP plugin.</p> <p>Streams are pure content; all decoration/color/HTML is via params.</p> Source code in <code>sweetbean/stimulus/RSVP.py</code> <pre><code>class BilateralRSVP(_BaseStimulus):\n    \"\"\"\n    Two-stream (left/right) wrapper around window.jsPsychBilateralRsvp.\n    You provide left/right item lists (or Variables). The wrapper composes\n    targets/distractors using convenience arrays (scalars/lists/Variables) and\n    delegates to the base RSVP plugin.\n\n    Streams are **pure content**; all decoration/color/HTML is via params.\n    \"\"\"\n\n    type = \"jsPsychBilateralRsvp\"\n\n    def __init__(\n        self,\n        # ---------------- Content ----------------\n        left: Any,\n        right: Any,\n        # ---------------- Targets (scalars OR lists OR Variables) ----------------\n        target_side: Optional[Union[StrLike, StrListLike]] = \"left\",  # \"left\" | \"right\"\n        target_index: Optional[Union[IntLike, IntListLike]] = 0,\n        target_shape: Optional[\n            Union[StrLike, StrListLike]\n        ] = \"circle\",  # \"circle\"|\"square\"|\"underline\"|\"none\"\n        target_color: Optional[Union[CssLike, List[CssLike], Var]] = None,\n        target_html: Optional[Union[HtmlLike, List[HtmlLike], Var]] = None,\n        # ---------------- Distractors (scalars OR lists OR Variables) ----------------\n        distractor_index: Optional[Union[IntLike, IntListLike]] = None,\n        distractor_side: Optional[\n            Union[StrLike, StrListLike]\n        ] = None,  # if omitted, plugin infers opposite of target_side\n        distractor_shape: Optional[Union[StrLike, StrListLike]] = None,\n        distractor_color: Optional[Union[CssLike, List[CssLike], Var]] = None,\n        distractor_html: Optional[Union[HtmlLike, List[HtmlLike], Var]] = None,\n        # ---------------- Presentation/timing ----------------\n        stimulus_duration: IntLike = 100,\n        isi: IntLike = 0,\n        choices: Union[StrLike, List[StrLike]] = \"ALL\",\n        mask_html: Optional[HtmlLike] = None,\n        color: CssLike = \"#ffffff\",\n        background: CssLike = \"#000000\",\n        token_box_size: CssLike = \"18vmin\",\n        token_font_size: CssLike = \"10vmin\",\n        token_padding: CssLike = \"0.25em 0.45em\",\n        trial_duration: Optional[IntLike] = None,\n        # ---------------- Convenience ----------------\n        end_on_response: BoolLike = False,  # maps to response_ends_trial in underlying plugin\n        # ---------------- SweetBean generic ----------------\n        duration: Optional[IntLike] = None,\n        side_effects: Optional[Dict[str, Any]] = None,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        left, right : list | Variable\n            Content lists for the left/right streams (e.g., [\"O\",\"Q\",\"O\",...]).\n            May be Variables that evaluate to such lists.\n\n        target_side : \"left\" | \"right\" | list[...] | Variable\n            Side(s) containing the target(s). Lists broadcast with other target_* arrays.\n        target_index : int | list[int|Variable] | Variable\n            Index/indices of target(s) within the chosen stream(s).\n        target_shape : {\"circle\",\"square\",\"underline\",\"none\"} | list[...] | Variable\n            Per-item decoration; \"none\" means color-only (no outline).\n        target_color : CSS color | list[...] | Variable\n            Per-item color (glyph color when shape == \"none\"; else border/underline color).\n        target_html : str (template or full HTML) | list[...] | Variable\n            If includes {{content}} / {CONTENT}, wraps the stream glyph; otherwise full override.\n\n        distractor_index : int | list[int|Variable] | Variable\n            Index/indices of distractor(s). If omitted and you set target_index,\n            Bilateral defaults to the same index as each target (per-item).\n        distractor_side : \"left\" | \"right\" | list[...] | Variable\n            Side(s) for distractor(s). If omitted and target_side is provided,\n            Bilateral infers the **opposite** side for each item.\n        distractor_shape : {\"circle\",\"square\",\"underline\",\"none\"} | list[...] | Variable\n            Per-item distractor decoration.\n        distractor_color : CSS color | list[...] | Variable\n            Per-item distractor color (glyph if shape==\"none\"; else border/underline).\n        distractor_html : str (template/full) | list[...] | Variable\n            Per-item HTML for distractors (same templating as targets).\n\n        stimulus_duration : int | Variable\n            Milliseconds each token is displayed.\n        isi : int | Variable\n            Inter-stimulus interval (ms) between tokens.\n        choices : \"ALL\" | \"NO_KEYS\" | list[str] | Variable\n            Allowed keys during RSVP. Use \"NO_KEYS\" when collecting responses afterward.\n        mask_html : str | None | Variable\n            HTML mask shown during ISI (e.g., \"\u2022\").\n        color, background, token_box_size, token_font_size, token_padding : CSS | Variable\n            Visual defaults passed through to the underlying RSVP plugin.\n        trial_duration : int | None | Variable\n            Hard stop for the RSVP (ms).\n\n        end_on_response : bool | Variable\n            Convenience; maps to the underlying plugin\u2019s `response_ends_trial`.\n\n        duration : int | None | Variable\n            SweetBean alias mirrored into `trial_duration`.\n        side_effects :\n            Optional side-effect configuration passed to the runtime. This expects\n                a list of SideEffect definitions (see SweetBean docs) which can be\n                used to update global data like overall score or trial counter.\n        \"\"\"\n        if distractor_index is None:\n            distractor_index = target_index\n        super().__init__(locals(), side_effects)\n\n    def _add_special_param(self):\n        # Mirror SweetBean `duration` \u2192 jsPsych `trial_duration`\n        if self.arg_js.get(\"duration\") not in (None, \"null\"):\n            self.arg_js[\"trial_duration\"] = self.arg_js[\"duration\"]\n\n        # Map convenience alias end_on_response -&gt; response_ends_trial (passed through)\n        try:\n            if \"end_on_response\" in self.arg_js:\n                self.arg_js[\"response_ends_trial\"] = bool(\n                    self.arg_js[\"end_on_response\"]\n                )\n        except Exception:\n            pass\n\n    def _process_response(self):\n        # The underlying RSVP provides key_press/rt; add SweetBean convenience fields:\n        self.js_data += 'data[\"bean_key\"] = data[\"key_press\"];'\n        self.js_data += 'data[\"bean_rt\"] = data[\"rt\"];'\n        self.js_data += (\n            'data[\"bean_any_hit\"] = '\n            '(Array.isArray(data[\"targets\"]) &amp;&amp; data[\"targets\"].some(t =&gt; t.hit));'\n        )\n\n    def _set_before(self):\n        pass\n\n    def process_l(self, prompts, get_input, multi_turn, datum=None):\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/sweetbean/stimulus/RSVP/#sweetbean.stimulus.RSVP.BilateralRSVP.__init__","title":"<code>__init__(left, right, target_side='left', target_index=0, target_shape='circle', target_color=None, target_html=None, distractor_index=None, distractor_side=None, distractor_shape=None, distractor_color=None, distractor_html=None, stimulus_duration=100, isi=0, choices='ALL', mask_html=None, color='#ffffff', background='#000000', token_box_size='18vmin', token_font_size='10vmin', token_padding='0.25em 0.45em', trial_duration=None, end_on_response=False, duration=None, side_effects=None)</code>","text":""},{"location":"reference/sweetbean/stimulus/RSVP/#sweetbean.stimulus.RSVP.BilateralRSVP.__init__--parameters","title":"Parameters","text":"<p>left, right : list | Variable     Content lists for the left/right streams (e.g., [\"O\",\"Q\",\"O\",...]).     May be Variables that evaluate to such lists.</p> \"left\" | \"right\" | list[...] | Variable <p>Side(s) containing the target(s). Lists broadcast with other target_* arrays.</p> <p>target_index : int | list[int|Variable] | Variable     Index/indices of target(s) within the chosen stream(s). target_shape : {\"circle\",\"square\",\"underline\",\"none\"} | list[...] | Variable     Per-item decoration; \"none\" means color-only (no outline). target_color : CSS color | list[...] | Variable     Per-item color (glyph color when shape == \"none\"; else border/underline color). target_html : str (template or full HTML) | list[...] | Variable     If includes {{content}} / {CONTENT}, wraps the stream glyph; otherwise full override.</p> int | list[int|Variable] | Variable <p>Index/indices of distractor(s). If omitted and you set target_index, Bilateral defaults to the same index as each target (per-item).</p> <p>distractor_side : \"left\" | \"right\" | list[...] | Variable     Side(s) for distractor(s). If omitted and target_side is provided,     Bilateral infers the opposite side for each item. distractor_shape : {\"circle\",\"square\",\"underline\",\"none\"} | list[...] | Variable     Per-item distractor decoration. distractor_color : CSS color | list[...] | Variable     Per-item distractor color (glyph if shape==\"none\"; else border/underline). distractor_html : str (template/full) | list[...] | Variable     Per-item HTML for distractors (same templating as targets).</p> int | Variable <p>Milliseconds each token is displayed.</p> <p>isi : int | Variable     Inter-stimulus interval (ms) between tokens. choices : \"ALL\" | \"NO_KEYS\" | list[str] | Variable     Allowed keys during RSVP. Use \"NO_KEYS\" when collecting responses afterward. mask_html : str | None | Variable     HTML mask shown during ISI (e.g., \"\u2022\"). color, background, token_box_size, token_font_size, token_padding : CSS | Variable     Visual defaults passed through to the underlying RSVP plugin. trial_duration : int | None | Variable     Hard stop for the RSVP (ms).</p> bool | Variable <p>Convenience; maps to the underlying plugin\u2019s <code>response_ends_trial</code>.</p> int | None | Variable <p>SweetBean alias mirrored into <code>trial_duration</code>.</p> <p>side_effects :     Optional side-effect configuration passed to the runtime. This expects         a list of SideEffect definitions (see SweetBean docs) which can be         used to update global data like overall score or trial counter.</p> Source code in <code>sweetbean/stimulus/RSVP.py</code> <pre><code>def __init__(\n    self,\n    # ---------------- Content ----------------\n    left: Any,\n    right: Any,\n    # ---------------- Targets (scalars OR lists OR Variables) ----------------\n    target_side: Optional[Union[StrLike, StrListLike]] = \"left\",  # \"left\" | \"right\"\n    target_index: Optional[Union[IntLike, IntListLike]] = 0,\n    target_shape: Optional[\n        Union[StrLike, StrListLike]\n    ] = \"circle\",  # \"circle\"|\"square\"|\"underline\"|\"none\"\n    target_color: Optional[Union[CssLike, List[CssLike], Var]] = None,\n    target_html: Optional[Union[HtmlLike, List[HtmlLike], Var]] = None,\n    # ---------------- Distractors (scalars OR lists OR Variables) ----------------\n    distractor_index: Optional[Union[IntLike, IntListLike]] = None,\n    distractor_side: Optional[\n        Union[StrLike, StrListLike]\n    ] = None,  # if omitted, plugin infers opposite of target_side\n    distractor_shape: Optional[Union[StrLike, StrListLike]] = None,\n    distractor_color: Optional[Union[CssLike, List[CssLike], Var]] = None,\n    distractor_html: Optional[Union[HtmlLike, List[HtmlLike], Var]] = None,\n    # ---------------- Presentation/timing ----------------\n    stimulus_duration: IntLike = 100,\n    isi: IntLike = 0,\n    choices: Union[StrLike, List[StrLike]] = \"ALL\",\n    mask_html: Optional[HtmlLike] = None,\n    color: CssLike = \"#ffffff\",\n    background: CssLike = \"#000000\",\n    token_box_size: CssLike = \"18vmin\",\n    token_font_size: CssLike = \"10vmin\",\n    token_padding: CssLike = \"0.25em 0.45em\",\n    trial_duration: Optional[IntLike] = None,\n    # ---------------- Convenience ----------------\n    end_on_response: BoolLike = False,  # maps to response_ends_trial in underlying plugin\n    # ---------------- SweetBean generic ----------------\n    duration: Optional[IntLike] = None,\n    side_effects: Optional[Dict[str, Any]] = None,\n):\n    \"\"\"\n    Parameters\n    ----------\n    left, right : list | Variable\n        Content lists for the left/right streams (e.g., [\"O\",\"Q\",\"O\",...]).\n        May be Variables that evaluate to such lists.\n\n    target_side : \"left\" | \"right\" | list[...] | Variable\n        Side(s) containing the target(s). Lists broadcast with other target_* arrays.\n    target_index : int | list[int|Variable] | Variable\n        Index/indices of target(s) within the chosen stream(s).\n    target_shape : {\"circle\",\"square\",\"underline\",\"none\"} | list[...] | Variable\n        Per-item decoration; \"none\" means color-only (no outline).\n    target_color : CSS color | list[...] | Variable\n        Per-item color (glyph color when shape == \"none\"; else border/underline color).\n    target_html : str (template or full HTML) | list[...] | Variable\n        If includes {{content}} / {CONTENT}, wraps the stream glyph; otherwise full override.\n\n    distractor_index : int | list[int|Variable] | Variable\n        Index/indices of distractor(s). If omitted and you set target_index,\n        Bilateral defaults to the same index as each target (per-item).\n    distractor_side : \"left\" | \"right\" | list[...] | Variable\n        Side(s) for distractor(s). If omitted and target_side is provided,\n        Bilateral infers the **opposite** side for each item.\n    distractor_shape : {\"circle\",\"square\",\"underline\",\"none\"} | list[...] | Variable\n        Per-item distractor decoration.\n    distractor_color : CSS color | list[...] | Variable\n        Per-item distractor color (glyph if shape==\"none\"; else border/underline).\n    distractor_html : str (template/full) | list[...] | Variable\n        Per-item HTML for distractors (same templating as targets).\n\n    stimulus_duration : int | Variable\n        Milliseconds each token is displayed.\n    isi : int | Variable\n        Inter-stimulus interval (ms) between tokens.\n    choices : \"ALL\" | \"NO_KEYS\" | list[str] | Variable\n        Allowed keys during RSVP. Use \"NO_KEYS\" when collecting responses afterward.\n    mask_html : str | None | Variable\n        HTML mask shown during ISI (e.g., \"\u2022\").\n    color, background, token_box_size, token_font_size, token_padding : CSS | Variable\n        Visual defaults passed through to the underlying RSVP plugin.\n    trial_duration : int | None | Variable\n        Hard stop for the RSVP (ms).\n\n    end_on_response : bool | Variable\n        Convenience; maps to the underlying plugin\u2019s `response_ends_trial`.\n\n    duration : int | None | Variable\n        SweetBean alias mirrored into `trial_duration`.\n    side_effects :\n        Optional side-effect configuration passed to the runtime. This expects\n            a list of SideEffect definitions (see SweetBean docs) which can be\n            used to update global data like overall score or trial counter.\n    \"\"\"\n    if distractor_index is None:\n        distractor_index = target_index\n    super().__init__(locals(), side_effects)\n</code></pre>"},{"location":"reference/sweetbean/stimulus/RSVP/#sweetbean.stimulus.RSVP.RSVP","title":"<code>RSVP</code>","text":"<p>               Bases: <code>_BaseStimulus</code></p> <p>General RSVP wrapper for your jsPsych plugin: window.jsPsychRsvp (plugin name: \"rsvp\" / class var: jsPsychRsvp)</p> <p>Streams are pure content (letters/digits). All shapes/colors/HTML wrapping are specified via target/distractor parameters (explicit arrays OR convenience arrays that accept scalars/lists/Variables and are broadcast by the plugin).</p> <p>No short-form normalization is performed here\u2014Variables pass through untouched.</p> Source code in <code>sweetbean/stimulus/RSVP.py</code> <pre><code>class RSVP(_BaseStimulus):\n    \"\"\"\n    General RSVP wrapper for your jsPsych plugin: window.jsPsychRsvp\n    (plugin name: \"rsvp\" / class var: jsPsychRsvp)\n\n    Streams are **pure content** (letters/digits). All shapes/colors/HTML wrapping\n    are specified via target/distractor parameters (explicit arrays OR convenience\n    arrays that accept scalars/lists/Variables and are broadcast by the plugin).\n\n    No short-form normalization is performed here\u2014Variables pass through untouched.\n    \"\"\"\n\n    type = \"jsPsychRsvp\"\n\n    def __init__(\n        self,\n        # ---------------- Appearance / layout ----------------\n        background: CssLike = \"#000000\",\n        color: CssLike = \"#ffffff\",\n        direction: StrLike = \"row\",  # \"row\" | \"column\"\n        stream_order: Optional[StrLike] = None,  # e.g., \"left,right\"\n        gap: CssLike = \"6rem\",\n        # ---------------- Token sizing ----------------\n        token_box_size: CssLike = \"18vmin\",  # fixed square box\n        token_font_size: CssLike = \"10vmin\",  # glyph size\n        token_padding: CssLike = \"0.25em 0.45em\",  # inner padding for outlines\n        # ---------------- Streams &amp; timing ----------------\n        streams: Optional[List[Any]] = None,  # preferred: [{\"id\":..., \"items\":[...]}]\n        stimulus_duration: IntLike = 100,  # ms each token is shown\n        isi: IntLike = 0,  # ms between tokens (SOA = dur + isi)\n        mask_html: Optional[HtmlLike] = None,  # HTML shown during ISI (e.g., \"\u2022\")\n        # ---------------- Responses ----------------\n        choices: Union[StrLike, List[StrLike]] = \"ALL\",  # \"ALL\" | \"NO_KEYS\" | [\"f\",\"j\"]\n        end_on_response: BoolLike = False,  # convenience \u2192 response_ends_trial\n        response_window: Optional[IntLike] = None,  # ms; None = unlimited\n        correct_keys: Optional[StrLike] = None,  # e.g., \"f,j\" for scoring\n        # ---------------- Targets (timing + decoration) ----------------\n        decorate_targets: BoolLike = True,  # show decoration if shape != \"none\"\n        target_shape: StrLike = \"none\",  # default shape if per-target omits\n        target_stroke: CssLike = \"3px\",  # outline/underline thickness\n        targets: Optional[\n            List[Dict[str, Any]]\n        ] = None,  # explicit array [{stream_id, index, ...}]\n        # Convenience (scalars OR lists OR Variables) \u2014 broadcast by plugin:\n        target_index: Optional[\n            Union[IntLike, IntListLike]\n        ] = None,  # number | [number|Var,...]\n        target_side: Optional[\n            Union[StrLike, StrListLike]\n        ] = None,  # stream ids (\"left\"/\"right\"/custom)\n        target_color: Optional[\n            Union[CssLike, List[CssLike], Var]\n        ] = None,  # CSS color; with shape:\"none\" colors text\n        target_html: Optional[\n            Union[HtmlLike, List[HtmlLike], Var]\n        ] = None,  # HTML template or full override\n        # ---------------- Distractors (decoration only) ----------------\n        decorate_distractors: BoolLike = False,\n        distractor_shape: StrLike = \"none\",\n        distractor_color: CssLike = \"#888888\",\n        distractor_stroke: CssLike = \"2px\",\n        distractors: Optional[List[Dict[str, Any]]] = None,  # explicit array\n        # Convenience (scalars OR lists OR Variables) \u2014 broadcast by plugin:\n        distractor_index: Optional[Union[IntLike, IntListLike]] = None,\n        distractor_side: Optional[Union[StrLike, StrListLike]] = None,  # stream ids\n        distractor_color2: Optional[\n            Union[CssLike, List[CssLike], Var]\n        ] = None,  # per-item override (else distractor_color)\n        distractor_html: Optional[\n            Union[HtmlLike, List[HtmlLike], Var]\n        ] = None,  # HTML template or full override\n        # ---------------- Lifetime &amp; data ----------------\n        trial_duration: Optional[\n            IntLike\n        ] = None,  # hard stop; else ends after last token\n        record_timestamps: BoolLike = True,  # include per-token onset/offset in data[\"schedule\"]\n        # ---------------- SweetBean generic ----------------\n        duration: Optional[IntLike] = None,  # alias mirrored into trial_duration\n        side_effects: Optional[Dict[str, Any]] = None,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        background : CSS color | Variable\n            Background color for the RSVP screen (e.g., \"#000\", \"black\").\n        color : CSS color | Variable\n            Default text/border color (used when a per-item color is not provided).\n        direction : {\"row\",\"column\"} | Variable\n            Layout of streams (left\u2013right for \"row\", top\u2013bottom for \"column\").\n        stream_order : str | None | Variable\n            Comma-separated DOM order of stream IDs (e.g., \"left,right\").\n            If omitted and there are exactly two streams with row layout, it is\n            auto-filled from the two stream IDs (e.g., \"left,right\").\n        gap : CSS length | Variable\n            Gap between streams in non-bilateral layouts.\n\n        token_box_size : CSS length | Variable\n            Size of the fixed token box (prevents wobble when borders appear).\n        token_font_size : CSS length | Variable\n            Font size for the glyphs inside each token box.\n        token_padding : CSS length | Variable\n            Inner padding used by outlined/underlined shapes.\n\n        streams : list | Variable\n            Per-trial stream specs. Prefer object form:\n              [{\"id\":\"left\",\"items\":[\"O\",\"Q\",...]}, {\"id\":\"right\",\"items\":[\"1\",\"2\",...]}]\n            Streams are **pure content**; do NOT embed \"circle\"/\"square\"/colors here.\n\n        stimulus_duration : int | Variable\n            Milliseconds each token is displayed.\n        isi : int | Variable\n            Inter-stimulus interval (ms) between tokens.\n        mask_html : str | None | Variable\n            Optional HTML shown during the ISI (e.g., \"\u2022\").\n\n        choices : \"ALL\" | \"NO_KEYS\" | list[str] | Variable\n            Allowed keys during RSVP. Use \"NO_KEYS\" when you collect responses afterward.\n        end_on_response : bool | Variable\n            If True, RSVP ends immediately after the first valid keypress\n            (mapped to plugin's `response_ends_trial`).\n        response_window : int | None | Variable\n            Time window (ms) for scoring target hits; None = unlimited.\n        correct_keys : str | None | Variable\n            Comma-separated keys used for per-target hit scoring (optional).\n\n        decorate_targets : bool | Variable\n            Whether to render target decorations (ignored if shape == \"none\").\n        target_shape : {\"circle\",\"square\",\"underline\",\"none\"} | Variable\n            Default shape if a target omits its own shape.\n        target_stroke : CSS length | Variable\n            Outline/underline thickness for targets.\n        targets : list[dict] | None\n            Explicit target list. Each item may include:\n              stream_id, index, label, response_window, correct_keys,\n              shape, color, stroke, padding, html, style, className.\n\n        target_index : int | list[int|Variable] | Variable\n            Convenience form\u2014position(s) of target(s) in their streams.\n        target_side : str | list[str|Variable] | Variable\n            Convenience\u2014stream id(s) (e.g., \"left\"/\"right\"/custom ids).\n        target_color : CSS color | list | Variable\n            Per-item color. If the item's shape is \"none\", this colors the glyph itself.\n        target_html : str (template) | list[str] | Variable\n            Per-item HTML. If it contains {{content}} or {CONTENT}, the stream item\u2019s\n            text is injected; otherwise treated as full override.\n\n        decorate_distractors : bool | Variable\n            Whether to render distractor decorations.\n        distractor_shape : {\"circle\",\"square\",\"underline\",\"none\"} | Variable\n            Default shape for distractors that omit a shape.\n        distractor_color : CSS color | Variable\n            Default distractor color (border or underline; or glyph if shape == \"none\").\n        distractor_stroke : CSS length | Variable\n            Outline/underline thickness for distractors.\n        distractors : list[dict] | None\n            Explicit distractor list. Each item may include:\n              stream_id, index, label, shape, color, stroke, padding, html, style, className.\n\n        distractor_index : int | list[int|Variable] | Variable\n            Convenience\u2014position(s) of distractor(s).\n        distractor_side : str | list[str|Variable] | Variable\n            Convenience\u2014stream id(s) for distractor(s).\n        distractor_color2 : CSS color | list | Variable\n            Per-item color override (falls back to `distractor_color` if not set).\n        distractor_html : str (template) | list[str] | Variable\n            Per-item HTML for distractors (same templating as target_html).\n\n        trial_duration : int | None | Variable\n            Hard stop (ms). If None, the trial ends after the last token (+ ISI).\n        record_timestamps : bool | Variable\n            If True, includes per-token onsets/offsets in data[\"schedule\"].\n\n        duration : int | None | Variable\n            SweetBean alias mirrored into `trial_duration`.\n        side_effects : dict | None\n            Optional side effects passed along at runtime.\n        \"\"\"\n        if streams is None:\n            streams = []\n        if targets is None:\n            targets = []\n        if distractors is None:\n            distractors = []\n        if distractor_index is None and distractors is None:\n            distractor_index = target_index\n\n        # \u26d4\ufe0f Do NOT normalize/transform streams here\u2014must support Variables unchanged.\n        super().__init__(locals(), side_effects)\n\n    # ---- SweetBean hooks ----\n\n    def _add_special_param(self):\n        # Mirror SweetBean `duration` \u2192 jsPsych `trial_duration`\n        if self.arg_js.get(\"duration\") not in (None, \"null\"):\n            self.arg_js[\"trial_duration\"] = self.arg_js[\"duration\"]\n\n        # Map convenience alias end_on_response -&gt; response_ends_trial\n        try:\n            if \"end_on_response\" in self.arg_js:\n                self.arg_js[\"response_ends_trial\"] = bool(\n                    self.arg_js[\"end_on_response\"]\n                )\n        except Exception:\n            pass\n\n        # Auto stream_order if exactly two streams in row layout and not explicitly set\n        try:\n            streams = self.arg_js.get(\"streams\") or []\n            if (\n                (not self.arg_js.get(\"stream_order\"))\n                and self.arg_js.get(\"direction\", \"row\") == \"row\"\n                and isinstance(streams, list)\n                and len(streams) == 2\n            ):\n                a, b = (streams[0] or {}).get(\"id\"), (streams[1] or {}).get(\"id\")\n                if a and b:\n                    self.arg_js[\"stream_order\"] = f\"{a},{b}\"\n        except Exception:\n            pass\n\n        # If any distractor lacks index AND there is exactly one target, copy target's index\n        try:\n            tlist = self.arg_js.get(\"targets\") or []\n            dlist = self.arg_js.get(\"distractors\") or []\n            if (\n                isinstance(tlist, list)\n                and len(tlist) == 1\n                and isinstance(dlist, list)\n                and len(dlist) &gt; 0\n            ):\n                t_idx = tlist[0].get(\"index\", None)\n                for d in dlist:\n                    if \"index\" not in d or d.get(\"index\") in (None, \"null\"):\n                        d[\"index\"] = t_idx\n                self.arg_js[\"distractors\"] = dlist\n        except Exception:\n            pass\n\n    def _process_response(self):\n        # Add SweetBean-style convenience fields to data\n        self.js_data += 'data[\"bean_key\"] = data[\"key_press\"];'\n        self.js_data += 'data[\"bean_rt\"] = data[\"rt\"];'\n        self.js_data += (\n            'data[\"bean_any_hit\"] = '\n            '(Array.isArray(data[\"targets\"]) &amp;&amp; data[\"targets\"].some(t =&gt; t.hit));'\n        )\n\n    def _set_before(self):\n        pass\n\n    def process_l(self, prompts, get_input, multi_turn, datum=None):\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/sweetbean/stimulus/RSVP/#sweetbean.stimulus.RSVP.RSVP.__init__","title":"<code>__init__(background='#000000', color='#ffffff', direction='row', stream_order=None, gap='6rem', token_box_size='18vmin', token_font_size='10vmin', token_padding='0.25em 0.45em', streams=None, stimulus_duration=100, isi=0, mask_html=None, choices='ALL', end_on_response=False, response_window=None, correct_keys=None, decorate_targets=True, target_shape='none', target_stroke='3px', targets=None, target_index=None, target_side=None, target_color=None, target_html=None, decorate_distractors=False, distractor_shape='none', distractor_color='#888888', distractor_stroke='2px', distractors=None, distractor_index=None, distractor_side=None, distractor_color2=None, distractor_html=None, trial_duration=None, record_timestamps=True, duration=None, side_effects=None)</code>","text":""},{"location":"reference/sweetbean/stimulus/RSVP/#sweetbean.stimulus.RSVP.RSVP.__init__--parameters","title":"Parameters","text":"<p>background : CSS color | Variable     Background color for the RSVP screen (e.g., \"#000\", \"black\"). color : CSS color | Variable     Default text/border color (used when a per-item color is not provided). direction : {\"row\",\"column\"} | Variable     Layout of streams (left\u2013right for \"row\", top\u2013bottom for \"column\"). stream_order : str | None | Variable     Comma-separated DOM order of stream IDs (e.g., \"left,right\").     If omitted and there are exactly two streams with row layout, it is     auto-filled from the two stream IDs (e.g., \"left,right\"). gap : CSS length | Variable     Gap between streams in non-bilateral layouts.</p> CSS length | Variable <p>Size of the fixed token box (prevents wobble when borders appear).</p> <p>token_font_size : CSS length | Variable     Font size for the glyphs inside each token box. token_padding : CSS length | Variable     Inner padding used by outlined/underlined shapes.</p> list | Variable <p>Per-trial stream specs. Prefer object form:   [{\"id\":\"left\",\"items\":[\"O\",\"Q\",...]}, {\"id\":\"right\",\"items\":[\"1\",\"2\",...]}] Streams are pure content; do NOT embed \"circle\"/\"square\"/colors here.</p> int | Variable <p>Milliseconds each token is displayed.</p> <p>isi : int | Variable     Inter-stimulus interval (ms) between tokens. mask_html : str | None | Variable     Optional HTML shown during the ISI (e.g., \"\u2022\").</p> \"ALL\" | \"NO_KEYS\" | list[str] | Variable <p>Allowed keys during RSVP. Use \"NO_KEYS\" when you collect responses afterward.</p> <p>end_on_response : bool | Variable     If True, RSVP ends immediately after the first valid keypress     (mapped to plugin's <code>response_ends_trial</code>). response_window : int | None | Variable     Time window (ms) for scoring target hits; None = unlimited. correct_keys : str | None | Variable     Comma-separated keys used for per-target hit scoring (optional).</p> bool | Variable <p>Whether to render target decorations (ignored if shape == \"none\").</p> <p>target_shape : {\"circle\",\"square\",\"underline\",\"none\"} | Variable     Default shape if a target omits its own shape. target_stroke : CSS length | Variable     Outline/underline thickness for targets. targets : list[dict] | None     Explicit target list. Each item may include:       stream_id, index, label, response_window, correct_keys,       shape, color, stroke, padding, html, style, className.</p> int | list[int|Variable] | Variable <p>Convenience form\u2014position(s) of target(s) in their streams.</p> <p>target_side : str | list[str|Variable] | Variable     Convenience\u2014stream id(s) (e.g., \"left\"/\"right\"/custom ids). target_color : CSS color | list | Variable     Per-item color. If the item's shape is \"none\", this colors the glyph itself. target_html : str (template) | list[str] | Variable     Per-item HTML. If it contains {{content}} or {CONTENT}, the stream item\u2019s     text is injected; otherwise treated as full override.</p> bool | Variable <p>Whether to render distractor decorations.</p> <p>distractor_shape : {\"circle\",\"square\",\"underline\",\"none\"} | Variable     Default shape for distractors that omit a shape. distractor_color : CSS color | Variable     Default distractor color (border or underline; or glyph if shape == \"none\"). distractor_stroke : CSS length | Variable     Outline/underline thickness for distractors. distractors : list[dict] | None     Explicit distractor list. Each item may include:       stream_id, index, label, shape, color, stroke, padding, html, style, className.</p> int | list[int|Variable] | Variable <p>Convenience\u2014position(s) of distractor(s).</p> <p>distractor_side : str | list[str|Variable] | Variable     Convenience\u2014stream id(s) for distractor(s). distractor_color2 : CSS color | list | Variable     Per-item color override (falls back to <code>distractor_color</code> if not set). distractor_html : str (template) | list[str] | Variable     Per-item HTML for distractors (same templating as target_html).</p> int | None | Variable <p>Hard stop (ms). If None, the trial ends after the last token (+ ISI).</p> <p>record_timestamps : bool | Variable     If True, includes per-token onsets/offsets in data[\"schedule\"].</p> int | None | Variable <p>SweetBean alias mirrored into <code>trial_duration</code>.</p> <p>side_effects : dict | None     Optional side effects passed along at runtime.</p> Source code in <code>sweetbean/stimulus/RSVP.py</code> <pre><code>def __init__(\n    self,\n    # ---------------- Appearance / layout ----------------\n    background: CssLike = \"#000000\",\n    color: CssLike = \"#ffffff\",\n    direction: StrLike = \"row\",  # \"row\" | \"column\"\n    stream_order: Optional[StrLike] = None,  # e.g., \"left,right\"\n    gap: CssLike = \"6rem\",\n    # ---------------- Token sizing ----------------\n    token_box_size: CssLike = \"18vmin\",  # fixed square box\n    token_font_size: CssLike = \"10vmin\",  # glyph size\n    token_padding: CssLike = \"0.25em 0.45em\",  # inner padding for outlines\n    # ---------------- Streams &amp; timing ----------------\n    streams: Optional[List[Any]] = None,  # preferred: [{\"id\":..., \"items\":[...]}]\n    stimulus_duration: IntLike = 100,  # ms each token is shown\n    isi: IntLike = 0,  # ms between tokens (SOA = dur + isi)\n    mask_html: Optional[HtmlLike] = None,  # HTML shown during ISI (e.g., \"\u2022\")\n    # ---------------- Responses ----------------\n    choices: Union[StrLike, List[StrLike]] = \"ALL\",  # \"ALL\" | \"NO_KEYS\" | [\"f\",\"j\"]\n    end_on_response: BoolLike = False,  # convenience \u2192 response_ends_trial\n    response_window: Optional[IntLike] = None,  # ms; None = unlimited\n    correct_keys: Optional[StrLike] = None,  # e.g., \"f,j\" for scoring\n    # ---------------- Targets (timing + decoration) ----------------\n    decorate_targets: BoolLike = True,  # show decoration if shape != \"none\"\n    target_shape: StrLike = \"none\",  # default shape if per-target omits\n    target_stroke: CssLike = \"3px\",  # outline/underline thickness\n    targets: Optional[\n        List[Dict[str, Any]]\n    ] = None,  # explicit array [{stream_id, index, ...}]\n    # Convenience (scalars OR lists OR Variables) \u2014 broadcast by plugin:\n    target_index: Optional[\n        Union[IntLike, IntListLike]\n    ] = None,  # number | [number|Var,...]\n    target_side: Optional[\n        Union[StrLike, StrListLike]\n    ] = None,  # stream ids (\"left\"/\"right\"/custom)\n    target_color: Optional[\n        Union[CssLike, List[CssLike], Var]\n    ] = None,  # CSS color; with shape:\"none\" colors text\n    target_html: Optional[\n        Union[HtmlLike, List[HtmlLike], Var]\n    ] = None,  # HTML template or full override\n    # ---------------- Distractors (decoration only) ----------------\n    decorate_distractors: BoolLike = False,\n    distractor_shape: StrLike = \"none\",\n    distractor_color: CssLike = \"#888888\",\n    distractor_stroke: CssLike = \"2px\",\n    distractors: Optional[List[Dict[str, Any]]] = None,  # explicit array\n    # Convenience (scalars OR lists OR Variables) \u2014 broadcast by plugin:\n    distractor_index: Optional[Union[IntLike, IntListLike]] = None,\n    distractor_side: Optional[Union[StrLike, StrListLike]] = None,  # stream ids\n    distractor_color2: Optional[\n        Union[CssLike, List[CssLike], Var]\n    ] = None,  # per-item override (else distractor_color)\n    distractor_html: Optional[\n        Union[HtmlLike, List[HtmlLike], Var]\n    ] = None,  # HTML template or full override\n    # ---------------- Lifetime &amp; data ----------------\n    trial_duration: Optional[\n        IntLike\n    ] = None,  # hard stop; else ends after last token\n    record_timestamps: BoolLike = True,  # include per-token onset/offset in data[\"schedule\"]\n    # ---------------- SweetBean generic ----------------\n    duration: Optional[IntLike] = None,  # alias mirrored into trial_duration\n    side_effects: Optional[Dict[str, Any]] = None,\n):\n    \"\"\"\n    Parameters\n    ----------\n    background : CSS color | Variable\n        Background color for the RSVP screen (e.g., \"#000\", \"black\").\n    color : CSS color | Variable\n        Default text/border color (used when a per-item color is not provided).\n    direction : {\"row\",\"column\"} | Variable\n        Layout of streams (left\u2013right for \"row\", top\u2013bottom for \"column\").\n    stream_order : str | None | Variable\n        Comma-separated DOM order of stream IDs (e.g., \"left,right\").\n        If omitted and there are exactly two streams with row layout, it is\n        auto-filled from the two stream IDs (e.g., \"left,right\").\n    gap : CSS length | Variable\n        Gap between streams in non-bilateral layouts.\n\n    token_box_size : CSS length | Variable\n        Size of the fixed token box (prevents wobble when borders appear).\n    token_font_size : CSS length | Variable\n        Font size for the glyphs inside each token box.\n    token_padding : CSS length | Variable\n        Inner padding used by outlined/underlined shapes.\n\n    streams : list | Variable\n        Per-trial stream specs. Prefer object form:\n          [{\"id\":\"left\",\"items\":[\"O\",\"Q\",...]}, {\"id\":\"right\",\"items\":[\"1\",\"2\",...]}]\n        Streams are **pure content**; do NOT embed \"circle\"/\"square\"/colors here.\n\n    stimulus_duration : int | Variable\n        Milliseconds each token is displayed.\n    isi : int | Variable\n        Inter-stimulus interval (ms) between tokens.\n    mask_html : str | None | Variable\n        Optional HTML shown during the ISI (e.g., \"\u2022\").\n\n    choices : \"ALL\" | \"NO_KEYS\" | list[str] | Variable\n        Allowed keys during RSVP. Use \"NO_KEYS\" when you collect responses afterward.\n    end_on_response : bool | Variable\n        If True, RSVP ends immediately after the first valid keypress\n        (mapped to plugin's `response_ends_trial`).\n    response_window : int | None | Variable\n        Time window (ms) for scoring target hits; None = unlimited.\n    correct_keys : str | None | Variable\n        Comma-separated keys used for per-target hit scoring (optional).\n\n    decorate_targets : bool | Variable\n        Whether to render target decorations (ignored if shape == \"none\").\n    target_shape : {\"circle\",\"square\",\"underline\",\"none\"} | Variable\n        Default shape if a target omits its own shape.\n    target_stroke : CSS length | Variable\n        Outline/underline thickness for targets.\n    targets : list[dict] | None\n        Explicit target list. Each item may include:\n          stream_id, index, label, response_window, correct_keys,\n          shape, color, stroke, padding, html, style, className.\n\n    target_index : int | list[int|Variable] | Variable\n        Convenience form\u2014position(s) of target(s) in their streams.\n    target_side : str | list[str|Variable] | Variable\n        Convenience\u2014stream id(s) (e.g., \"left\"/\"right\"/custom ids).\n    target_color : CSS color | list | Variable\n        Per-item color. If the item's shape is \"none\", this colors the glyph itself.\n    target_html : str (template) | list[str] | Variable\n        Per-item HTML. If it contains {{content}} or {CONTENT}, the stream item\u2019s\n        text is injected; otherwise treated as full override.\n\n    decorate_distractors : bool | Variable\n        Whether to render distractor decorations.\n    distractor_shape : {\"circle\",\"square\",\"underline\",\"none\"} | Variable\n        Default shape for distractors that omit a shape.\n    distractor_color : CSS color | Variable\n        Default distractor color (border or underline; or glyph if shape == \"none\").\n    distractor_stroke : CSS length | Variable\n        Outline/underline thickness for distractors.\n    distractors : list[dict] | None\n        Explicit distractor list. Each item may include:\n          stream_id, index, label, shape, color, stroke, padding, html, style, className.\n\n    distractor_index : int | list[int|Variable] | Variable\n        Convenience\u2014position(s) of distractor(s).\n    distractor_side : str | list[str|Variable] | Variable\n        Convenience\u2014stream id(s) for distractor(s).\n    distractor_color2 : CSS color | list | Variable\n        Per-item color override (falls back to `distractor_color` if not set).\n    distractor_html : str (template) | list[str] | Variable\n        Per-item HTML for distractors (same templating as target_html).\n\n    trial_duration : int | None | Variable\n        Hard stop (ms). If None, the trial ends after the last token (+ ISI).\n    record_timestamps : bool | Variable\n        If True, includes per-token onsets/offsets in data[\"schedule\"].\n\n    duration : int | None | Variable\n        SweetBean alias mirrored into `trial_duration`.\n    side_effects : dict | None\n        Optional side effects passed along at runtime.\n    \"\"\"\n    if streams is None:\n        streams = []\n    if targets is None:\n        targets = []\n    if distractors is None:\n        distractors = []\n    if distractor_index is None and distractors is None:\n        distractor_index = target_index\n\n    # \u26d4\ufe0f Do NOT normalize/transform streams here\u2014must support Variables unchanged.\n    super().__init__(locals(), side_effects)\n</code></pre>"},{"location":"reference/sweetbean/stimulus/Survey/","title":"sweetbean.stimulus.Survey","text":""},{"location":"reference/sweetbean/stimulus/Survey/#sweetbean.stimulus.Survey.LikertSurvey","title":"<code>LikertSurvey</code>","text":"<p>               Bases: <code>_Survey</code></p> <p>A survey that asks for Likert scale input</p> Source code in <code>sweetbean/stimulus/Survey.py</code> <pre><code>class LikertSurvey(_Survey):\n    \"\"\"\n    A survey that asks for Likert scale input\n    \"\"\"\n\n    type = \"jsPsychSurveyLikert\"\n\n    def __init__(self, questions=None, side_effects=None):\n        \"\"\"\n        Arguments:\n            questions: a list of dictionaries with the keys \"prompt\" and \"labels\"\n            side_effects: a dictionary of side effects\n        \"\"\"\n        if not questions:\n            questions = []\n\n        def get_prompts(_prompts):\n            prompts_ = []\n            for p in _prompts:\n                prompts_.append({\"prompt\": p[\"prompt\"], \"labels\": p[\"labels\"]})\n            return prompts_\n\n        questions_ = FunctionVariable(\"questions\", get_prompts, [questions])\n        super().__init__(questions_, side_effects=side_effects)\n\n    #\n    @classmethod\n    def from_scale(cls, prompts=None, scale=None, side_effects=None):\n        \"\"\"\n        Create a LikertSurvey from a scale\n\n        Arguments:\n            prompts: a list of strings representing the prompts\n            scale: a list of strings representing the scale\n            side_effects: a dictionary of side effects\n        \"\"\"\n        if not prompts:\n            prompts = []\n        if not scale:\n            scale = []\n        prompts_ = []\n        for p in prompts:\n            prompts_.append({\"prompt\": p, \"labels\": scale})\n        return cls(prompts_, side_effects=side_effects)\n\n    def process_l(self, prompts, get_input, multi_turn, datum=None):\n        current_prompt = []\n        responses = {}\n        data = self.l_args.copy()\n        for idx, question in enumerate(self.l_args[\"questions\"]):\n            current_prompt.append(question[\"prompt\"])\n            current_prompt[-1] += \" Your options are: \" + \", \".join(\n                [str(i) for i in question[\"labels\"]]\n            )\n            if not multi_turn:\n                _in_prompt = (\n                    \" \".join([p for p in prompts])\n                    + \" \".join([c for c in current_prompt])\n                    + \"&lt;&lt;\"\n                )\n            else:\n                _in_prompt = current_prompt[-1] + \"&lt;&lt;\"\n            if not datum:\n                response = get_input(_in_prompt)\n            else:\n                response = datum[\"response\"][f\"Q{str(idx)}\"]\n            current_prompt[-1] += f\"&lt;&lt;{response}&gt;&gt;\"\n            responses[f\"Q{str(idx)}\"] = response\n        data.update({\"response\": responses})\n        prompts += current_prompt\n        return data, prompts\n</code></pre>"},{"location":"reference/sweetbean/stimulus/Survey/#sweetbean.stimulus.Survey.LikertSurvey.__init__","title":"<code>__init__(questions=None, side_effects=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>questions</code> <p>a list of dictionaries with the keys \"prompt\" and \"labels\"</p> <code>None</code> <code>side_effects</code> <p>a dictionary of side effects</p> <code>None</code> Source code in <code>sweetbean/stimulus/Survey.py</code> <pre><code>def __init__(self, questions=None, side_effects=None):\n    \"\"\"\n    Arguments:\n        questions: a list of dictionaries with the keys \"prompt\" and \"labels\"\n        side_effects: a dictionary of side effects\n    \"\"\"\n    if not questions:\n        questions = []\n\n    def get_prompts(_prompts):\n        prompts_ = []\n        for p in _prompts:\n            prompts_.append({\"prompt\": p[\"prompt\"], \"labels\": p[\"labels\"]})\n        return prompts_\n\n    questions_ = FunctionVariable(\"questions\", get_prompts, [questions])\n    super().__init__(questions_, side_effects=side_effects)\n</code></pre>"},{"location":"reference/sweetbean/stimulus/Survey/#sweetbean.stimulus.Survey.LikertSurvey.from_scale","title":"<code>from_scale(prompts=None, scale=None, side_effects=None)</code>  <code>classmethod</code>","text":"<p>Create a LikertSurvey from a scale</p> <p>Parameters:</p> Name Type Description Default <code>prompts</code> <p>a list of strings representing the prompts</p> <code>None</code> <code>scale</code> <p>a list of strings representing the scale</p> <code>None</code> <code>side_effects</code> <p>a dictionary of side effects</p> <code>None</code> Source code in <code>sweetbean/stimulus/Survey.py</code> <pre><code>@classmethod\ndef from_scale(cls, prompts=None, scale=None, side_effects=None):\n    \"\"\"\n    Create a LikertSurvey from a scale\n\n    Arguments:\n        prompts: a list of strings representing the prompts\n        scale: a list of strings representing the scale\n        side_effects: a dictionary of side effects\n    \"\"\"\n    if not prompts:\n        prompts = []\n    if not scale:\n        scale = []\n    prompts_ = []\n    for p in prompts:\n        prompts_.append({\"prompt\": p, \"labels\": scale})\n    return cls(prompts_, side_effects=side_effects)\n</code></pre>"},{"location":"reference/sweetbean/stimulus/Survey/#sweetbean.stimulus.Survey.MultiChoiceSurvey","title":"<code>MultiChoiceSurvey</code>","text":"<p>               Bases: <code>_Survey</code></p> <p>A survey that asks for multiple choice input</p> Source code in <code>sweetbean/stimulus/Survey.py</code> <pre><code>class MultiChoiceSurvey(_Survey):\n    \"\"\"\n    A survey that asks for multiple choice input\n    \"\"\"\n\n    type = \"jsPsychSurveyMultiChoice\"\n\n    def __init__(self, questions=None, side_effects=None):\n        \"\"\"\n        Arguments:\n            questions: a list of dictionaries with the keys \"prompt\" and \"options\"\n            side_effects: a dictionary of side effects\n        \"\"\"\n        if not questions:\n            questions = []\n\n        def get_prompts(_prompts):\n            prompts_ = []\n            for p in _prompts:\n                prompts_.append({\"prompt\": p[\"prompt\"], \"options\": p[\"options\"]})\n            return prompts_\n\n        questions_ = FunctionVariable(\"questions\", get_prompts, [questions])\n        super().__init__(questions_, side_effects=side_effects)\n\n    def process_l(self, prompts, get_input, multi_turn, datum=None):\n        current_prompt = []\n        responses = {}\n        data = self.l_args.copy()\n        for idx, question in enumerate(self.l_args[\"questions\"]):\n            current_prompt.append(question[\"prompt\"])\n            current_prompt[-1] += \" Your options are: \" + \", \".join(\n                [str(i) for i in question[\"options\"]]\n            )\n            if not multi_turn:\n                _in_prompt = (\n                    \" \".join([p for p in prompts])\n                    + \" \".join([c for c in current_prompt])\n                    + \"&lt;&lt;\"\n                )\n            else:\n                _in_prompt = current_prompt[-1] + \"&lt;&lt;\"\n            if not datum:\n                response = get_input(_in_prompt)\n            else:\n                response = datum[\"response\"][f\"Q{str(idx)}\"]\n            current_prompt[-1] += f\"&lt;&lt;{response}&gt;&gt;\"\n            responses[f\"Q{str(idx)}\"] = response\n        data.update({\"response\": responses})\n        prompts += current_prompt\n        return data, prompts\n</code></pre>"},{"location":"reference/sweetbean/stimulus/Survey/#sweetbean.stimulus.Survey.MultiChoiceSurvey.__init__","title":"<code>__init__(questions=None, side_effects=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>questions</code> <p>a list of dictionaries with the keys \"prompt\" and \"options\"</p> <code>None</code> <code>side_effects</code> <p>a dictionary of side effects</p> <code>None</code> Source code in <code>sweetbean/stimulus/Survey.py</code> <pre><code>def __init__(self, questions=None, side_effects=None):\n    \"\"\"\n    Arguments:\n        questions: a list of dictionaries with the keys \"prompt\" and \"options\"\n        side_effects: a dictionary of side effects\n    \"\"\"\n    if not questions:\n        questions = []\n\n    def get_prompts(_prompts):\n        prompts_ = []\n        for p in _prompts:\n            prompts_.append({\"prompt\": p[\"prompt\"], \"options\": p[\"options\"]})\n        return prompts_\n\n    questions_ = FunctionVariable(\"questions\", get_prompts, [questions])\n    super().__init__(questions_, side_effects=side_effects)\n</code></pre>"},{"location":"reference/sweetbean/stimulus/Survey/#sweetbean.stimulus.Survey.TextSurvey","title":"<code>TextSurvey</code>","text":"<p>               Bases: <code>_Survey</code></p> <p>A survey that asks for text input</p> Source code in <code>sweetbean/stimulus/Survey.py</code> <pre><code>class TextSurvey(_Survey):\n    \"\"\"\n    A survey that asks for text input\n    \"\"\"\n\n    type = \"jsPsychSurveyText\"\n\n    def __init__(self, questions=None, side_effects=None):\n        \"\"\"\n        Arguments:\n            questions: a list of strings representing the questions\n            side_effects: Optional side-effect configuration passed to the runtime. This expects\n                a list of SideEffect definitions (see SweetBean docs) which can be\n                used to update global data like overall score or trial counter.\n        \"\"\"\n        if not questions:\n            questions = []\n\n        def get_prompts(_prompts):\n            prompts_ = []\n            for p in _prompts:\n                prompts_.append({\"prompt\": p})\n            return prompts_\n\n        questions_ = FunctionVariable(\"questions\", get_prompts, [questions])\n        super().__init__(questions_, side_effects=side_effects)\n\n    def process_l(self, prompts, get_input, multi_turn, datum=None):\n        current_prompt = []\n        responses = {}\n        data = self.l_args.copy()\n        for idx, question in enumerate(self.l_args[\"questions\"]):\n            current_prompt.append(question[\"prompt\"])\n            if not multi_turn:\n                _in_prompt = (\n                    \" \".join([p for p in prompts])\n                    + \" \".join([c for c in current_prompt])\n                    + \"&lt;&lt;\"\n                )\n            else:\n                _in_prompt = current_prompt[-1] + \"&lt;&lt;\"\n            if not datum:\n                response = get_input(_in_prompt)\n            else:\n                response = datum[\"response\"][f\"Q{str(idx)}\"]\n            current_prompt[-1] += f\"&lt;&lt;{response}&gt;&gt;\"\n            responses[f\"Q{str(idx)}\"] = response\n        data.update({\"response\": responses})\n        prompts += current_prompt\n        return data, prompts\n</code></pre>"},{"location":"reference/sweetbean/stimulus/Survey/#sweetbean.stimulus.Survey.TextSurvey.__init__","title":"<code>__init__(questions=None, side_effects=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>questions</code> <p>a list of strings representing the questions</p> <code>None</code> <code>side_effects</code> <p>Optional side-effect configuration passed to the runtime. This expects a list of SideEffect definitions (see SweetBean docs) which can be used to update global data like overall score or trial counter.</p> <code>None</code> Source code in <code>sweetbean/stimulus/Survey.py</code> <pre><code>def __init__(self, questions=None, side_effects=None):\n    \"\"\"\n    Arguments:\n        questions: a list of strings representing the questions\n        side_effects: Optional side-effect configuration passed to the runtime. This expects\n            a list of SideEffect definitions (see SweetBean docs) which can be\n            used to update global data like overall score or trial counter.\n    \"\"\"\n    if not questions:\n        questions = []\n\n    def get_prompts(_prompts):\n        prompts_ = []\n        for p in _prompts:\n            prompts_.append({\"prompt\": p})\n        return prompts_\n\n    questions_ = FunctionVariable(\"questions\", get_prompts, [questions])\n    super().__init__(questions_, side_effects=side_effects)\n</code></pre>"},{"location":"reference/sweetbean/stimulus/Symbol/","title":"sweetbean.stimulus.Symbol","text":""},{"location":"reference/sweetbean/stimulus/Symbol/#sweetbean.stimulus.Symbol.Symbol","title":"<code>Symbol</code>","text":"<p>               Bases: <code>_BaseStimulus</code></p> <p>SweetBean wrapper for window.jsPsychSymbol (string type: \"symbol\").</p> <p>Minimal + safe conveniences:   - Pass <code>items</code> (list[dict] or Var) directly, OR provide a top-level <code>shape</code>     to spawn a single-item list.   - Top-level <code>color</code>/<code>texture</code> broadcast to items that haven't set their own     (only when items is a concrete list).   - If <code>items</code> is a Variable (TimelineVariable, FunctionVariable, etc.), it is     forwarded unchanged and no expansion/broadcast is attempted     (to avoid incorrect compile-time assumptions).</p> <p>Python API (snake_case) -&gt; plugin (camelCase):   canvas_width -&gt; canvasWidth   canvas_height -&gt; canvasHeight   background -&gt; background   items -&gt; items   duration -&gt; trialDuration   response_ends_trial -&gt; responseEndsTrial   choices -&gt; choices   allow_mouse -&gt; allowMouse</p> Source code in <code>sweetbean/stimulus/Symbol.py</code> <pre><code>class Symbol(_BaseStimulus):\n    \"\"\"\n    SweetBean wrapper for window.jsPsychSymbol (string type: \"symbol\").\n\n    Minimal + safe conveniences:\n      - Pass `items` (list[dict] or Var) directly, OR provide a top-level `shape`\n        to spawn a single-item list.\n      - Top-level `color`/`texture` broadcast to items that haven't set their own\n        (only when items is a concrete list).\n      - If `items` is a Variable (TimelineVariable, FunctionVariable, etc.), it is\n        forwarded unchanged and no expansion/broadcast is attempted\n        (to avoid incorrect compile-time assumptions).\n\n    Python API (snake_case) -&gt; plugin (camelCase):\n      canvas_width -&gt; canvasWidth\n      canvas_height -&gt; canvasHeight\n      background -&gt; background\n      items -&gt; items\n      duration -&gt; trialDuration\n      response_ends_trial -&gt; responseEndsTrial\n      choices -&gt; choices\n      allow_mouse -&gt; allowMouse\n    \"\"\"\n\n    type = \"jsPsychSymbol\"\n\n    def __init__(\n        self,\n        *,\n        # ---- Display ----\n        canvas_width: IntLike = 800,\n        canvas_height: IntLike = 600,\n        background: StrLike = \"transparent\",\n        # ---- Content ----\n        items: Optional[Any] = None,  # list[dict] | Var\n        shape: Optional[\n            StrLike\n        ] = None,  # fast path for a single item (only if concrete)\n        color: Optional[StrLike] = None,  # optional broadcast (concrete lists only)\n        texture: Optional[Any] = None,  # optional broadcast (concrete lists only)\n        # ---- Timing / responses ----\n        duration: Optional[IntLike] = None,\n        response_ends_trial: BoolLike = True,\n        choices: Optional[Union[StrLike, StrListLike]] = None,\n        allow_mouse: BoolLike = False,\n        # ---- Scoring convenience ----\n        correct_key: Optional[StrLike] = None,\n        # ---- SweetBean generic ----\n        side_effects: Optional[Dict[str, Any]] = None,\n    ):\n        \"\"\"\n        Arguments:\n            canvas_width (int): Canvas width in px. Default 800.\n            canvas_height (int): Canvas height in px. Default 600.\n            background (str): Page background CSS color. Default \"transparent\".\n\n            items (list[dict] | None):\n                List of shape dicts. Each item supports:\n\n                  Required\n                  - shape: one of\n                      \"circle\" | \"ring\" | \"rectangle\" | \"triangle\" | \"cross\"\n\n                  Size (by shape)\n                  - circle    : radius (int)\n                  - ring      : innerRadius (int), outerRadius (int)\n                  - rectangle : width (int), height (int), cornerRadius (int, opt)\n                  - triangle  : side (int)\n                  - cross     : armLen (int), armWidth (int)\n\n                  Common (optional)\n                  - x, y      : int. Position in px relative to center (default 0,0)\n                  - z         : int. Draw order; higher draws later (default 0)\n                  - rotation  : float deg, clockwise from vertical (default 0)\n                  - alpha     : float 0..1 (default 1)\n                  - blend     : canvas comp-op string. One of:\n                                 \"source-over\",\"lighter\",\"multiply\",\"screen\",\n                                 \"overlay\",\"darken\",\"lighten\",\"difference\",\n                                 \"exclusion\",\"hard-light\",\"soft-light\"\n                  - color     : CSS color string; used if no texture (default \"#000\")\n                  - texture   : dict (see Texture below)\n                  - stroke    : CSS color string (outline). Optional.\n                  - strokePx  : int stroke width (px). Optional.\n\n            shape (str | None):\n                Fast path. If set and `items` is empty/None, creates a single\n                item {\"shape\": shape}. Useful for one-off trials.\n\n            color (str | None):\n                Broadcast fill color to any item that lacks \"color\".\n                Also applied to the fast-path single item.\n\n            texture (dict | None):\n                Broadcast texture to any item that lacks \"texture\".\n                Also applied to the fast-path single item.\n\n            duration (int | None):\n                Trial timeout in ms. Mapped to plugin key `trialDuration`.\n\n            response_ends_trial (bool): If True, end on first valid response.\n\n            choices (list[str] | str | None):\n                Allowed keys. None/\"\"/\"NO_KEYS\" \u2192 []; \"ALL\"/\"ALL_KEYS\" \u2192 \"ALL_KEYS\";\n                a single string becomes [that string].\n\n            allow_mouse (bool): If True, mouse click counts as a response.\n\n            correct_key (str | None): Copied into data; enables simple correctness.\n\n            side_effects (dict | None): SweetBean side-effects configuration.\n\n            Texture:\n                A texture is a dict with a \"type\" and type-specific fields.\n\n                - type: \"stripes\"\n                  Fields:\n                    bar    : int period in px (stripe A + stripe B). Default 20.\n                    duty   : float 0..1 fraction for stripe A. Default 0.5.\n                    angle  : float deg; extra rotation added to item.rotation. Default 0.\n                    phase  : int px shift along stripe normal. Default 0.\n                    colors : [str, str] optional two-color palette. If omitted, a\n                             light/dark pair is derived from the item \"color\".\n\n                - type: \"noise\"\n                  Fields:\n                    cell   : int size of each block in px. Default 4.\n                    seed   : int optional RNG seed.\n                    colors : [str, str] optional two-color palette. If omitted, a\n                             light/dark pair is derived from the item \"color\".\n                    mix    : float 0..1 mean toward second color. Default 0.5.\n        \"\"\"\n        # ---------------- items construction / broadcasting ----------------\n        items_final: Any = items\n\n        # Heuristic for \"variable-like\": we only treat as concrete when it's a Python list of dicts\n        is_concrete_list = isinstance(items_final, list) and all(\n            isinstance(it, dict) for it in items_final\n        )\n        is_empty_or_none = (items_final is None) or (\n            isinstance(items_final, list) and len(items_final) == 0\n        )\n\n        # Single-item fast path ONLY when shape is a concrete string and items isn't provided\n        if is_empty_or_none and isinstance(shape, str) and shape.strip():\n            one: Dict[str, Any] = {\"shape\": shape.strip()}\n            if color not in (None, \"null\"):\n                one[\"color\"] = color\n            if texture not in (None, \"null\"):\n                one[\"texture\"] = texture\n            items_final = [one]\n            is_concrete_list = True\n\n        # Broadcast top-level color/texture ONLY when we truly have a concrete list\n        if is_concrete_list and (\n            color not in (None, \"null\") or texture not in (None, \"null\")\n        ):\n            out: List[Dict[str, Any]] = []\n            for it in items_final:  # type: ignore[iteration-over-optional]\n                tmp = dict(it)\n                # Add color only if item doesn't specify it\n                if color not in (None, \"null\") and (\"color\" not in tmp):\n                    tmp[\"color\"] = color\n                # Add texture only if item doesn't specify it\n                if texture not in (None, \"null\") and (\"texture\" not in tmp):\n                    tmp[\"texture\"] = texture\n                out.append(tmp)\n            items_final = out\n\n        # ---------------- choices normalization (keep Vars untouched) ----------------\n        choices_final: Any = choices\n        if not hasattr(choices, \"__dict__\") and not callable(choices):\n            if choices in (None, \"NO_KEYS\", \"no_keys\", \"\", []):\n                choices_final = []\n            elif isinstance(choices, str):\n                s = choices.strip()\n                choices_final = \"ALL_KEYS\" if s.lower() in (\"all\", \"all_keys\") else [s]\n            elif isinstance(choices, list):\n                choices_final = choices\n\n        # ---------------- build params for plugin ----------------\n        params: Dict[str, Any] = {\n            \"canvasWidth\": canvas_width,\n            \"canvasHeight\": canvas_height,\n            \"background\": background,\n            \"items\": items_final,\n            \"trialDuration\": duration,  # single source of truth\n            \"responseEndsTrial\": response_ends_trial,\n            \"choices\": choices_final,\n            \"allowMouse\": allow_mouse,\n            # pass-through for scoring convenience (not a plugin param)\n            \"correct_key\": correct_key,\n        }\n\n        super().__init__(params, side_effects)\n\n    # ---- SweetBean hooks -------------------------------------------------\n\n    def _add_special_param(self):\n        # ensure correct_key is included in trial data if provided\n        ck = self.arg_js.get(\"correct_key\", None)\n        if ck not in (None, \"null\"):\n            self.arg_js.setdefault(\"data\", {})\n            self.arg_js[\"data\"][\"correct_key\"] = ck\n\n    def _process_response(self):\n        # mirror core timing/response fields for convenience\n        self.js_data += 'data[\"bean_key\"] = data[\"resp_key\"];'\n        self.js_data += 'data[\"bean_rt\"] = data[\"rt\"];'\n        self.js_data += 'data[\"bean_onset\"] = data[\"onset_ms\"];'\n        self.js_data += 'data[\"bean_offset\"] = data[\"offset_ms\"];'\n        self.js_data += 'data[\"bean_n_items\"] = data[\"n_items\"];'\n        # optional correctness if a correct_key was supplied\n        self.js_data += (\n            'if (typeof data[\"correct_key\"] !== \"undefined\" &amp;&amp; data[\"correct_key\"] !== null) {'\n            '  var rk = (data[\"resp_key\"] == null) ? null : String(data[\"resp_key\"]).toLowerCase();'\n            '  var ck = String(data[\"correct_key\"]).toLowerCase();'\n            '  data[\"bean_correct\"] = (rk !== null &amp;&amp; rk === ck);'\n            \"}\"\n        )\n\n    def _set_before(self):\n        pass\n\n    def process_l(self, prompts, get_input, multi_turn, datum=None):\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/sweetbean/stimulus/Symbol/#sweetbean.stimulus.Symbol.Symbol.__init__","title":"<code>__init__(*, canvas_width=800, canvas_height=600, background='transparent', items=None, shape=None, color=None, texture=None, duration=None, response_ends_trial=True, choices=None, allow_mouse=False, correct_key=None, side_effects=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>canvas_width</code> <code>int</code> <p>Canvas width in px. Default 800.</p> <code>800</code> <code>canvas_height</code> <code>int</code> <p>Canvas height in px. Default 600.</p> <code>600</code> <code>background</code> <code>str</code> <p>Page background CSS color. Default \"transparent\".</p> <code>'transparent'</code> <code>items</code> <code>list[dict] | None</code> <p>List of shape dicts. Each item supports:</p> <p>Required   - shape: one of       \"circle\" | \"ring\" | \"rectangle\" | \"triangle\" | \"cross\"</p> <p>Size (by shape)   - circle    : radius (int)   - ring      : innerRadius (int), outerRadius (int)   - rectangle : width (int), height (int), cornerRadius (int, opt)   - triangle  : side (int)   - cross     : armLen (int), armWidth (int)</p> <p>Common (optional)   - x, y      : int. Position in px relative to center (default 0,0)   - z         : int. Draw order; higher draws later (default 0)   - rotation  : float deg, clockwise from vertical (default 0)   - alpha     : float 0..1 (default 1)   - blend     : canvas comp-op string. One of:                  \"source-over\",\"lighter\",\"multiply\",\"screen\",                  \"overlay\",\"darken\",\"lighten\",\"difference\",                  \"exclusion\",\"hard-light\",\"soft-light\"   - color     : CSS color string; used if no texture (default \"#000\")   - texture   : dict (see Texture below)   - stroke    : CSS color string (outline). Optional.   - strokePx  : int stroke width (px). Optional.</p> <code>None</code> <code>shape</code> <code>str | None</code> <p>Fast path. If set and <code>items</code> is empty/None, creates a single item {\"shape\": shape}. Useful for one-off trials.</p> <code>None</code> <code>color</code> <code>str | None</code> <p>Broadcast fill color to any item that lacks \"color\". Also applied to the fast-path single item.</p> <code>None</code> <code>texture</code> <code>dict | None</code> <p>Broadcast texture to any item that lacks \"texture\". Also applied to the fast-path single item.</p> <code>None</code> <code>duration</code> <code>int | None</code> <p>Trial timeout in ms. Mapped to plugin key <code>trialDuration</code>.</p> <code>None</code> <code>response_ends_trial</code> <code>bool</code> <p>If True, end on first valid response.</p> <code>True</code> <code>choices</code> <code>list[str] | str | None</code> <p>Allowed keys. None/\"\"/\"NO_KEYS\" \u2192 []; \"ALL\"/\"ALL_KEYS\" \u2192 \"ALL_KEYS\"; a single string becomes [that string].</p> <code>None</code> <code>allow_mouse</code> <code>bool</code> <p>If True, mouse click counts as a response.</p> <code>False</code> <code>correct_key</code> <code>str | None</code> <p>Copied into data; enables simple correctness.</p> <code>None</code> <code>side_effects</code> <code>dict | None</code> <p>SweetBean side-effects configuration.</p> <code>None</code> <code>Texture</code> <p>A texture is a dict with a \"type\" and type-specific fields.</p> <ul> <li> <p>type: \"stripes\"   Fields:     bar    : int period in px (stripe A + stripe B). Default 20.     duty   : float 0..1 fraction for stripe A. Default 0.5.     angle  : float deg; extra rotation added to item.rotation. Default 0.     phase  : int px shift along stripe normal. Default 0.     colors : [str, str] optional two-color palette. If omitted, a              light/dark pair is derived from the item \"color\".</p> </li> <li> <p>type: \"noise\"   Fields:     cell   : int size of each block in px. Default 4.     seed   : int optional RNG seed.     colors : [str, str] optional two-color palette. If omitted, a              light/dark pair is derived from the item \"color\".     mix    : float 0..1 mean toward second color. Default 0.5.</p> </li> </ul> required Source code in <code>sweetbean/stimulus/Symbol.py</code> <pre><code>def __init__(\n    self,\n    *,\n    # ---- Display ----\n    canvas_width: IntLike = 800,\n    canvas_height: IntLike = 600,\n    background: StrLike = \"transparent\",\n    # ---- Content ----\n    items: Optional[Any] = None,  # list[dict] | Var\n    shape: Optional[\n        StrLike\n    ] = None,  # fast path for a single item (only if concrete)\n    color: Optional[StrLike] = None,  # optional broadcast (concrete lists only)\n    texture: Optional[Any] = None,  # optional broadcast (concrete lists only)\n    # ---- Timing / responses ----\n    duration: Optional[IntLike] = None,\n    response_ends_trial: BoolLike = True,\n    choices: Optional[Union[StrLike, StrListLike]] = None,\n    allow_mouse: BoolLike = False,\n    # ---- Scoring convenience ----\n    correct_key: Optional[StrLike] = None,\n    # ---- SweetBean generic ----\n    side_effects: Optional[Dict[str, Any]] = None,\n):\n    \"\"\"\n    Arguments:\n        canvas_width (int): Canvas width in px. Default 800.\n        canvas_height (int): Canvas height in px. Default 600.\n        background (str): Page background CSS color. Default \"transparent\".\n\n        items (list[dict] | None):\n            List of shape dicts. Each item supports:\n\n              Required\n              - shape: one of\n                  \"circle\" | \"ring\" | \"rectangle\" | \"triangle\" | \"cross\"\n\n              Size (by shape)\n              - circle    : radius (int)\n              - ring      : innerRadius (int), outerRadius (int)\n              - rectangle : width (int), height (int), cornerRadius (int, opt)\n              - triangle  : side (int)\n              - cross     : armLen (int), armWidth (int)\n\n              Common (optional)\n              - x, y      : int. Position in px relative to center (default 0,0)\n              - z         : int. Draw order; higher draws later (default 0)\n              - rotation  : float deg, clockwise from vertical (default 0)\n              - alpha     : float 0..1 (default 1)\n              - blend     : canvas comp-op string. One of:\n                             \"source-over\",\"lighter\",\"multiply\",\"screen\",\n                             \"overlay\",\"darken\",\"lighten\",\"difference\",\n                             \"exclusion\",\"hard-light\",\"soft-light\"\n              - color     : CSS color string; used if no texture (default \"#000\")\n              - texture   : dict (see Texture below)\n              - stroke    : CSS color string (outline). Optional.\n              - strokePx  : int stroke width (px). Optional.\n\n        shape (str | None):\n            Fast path. If set and `items` is empty/None, creates a single\n            item {\"shape\": shape}. Useful for one-off trials.\n\n        color (str | None):\n            Broadcast fill color to any item that lacks \"color\".\n            Also applied to the fast-path single item.\n\n        texture (dict | None):\n            Broadcast texture to any item that lacks \"texture\".\n            Also applied to the fast-path single item.\n\n        duration (int | None):\n            Trial timeout in ms. Mapped to plugin key `trialDuration`.\n\n        response_ends_trial (bool): If True, end on first valid response.\n\n        choices (list[str] | str | None):\n            Allowed keys. None/\"\"/\"NO_KEYS\" \u2192 []; \"ALL\"/\"ALL_KEYS\" \u2192 \"ALL_KEYS\";\n            a single string becomes [that string].\n\n        allow_mouse (bool): If True, mouse click counts as a response.\n\n        correct_key (str | None): Copied into data; enables simple correctness.\n\n        side_effects (dict | None): SweetBean side-effects configuration.\n\n        Texture:\n            A texture is a dict with a \"type\" and type-specific fields.\n\n            - type: \"stripes\"\n              Fields:\n                bar    : int period in px (stripe A + stripe B). Default 20.\n                duty   : float 0..1 fraction for stripe A. Default 0.5.\n                angle  : float deg; extra rotation added to item.rotation. Default 0.\n                phase  : int px shift along stripe normal. Default 0.\n                colors : [str, str] optional two-color palette. If omitted, a\n                         light/dark pair is derived from the item \"color\".\n\n            - type: \"noise\"\n              Fields:\n                cell   : int size of each block in px. Default 4.\n                seed   : int optional RNG seed.\n                colors : [str, str] optional two-color palette. If omitted, a\n                         light/dark pair is derived from the item \"color\".\n                mix    : float 0..1 mean toward second color. Default 0.5.\n    \"\"\"\n    # ---------------- items construction / broadcasting ----------------\n    items_final: Any = items\n\n    # Heuristic for \"variable-like\": we only treat as concrete when it's a Python list of dicts\n    is_concrete_list = isinstance(items_final, list) and all(\n        isinstance(it, dict) for it in items_final\n    )\n    is_empty_or_none = (items_final is None) or (\n        isinstance(items_final, list) and len(items_final) == 0\n    )\n\n    # Single-item fast path ONLY when shape is a concrete string and items isn't provided\n    if is_empty_or_none and isinstance(shape, str) and shape.strip():\n        one: Dict[str, Any] = {\"shape\": shape.strip()}\n        if color not in (None, \"null\"):\n            one[\"color\"] = color\n        if texture not in (None, \"null\"):\n            one[\"texture\"] = texture\n        items_final = [one]\n        is_concrete_list = True\n\n    # Broadcast top-level color/texture ONLY when we truly have a concrete list\n    if is_concrete_list and (\n        color not in (None, \"null\") or texture not in (None, \"null\")\n    ):\n        out: List[Dict[str, Any]] = []\n        for it in items_final:  # type: ignore[iteration-over-optional]\n            tmp = dict(it)\n            # Add color only if item doesn't specify it\n            if color not in (None, \"null\") and (\"color\" not in tmp):\n                tmp[\"color\"] = color\n            # Add texture only if item doesn't specify it\n            if texture not in (None, \"null\") and (\"texture\" not in tmp):\n                tmp[\"texture\"] = texture\n            out.append(tmp)\n        items_final = out\n\n    # ---------------- choices normalization (keep Vars untouched) ----------------\n    choices_final: Any = choices\n    if not hasattr(choices, \"__dict__\") and not callable(choices):\n        if choices in (None, \"NO_KEYS\", \"no_keys\", \"\", []):\n            choices_final = []\n        elif isinstance(choices, str):\n            s = choices.strip()\n            choices_final = \"ALL_KEYS\" if s.lower() in (\"all\", \"all_keys\") else [s]\n        elif isinstance(choices, list):\n            choices_final = choices\n\n    # ---------------- build params for plugin ----------------\n    params: Dict[str, Any] = {\n        \"canvasWidth\": canvas_width,\n        \"canvasHeight\": canvas_height,\n        \"background\": background,\n        \"items\": items_final,\n        \"trialDuration\": duration,  # single source of truth\n        \"responseEndsTrial\": response_ends_trial,\n        \"choices\": choices_final,\n        \"allowMouse\": allow_mouse,\n        # pass-through for scoring convenience (not a plugin param)\n        \"correct_key\": correct_key,\n    }\n\n    super().__init__(params, side_effects)\n</code></pre>"},{"location":"reference/sweetbean/stimulus/Video/","title":"sweetbean.stimulus.Video","text":""},{"location":"reference/sweetbean/stimulus/Video/#sweetbean.stimulus.Video.Video","title":"<code>Video</code>","text":"<p>               Bases: <code>_KeyboardResponseStimulus</code></p> <p>shows a video</p> Source code in <code>sweetbean/stimulus/Video.py</code> <pre><code>class Video(_KeyboardResponseStimulus):\n    \"\"\"\n    shows a video\n    \"\"\"\n\n    # correct jsPsych plugin id\n    type = \"jsPsychVideoKeyboardResponse\"\n\n    def __init__(\n        self,\n        duration: Optional[int] = None,  # alias for trial_duration\n        stimulus: Optional[\n            Union[str, List[str]]\n        ] = None,  # single URL/path or list of sources\n        choices=None,  # e.g., [\"f\",\"j\"] | \"ALL\" | \"NO_KEYS\"\n        correct_key: str = \"\",\n        trial_ends_after_video: bool = True,\n        autoplay: bool = True,\n        controls: bool = False,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        muted: bool = True,  # helpful for autoplay policies\n        side_effects=None,\n    ):\n        \"\"\"\n        Arguments:\n            duration: time in ms the stimulus is presented (alias for trial_duration)\n            stimulus: video source(s). Either a single string or a list of strings (URLs/paths).\n                 You can specify multiple formats of the same video (e.g., .mp4, .ogg, .webm)\n                 to maximize the cross-browser compatibility.\n            choices: keys to accept (e.g., [\"f\",\"j\"]), or \"ALL\" / \"NO_KEYS\"\n            correct_key: the correct key to press (optional)\n            trial_ends_after_video: end the trial automatically when video finishes\n            autoplay: start playback automatically\n            controls: show native video controls\n            width, height: optional pixel dimensions\n            muted: mute audio (often required for autoplay)\n            side_effects: Optional side-effect configuration passed to the runtime. This expects\n                a list of SideEffect definitions (see SweetBean docs) which can be\n                used to update global data like overall score or trial counter.\n        \"\"\"\n        if isinstance(stimulus, str):\n            stimulus = [stimulus]\n        super().__init__(locals(), side_effects=side_effects)\n\n    def _add_special_param(self):\n        # duration -&gt; trial_duration (SweetBean convention)\n        if self.arg_js.get(\"duration\") not in (None, \"null\"):\n            self.arg_js[\"trial_duration\"] = self.arg_js[\"duration\"]\n\n        # Normalize stimulus to a list[str] for jsPsych video plugin\n        stim = self.arg_js.get(\"stimulus\")\n        if isinstance(stim, str) and stim:\n            self.arg_js[\"stimulus\"] = [stim]\n        elif isinstance(stim, list):\n            # leave as-is (assumed list[str])\n            pass\n        # else: leave None; jsPsych will error if missing, which is fine for dev feedback\n\n        # Keep declarative type\n        self.arg_js[\"type\"] = self.type\n\n    def _process_response(self):\n        # convenience mirrors to align with other keyboard-response wrappers\n        self.js_data += 'data[\"bean_key\"] = data[\"key_press\"];'\n        self.js_data += 'data[\"bean_rt\"] = data[\"rt\"];'\n\n    def _set_before(self):\n        pass\n</code></pre>"},{"location":"reference/sweetbean/stimulus/Video/#sweetbean.stimulus.Video.Video.__init__","title":"<code>__init__(duration=None, stimulus=None, choices=None, correct_key='', trial_ends_after_video=True, autoplay=True, controls=False, width=None, height=None, muted=True, side_effects=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>duration</code> <code>Optional[int]</code> <p>time in ms the stimulus is presented (alias for trial_duration)</p> <code>None</code> <code>stimulus</code> <code>Optional[Union[str, List[str]]]</code> <p>video source(s). Either a single string or a list of strings (URLs/paths).  You can specify multiple formats of the same video (e.g., .mp4, .ogg, .webm)  to maximize the cross-browser compatibility.</p> <code>None</code> <code>choices</code> <p>keys to accept (e.g., [\"f\",\"j\"]), or \"ALL\" / \"NO_KEYS\"</p> <code>None</code> <code>correct_key</code> <code>str</code> <p>the correct key to press (optional)</p> <code>''</code> <code>trial_ends_after_video</code> <code>bool</code> <p>end the trial automatically when video finishes</p> <code>True</code> <code>autoplay</code> <code>bool</code> <p>start playback automatically</p> <code>True</code> <code>controls</code> <code>bool</code> <p>show native video controls</p> <code>False</code> <code>width, height</code> <p>optional pixel dimensions</p> required <code>muted</code> <code>bool</code> <p>mute audio (often required for autoplay)</p> <code>True</code> <code>side_effects</code> <p>Optional side-effect configuration passed to the runtime. This expects a list of SideEffect definitions (see SweetBean docs) which can be used to update global data like overall score or trial counter.</p> <code>None</code> Source code in <code>sweetbean/stimulus/Video.py</code> <pre><code>def __init__(\n    self,\n    duration: Optional[int] = None,  # alias for trial_duration\n    stimulus: Optional[\n        Union[str, List[str]]\n    ] = None,  # single URL/path or list of sources\n    choices=None,  # e.g., [\"f\",\"j\"] | \"ALL\" | \"NO_KEYS\"\n    correct_key: str = \"\",\n    trial_ends_after_video: bool = True,\n    autoplay: bool = True,\n    controls: bool = False,\n    width: Optional[int] = None,\n    height: Optional[int] = None,\n    muted: bool = True,  # helpful for autoplay policies\n    side_effects=None,\n):\n    \"\"\"\n    Arguments:\n        duration: time in ms the stimulus is presented (alias for trial_duration)\n        stimulus: video source(s). Either a single string or a list of strings (URLs/paths).\n             You can specify multiple formats of the same video (e.g., .mp4, .ogg, .webm)\n             to maximize the cross-browser compatibility.\n        choices: keys to accept (e.g., [\"f\",\"j\"]), or \"ALL\" / \"NO_KEYS\"\n        correct_key: the correct key to press (optional)\n        trial_ends_after_video: end the trial automatically when video finishes\n        autoplay: start playback automatically\n        controls: show native video controls\n        width, height: optional pixel dimensions\n        muted: mute audio (often required for autoplay)\n        side_effects: Optional side-effect configuration passed to the runtime. This expects\n            a list of SideEffect definitions (see SweetBean docs) which can be\n            used to update global data like overall score or trial counter.\n    \"\"\"\n    if isinstance(stimulus, str):\n        stimulus = [stimulus]\n    super().__init__(locals(), side_effects=side_effects)\n</code></pre>"},{"location":"reference/sweetbean/util/","title":"sweetbean.util","text":""},{"location":"reference/sweetbean/util/data_process/","title":"sweetbean.util.data_process","text":""},{"location":"reference/sweetbean/util/data_process/#sweetbean.util.data_process.process","title":"<code>process(stimulus_data, n_stims, idx=None)</code>","text":"<p>Process list of stimulus to list of trials. For example, if the stimulus sequence is [Fixation, Text, Feedback] a list of all stimuli will be processed so that Fixation, Text and Feedback are bundled into one trial. Arguments:     stimulus_data: the list of stimulus data     n_stims: the number of stimuli in a sequence (3 in the above example)</p> Source code in <code>sweetbean/util/data_process.py</code> <pre><code>def process(stimulus_data, n_stims, idx=None):\n    \"\"\"\n    Process list of stimulus to list of trials. For example, if the stimulus sequence is\n    [Fixation, Text, Feedback] a list of all stimuli will be processed so that\n    Fixation, Text and Feedback are bundled into one trial.\n    Arguments:\n        stimulus_data: the list of stimulus data\n        n_stims: the number of stimuli in a sequence (3 in the above example)\n    \"\"\"\n    if len(stimulus_data) % n_stims != 0:\n        print(\"Stimulus data could not be processed.\")\n        return []\n\n    len_timeline = len(stimulus_data) // n_stims\n\n    if idx is not None:\n        res = [{\"exp_id\": idx} for _ in range(len_timeline)]\n    else:\n        res = [{} for _ in range(len_timeline)]\n    for i, stim_dict in enumerate(stimulus_data):\n        stim_index = i % n_stims\n        for k, v in stim_dict.items():\n            new_key = f\"{k}.{stim_index}\"\n            res[i // n_stims][new_key] = v\n    return res\n</code></pre>"},{"location":"reference/sweetbean/util/data_process/#sweetbean.util.data_process.process_autora","title":"<code>process_autora(data, n_stims, as_dict=True)</code>","text":"<p>Process data when using AutoRA experiment runner (https://autoresearch.github.io/autora/) Arguments:     data: the data to process     n_stims: the number of stimuli in a sequence (3 in the above example)     as_dict: whether to return a dictionary (can be used for pandas dataframe)</p> Source code in <code>sweetbean/util/data_process.py</code> <pre><code>def process_autora(data, n_stims, as_dict=True):\n    \"\"\"\n    Process data when using AutoRA experiment runner (https://autoresearch.github.io/autora/)\n    Arguments:\n        data: the data to process\n        n_stims: the number of stimuli in a sequence (3 in the above example)\n        as_dict: whether to return a dictionary (can be used for pandas dataframe)\n    \"\"\"\n    res = []\n    for idx, subj_d in enumerate(data):\n        try:\n            _subj_d = subj_d\n            if type(subj_d) == str:\n                _subj_d = json.loads(subj_d)\n            d = _subj_d[\"trials\"]\n            processed = process(d, n_stims, idx)\n            res += processed\n        except Exception as e:\n            print(f\"ERROR with: {subj_d}, {e}\")\n    if as_dict:\n        _as_dict = {}\n        try:\n            _as_dict = _list_of_dicts_to_dataframe(res)\n        except Exception as e:\n            print(f\"ERROR with: {res}, {e}\")\n        return _as_dict\n    return res\n</code></pre>"},{"location":"reference/sweetbean/util/io/","title":"sweetbean.util.io","text":""},{"location":"reference/sweetbean/variable/","title":"sweetbean.variable","text":""},{"location":"reference/sweetbean/variable/#sweetbean.variable.CodeVariable","title":"<code>CodeVariable</code>","text":"<p>               Bases: <code>Variable</code></p> <p>A variable to access JavaScript code.</p> Source code in <code>sweetbean/variable/__init__.py</code> <pre><code>class CodeVariable(Variable):\n    \"\"\"\n    A variable to access JavaScript code.\n    \"\"\"\n\n    def __init__(self, name, value):\n        \"\"\"\n        Arguments:\n            name: the name of the variable\n            value: the initial value of the variable\n        \"\"\"\n        super().__init__(name)\n        self.value = value\n\n    def set(self):\n        return f\"let {self.name}={self.value};\"\n\n    def to_js(self):\n        return self.name\n</code></pre>"},{"location":"reference/sweetbean/variable/#sweetbean.variable.CodeVariable.__init__","title":"<code>__init__(name, value)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <p>the name of the variable</p> required <code>value</code> <p>the initial value of the variable</p> required Source code in <code>sweetbean/variable/__init__.py</code> <pre><code>def __init__(self, name, value):\n    \"\"\"\n    Arguments:\n        name: the name of the variable\n        value: the initial value of the variable\n    \"\"\"\n    super().__init__(name)\n    self.value = value\n</code></pre>"},{"location":"reference/sweetbean/variable/#sweetbean.variable.DataVariable","title":"<code>DataVariable</code>","text":"<p>               Bases: <code>Variable</code></p> <p>A data variable for jsPsych to access data of previous trials.</p> Source code in <code>sweetbean/variable/__init__.py</code> <pre><code>class DataVariable(Variable):\n    \"\"\"\n    A data variable for jsPsych to access data of previous trials.\n    \"\"\"\n\n    def __init__(self, name, window):\n        \"\"\"\n        Arguments:\n            name: the name of the variable\n            window: the window of the data\n        \"\"\"\n        super().__init__(name)\n        self.name = f'data[\"bean_{name}\"]'\n        self.raw_name = name\n        self.window = window\n\n    def to_js(self):\n        if self.window == 0:\n            return self.name\n        return f\"jsPsych.data.get().last({self.window})['trials'][0]['bean_{self.raw_name}']\"\n</code></pre>"},{"location":"reference/sweetbean/variable/#sweetbean.variable.DataVariable.__init__","title":"<code>__init__(name, window)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <p>the name of the variable</p> required <code>window</code> <p>the window of the data</p> required Source code in <code>sweetbean/variable/__init__.py</code> <pre><code>def __init__(self, name, window):\n    \"\"\"\n    Arguments:\n        name: the name of the variable\n        window: the window of the data\n    \"\"\"\n    super().__init__(name)\n    self.name = f'data[\"bean_{name}\"]'\n    self.raw_name = name\n    self.window = window\n</code></pre>"},{"location":"reference/sweetbean/variable/#sweetbean.variable.FunctionVariable","title":"<code>FunctionVariable</code>","text":"<p>               Bases: <code>Variable</code></p> <p>A variable that is the result of a function. Examples:     &gt;&gt;&gt; def add(a, b):     ...     return a + b     &gt;&gt;&gt; FunctionVariable('a', add, [1, 2]).to_js()     ((a,b) =&gt; {return a+b})(1, 2)</p> Source code in <code>sweetbean/variable/__init__.py</code> <pre><code>class FunctionVariable(Variable):\n    \"\"\"\n    A variable that is the result of a function.\n    Examples:\n        &gt;&gt;&gt; def add(a, b):\n        ...     return a + b\n        &gt;&gt;&gt; FunctionVariable('a', add, [1, 2]).to_js()\n        ((a,b) =&gt; {return a+b})(1, 2)\n\n    \"\"\"\n\n    def __init__(self, name, fct, args):\n        \"\"\"\n        Arguments:\n            name: the name of the variable\n            fct: the function\n            args: the arguments of the function\n        \"\"\"\n        super().__init__(name)\n        self.fct = fct\n        self.args = args\n\n    def to_js(self):\n        fct_declaration = _fct_to_js(self.fct)\n        fct_input = _fct_args_to_js(self.args)\n        return f\"({fct_declaration}){fct_input}\"\n</code></pre>"},{"location":"reference/sweetbean/variable/#sweetbean.variable.FunctionVariable.__init__","title":"<code>__init__(name, fct, args)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <p>the name of the variable</p> required <code>fct</code> <p>the function</p> required <code>args</code> <p>the arguments of the function</p> required Source code in <code>sweetbean/variable/__init__.py</code> <pre><code>def __init__(self, name, fct, args):\n    \"\"\"\n    Arguments:\n        name: the name of the variable\n        fct: the function\n        args: the arguments of the function\n    \"\"\"\n    super().__init__(name)\n    self.fct = fct\n    self.args = args\n</code></pre>"},{"location":"reference/sweetbean/variable/#sweetbean.variable.SharedVariable","title":"<code>SharedVariable</code>","text":"<p>A variable that can be shared between different stimuli.</p> Source code in <code>sweetbean/variable/__init__.py</code> <pre><code>class SharedVariable:\n    \"\"\"\n    A variable that can be shared between different stimuli.\n    \"\"\"\n\n    def __init__(self, name, value):\n        \"\"\"\n        Arguments:\n            name: the name of the variable\n            value: the initial value of the variable\n        \"\"\"\n        self.name = str(name)\n        self.value = value\n\n    def set(self):\n        return f\"let {self.name}={self.value};\"\n\n    def to_js(self):\n        return self.name\n</code></pre>"},{"location":"reference/sweetbean/variable/#sweetbean.variable.SharedVariable.__init__","title":"<code>__init__(name, value)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <p>the name of the variable</p> required <code>value</code> <p>the initial value of the variable</p> required Source code in <code>sweetbean/variable/__init__.py</code> <pre><code>def __init__(self, name, value):\n    \"\"\"\n    Arguments:\n        name: the name of the variable\n        value: the initial value of the variable\n    \"\"\"\n    self.name = str(name)\n    self.value = value\n</code></pre>"},{"location":"reference/sweetbean/variable/#sweetbean.variable.SideEffect","title":"<code>SideEffect</code>","text":"Source code in <code>sweetbean/variable/__init__.py</code> <pre><code>class SideEffect:\n    def __init__(self, set_variable, get_variable):\n        \"\"\"\n        A side effect that can set variables.\n\n        Arguments:\n            set_variable: the variable to set (often a SharedVariable)\n            get_variable: the variable to get (e.g, the variable the set variable should be set to)\n        \"\"\"\n        self.set_variable = set_variable\n        self.get_variable = get_variable\n\n    def to_js(self):\n        return f\"{self.set_variable.name}={_var_to_js(self.get_variable)};\"\n</code></pre>"},{"location":"reference/sweetbean/variable/#sweetbean.variable.SideEffect.__init__","title":"<code>__init__(set_variable, get_variable)</code>","text":"<p>A side effect that can set variables.</p> <p>Parameters:</p> Name Type Description Default <code>set_variable</code> <p>the variable to set (often a SharedVariable)</p> required <code>get_variable</code> <p>the variable to get (e.g, the variable the set variable should be set to)</p> required Source code in <code>sweetbean/variable/__init__.py</code> <pre><code>def __init__(self, set_variable, get_variable):\n    \"\"\"\n    A side effect that can set variables.\n\n    Arguments:\n        set_variable: the variable to set (often a SharedVariable)\n        get_variable: the variable to get (e.g, the variable the set variable should be set to)\n    \"\"\"\n    self.set_variable = set_variable\n    self.get_variable = get_variable\n</code></pre>"},{"location":"reference/sweetbean/variable/#sweetbean.variable.TimelineVariable","title":"<code>TimelineVariable</code>","text":"<p>               Bases: <code>Variable</code></p> <p>A timeline variable for jsPsych.</p> Source code in <code>sweetbean/variable/__init__.py</code> <pre><code>class TimelineVariable(Variable):\n    \"\"\"\n    A timeline variable for jsPsych.\n    \"\"\"\n\n    def to_js(self):\n        return f\"jsPsych.timelineVariable('{self.name}')\"\n</code></pre>"},{"location":"reference/sweetbean/variable/#sweetbean.variable.Variable","title":"<code>Variable</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A base class for variables.</p> Source code in <code>sweetbean/variable/__init__.py</code> <pre><code>class Variable(ABC):\n    \"\"\"\n    A base class for variables.\n    \"\"\"\n\n    def __init__(self, name):\n        self.name = name\n\n    @abstractmethod\n    def to_js(self):\n        pass\n</code></pre>"}]}